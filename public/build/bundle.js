
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.head.appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if (typeof $$scope.dirty === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        if (value != null || input.value) {
            input.value = value;
        }
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    const seen_callbacks = new Set();
    function flush() {
        do {
            // first, call beforeUpdate functions
            // and update components
            while (dirty_components.length) {
                const component = dirty_components.shift();
                set_current_component(component);
                update(component.$$);
            }
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined' ? window : global);
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error(`Cannot have duplicate keys in a keyed each`);
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if ($$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(children(options.target));
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.18.1' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev("SvelteDOMInsert", { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev("SvelteDOMInsert", { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev("SvelteDOMRemove", { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
        else
            dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev("SvelteDOMSetData", { node: text, data });
        text.data = data;
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
    }

    function styleInject(css, ref) {
      if ( ref === void 0 ) ref = {};
      var insertAt = ref.insertAt;

      if (!css || typeof document === 'undefined') { return; }

      var head = document.head || document.getElementsByTagName('head')[0];
      var style = document.createElement('style');
      style.type = 'text/css';

      if (insertAt === 'top') {
        if (head.firstChild) {
          head.insertBefore(style, head.firstChild);
        } else {
          head.appendChild(style);
        }
      } else {
        head.appendChild(style);
      }

      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
    }

    var css = ".mdc-button{padding:0;min-width:24px}.mdc-button:after,.mdc-button:before{background:none}.mdc-menu{max-width:450px}.mdc-menu-surface{top:50px!important}.mdc-tab-bar{position:static}.mdc-list{height:300px;overflow:hidden;overflow-y:scroll;scroll-behavior:smooth;scrollbar-width:5px}::-webkit-scrollbar{width:5px}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px rgba(0,0,0,.3);-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);-webkit-border-radius:5px;border-radius:5px}::-webkit-scrollbar-thumb{-webkit-border-radius:5px;border-radius:5px;background:rgba(196,183,183,.8);-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.5);box-shadow:inset 0 0 6px rgba(0,0,0,.5)}::-webkit-scrollbar-thumb:window-inactive{background:rgba(138,129,129,.4)}.mdc-menu-surface{display:none;position:absolute;box-sizing:border-box;max-width:calc(100vw - 32px);max-height:calc(100vh - 32px);margin:0;padding:0;transform:scale(1);transform-origin:top left;opacity:0;overflow:auto;will-change:transform,opacity;z-index:8;transition:opacity .03s linear,transform .12s cubic-bezier(0,0,.2,1);box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);background-color:#fff;background-color:var(--mdc-theme-surface,#fff);color:#000;color:var(--mdc-theme-on-surface,#000);border-radius:4px;transform-origin-left:top left;transform-origin-right:top right}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--open{display:inline-block;transform:scale(1);opacity:1}.mdc-menu-surface--animating-open{display:inline-block;transform:scale(.8);opacity:0}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0;transition:opacity 75ms linear}.mdc-menu-surface[dir=rtl],[dir=rtl] .mdc-menu-surface{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{position:relative;overflow:visible}.mdc-menu-surface--fixed{position:fixed}.smui-menu-surface--static{position:static;z-index:0;display:inline-block;transform:scale(1);opacity:1}";
    styleInject(css);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cachedCssTransformPropertyName_;
    /**
     * Returns the name of the correct transform property to use on the current browser.
     */
    function getTransformPropertyName(globalObj, forceRefresh) {
        if (forceRefresh === void 0) { forceRefresh = false; }
        if (cachedCssTransformPropertyName_ === undefined || forceRefresh) {
            var el = globalObj.document.createElement('div');
            cachedCssTransformPropertyName_ = 'transform' in el.style ? 'transform' : 'webkitTransform';
        }
        return cachedCssTransformPropertyName_;
    }
    //# sourceMappingURL=util.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses = {
        ANCHOR: 'mdc-menu-surface--anchor',
        ANIMATING_CLOSED: 'mdc-menu-surface--animating-closed',
        ANIMATING_OPEN: 'mdc-menu-surface--animating-open',
        FIXED: 'mdc-menu-surface--fixed',
        OPEN: 'mdc-menu-surface--open',
        ROOT: 'mdc-menu-surface',
    };
    // tslint:disable:object-literal-sort-keys
    var strings = {
        CLOSED_EVENT: 'MDCMenuSurface:closed',
        OPENED_EVENT: 'MDCMenuSurface:opened',
        FOCUSABLE_ELEMENTS: [
            'button:not(:disabled)', '[href]:not([aria-disabled="true"])', 'input:not(:disabled)',
            'select:not(:disabled)', 'textarea:not(:disabled)', '[tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])',
        ].join(', '),
    };
    // tslint:enable:object-literal-sort-keys
    var numbers = {
        /** Total duration of menu-surface open animation. */
        TRANSITION_OPEN_DURATION: 120,
        /** Total duration of menu-surface close animation. */
        TRANSITION_CLOSE_DURATION: 75,
        /** Margin left to the edge of the viewport when menu-surface is at maximum possible height. */
        MARGIN_TO_EDGE: 32,
        /** Ratio of anchor width to menu-surface width for switching from corner positioning to center positioning. */
        ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,
    };
    /**
     * Enum for bits in the {@see Corner) bitmap.
     */
    var CornerBit;
    (function (CornerBit) {
        CornerBit[CornerBit["BOTTOM"] = 1] = "BOTTOM";
        CornerBit[CornerBit["CENTER"] = 2] = "CENTER";
        CornerBit[CornerBit["RIGHT"] = 4] = "RIGHT";
        CornerBit[CornerBit["FLIP_RTL"] = 8] = "FLIP_RTL";
    })(CornerBit || (CornerBit = {}));
    /**
     * Enum for representing an element corner for positioning the menu-surface.
     *
     * The START constants map to LEFT if element directionality is left
     * to right and RIGHT if the directionality is right to left.
     * Likewise END maps to RIGHT or LEFT depending on the directionality.
     */
    var Corner;
    (function (Corner) {
        Corner[Corner["TOP_LEFT"] = 0] = "TOP_LEFT";
        Corner[Corner["TOP_RIGHT"] = 4] = "TOP_RIGHT";
        Corner[Corner["BOTTOM_LEFT"] = 1] = "BOTTOM_LEFT";
        Corner[Corner["BOTTOM_RIGHT"] = 5] = "BOTTOM_RIGHT";
        Corner[Corner["TOP_START"] = 8] = "TOP_START";
        Corner[Corner["TOP_END"] = 12] = "TOP_END";
        Corner[Corner["BOTTOM_START"] = 9] = "BOTTOM_START";
        Corner[Corner["BOTTOM_END"] = 13] = "BOTTOM_END";
    })(Corner || (Corner = {}));
    //# sourceMappingURL=constants.js.map

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCFoundation = /** @class */ (function () {
        function MDCFoundation(adapter) {
            if (adapter === void 0) { adapter = {}; }
            this.adapter_ = adapter;
        }
        Object.defineProperty(MDCFoundation, "cssClasses", {
            get: function () {
                // Classes extending MDCFoundation should implement this method to return an object which exports every
                // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
                return {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCFoundation, "strings", {
            get: function () {
                // Classes extending MDCFoundation should implement this method to return an object which exports all
                // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
                return {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCFoundation, "numbers", {
            get: function () {
                // Classes extending MDCFoundation should implement this method to return an object which exports all
                // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
                return {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCFoundation, "defaultAdapter", {
            get: function () {
                // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
                // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
                // validation.
                return {};
            },
            enumerable: true,
            configurable: true
        });
        MDCFoundation.prototype.init = function () {
            // Subclasses should override this method to perform initialization routines (registering events, etc.)
        };
        MDCFoundation.prototype.destroy = function () {
            // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        };
        return MDCFoundation;
    }());
    //# sourceMappingURL=foundation.js.map

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCComponent = /** @class */ (function () {
        function MDCComponent(root, foundation) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            this.root_ = root;
            this.initialize.apply(this, __spread(args));
            // Note that we initialize foundation here and not within the constructor's default param so that
            // this.root_ is defined and can be used within the foundation class.
            this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
            this.foundation_.init();
            this.initialSyncWithDOM();
        }
        MDCComponent.attachTo = function (root) {
            // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
            // returns an instantiated component with its root set to that element. Also note that in the cases of
            // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
            // from getDefaultFoundation().
            return new MDCComponent(root, new MDCFoundation({}));
        };
        /* istanbul ignore next: method param only exists for typing purposes; it does not need to be unit tested */
        MDCComponent.prototype.initialize = function () {
            var _args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                _args[_i] = arguments[_i];
            }
            // Subclasses can override this to do any additional setup work that would be considered part of a
            // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
            // initialized. Any additional arguments besides root and foundation will be passed in here.
        };
        MDCComponent.prototype.getDefaultFoundation = function () {
            // Subclasses must override this method to return a properly configured foundation class for the
            // component.
            throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' +
                'foundation class');
        };
        MDCComponent.prototype.initialSyncWithDOM = function () {
            // Subclasses should override this method if they need to perform work to synchronize with a host DOM
            // object. An example of this would be a form control wrapper that needs to synchronize its internal state
            // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
            // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        };
        MDCComponent.prototype.destroy = function () {
            // Subclasses may implement this method to release any resources / deregister any listeners they have
            // attached. An example of this might be deregistering a resize event from the window object.
            this.foundation_.destroy();
        };
        MDCComponent.prototype.listen = function (evtType, handler, options) {
            this.root_.addEventListener(evtType, handler, options);
        };
        MDCComponent.prototype.unlisten = function (evtType, handler, options) {
            this.root_.removeEventListener(evtType, handler, options);
        };
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type, with the given data.
         */
        MDCComponent.prototype.emit = function (evtType, evtData, shouldBubble) {
            if (shouldBubble === void 0) { shouldBubble = false; }
            var evt;
            if (typeof CustomEvent === 'function') {
                evt = new CustomEvent(evtType, {
                    bubbles: shouldBubble,
                    detail: evtData,
                });
            }
            else {
                evt = document.createEvent('CustomEvent');
                evt.initCustomEvent(evtType, shouldBubble, false, evtData);
            }
            this.root_.dispatchEvent(evt);
        };
        return MDCComponent;
    }());
    //# sourceMappingURL=component.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCMenuSurfaceFoundation = /** @class */ (function (_super) {
        __extends(MDCMenuSurfaceFoundation, _super);
        function MDCMenuSurfaceFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCMenuSurfaceFoundation.defaultAdapter, adapter)) || this;
            _this.isOpen_ = false;
            _this.isQuickOpen_ = false;
            _this.isHoistedElement_ = false;
            _this.isFixedPosition_ = false;
            _this.openAnimationEndTimerId_ = 0;
            _this.closeAnimationEndTimerId_ = 0;
            _this.animationRequestId_ = 0;
            _this.anchorCorner_ = Corner.TOP_START;
            _this.anchorMargin_ = { top: 0, right: 0, bottom: 0, left: 0 };
            _this.position_ = { x: 0, y: 0 };
            return _this;
        }
        Object.defineProperty(MDCMenuSurfaceFoundation, "cssClasses", {
            get: function () {
                return cssClasses;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenuSurfaceFoundation, "strings", {
            get: function () {
                return strings;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenuSurfaceFoundation, "numbers", {
            get: function () {
                return numbers;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenuSurfaceFoundation, "Corner", {
            get: function () {
                return Corner;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenuSurfaceFoundation, "defaultAdapter", {
            /**
             * @see {@link MDCMenuSurfaceAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    hasClass: function () { return false; },
                    hasAnchor: function () { return false; },
                    isElementInContainer: function () { return false; },
                    isFocused: function () { return false; },
                    isRtl: function () { return false; },
                    getInnerDimensions: function () { return ({ height: 0, width: 0 }); },
                    getAnchorDimensions: function () { return null; },
                    getWindowDimensions: function () { return ({ height: 0, width: 0 }); },
                    getBodyDimensions: function () { return ({ height: 0, width: 0 }); },
                    getWindowScroll: function () { return ({ x: 0, y: 0 }); },
                    setPosition: function () { return undefined; },
                    setMaxHeight: function () { return undefined; },
                    setTransformOrigin: function () { return undefined; },
                    saveFocus: function () { return undefined; },
                    restoreFocus: function () { return undefined; },
                    notifyClose: function () { return undefined; },
                    notifyOpen: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCMenuSurfaceFoundation.prototype.init = function () {
            var _a = MDCMenuSurfaceFoundation.cssClasses, ROOT = _a.ROOT, OPEN = _a.OPEN;
            if (!this.adapter_.hasClass(ROOT)) {
                throw new Error(ROOT + " class required in root element.");
            }
            if (this.adapter_.hasClass(OPEN)) {
                this.isOpen_ = true;
            }
        };
        MDCMenuSurfaceFoundation.prototype.destroy = function () {
            clearTimeout(this.openAnimationEndTimerId_);
            clearTimeout(this.closeAnimationEndTimerId_);
            // Cancel any currently running animations.
            cancelAnimationFrame(this.animationRequestId_);
        };
        /**
         * @param corner Default anchor corner alignment of top-left menu surface corner.
         */
        MDCMenuSurfaceFoundation.prototype.setAnchorCorner = function (corner) {
            this.anchorCorner_ = corner;
        };
        /**
         * @param margin Set of margin values from anchor.
         */
        MDCMenuSurfaceFoundation.prototype.setAnchorMargin = function (margin) {
            this.anchorMargin_.top = margin.top || 0;
            this.anchorMargin_.right = margin.right || 0;
            this.anchorMargin_.bottom = margin.bottom || 0;
            this.anchorMargin_.left = margin.left || 0;
        };
        /** Used to indicate if the menu-surface is hoisted to the body. */
        MDCMenuSurfaceFoundation.prototype.setIsHoisted = function (isHoisted) {
            this.isHoistedElement_ = isHoisted;
        };
        /** Used to set the menu-surface calculations based on a fixed position menu. */
        MDCMenuSurfaceFoundation.prototype.setFixedPosition = function (isFixedPosition) {
            this.isFixedPosition_ = isFixedPosition;
        };
        /** Sets the menu-surface position on the page. */
        MDCMenuSurfaceFoundation.prototype.setAbsolutePosition = function (x, y) {
            this.position_.x = this.isFinite_(x) ? x : 0;
            this.position_.y = this.isFinite_(y) ? y : 0;
        };
        MDCMenuSurfaceFoundation.prototype.setQuickOpen = function (quickOpen) {
            this.isQuickOpen_ = quickOpen;
        };
        MDCMenuSurfaceFoundation.prototype.isOpen = function () {
            return this.isOpen_;
        };
        /**
         * Open the menu surface.
         */
        MDCMenuSurfaceFoundation.prototype.open = function () {
            var _this = this;
            this.adapter_.saveFocus();
            if (!this.isQuickOpen_) {
                this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
            }
            this.animationRequestId_ = requestAnimationFrame(function () {
                _this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
                _this.dimensions_ = _this.adapter_.getInnerDimensions();
                _this.autoPosition_();
                if (_this.isQuickOpen_) {
                    _this.adapter_.notifyOpen();
                }
                else {
                    _this.openAnimationEndTimerId_ = setTimeout(function () {
                        _this.openAnimationEndTimerId_ = 0;
                        _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
                        _this.adapter_.notifyOpen();
                    }, numbers.TRANSITION_OPEN_DURATION);
                }
            });
            this.isOpen_ = true;
        };
        /**
         * Closes the menu surface.
         */
        MDCMenuSurfaceFoundation.prototype.close = function (skipRestoreFocus) {
            var _this = this;
            if (skipRestoreFocus === void 0) { skipRestoreFocus = false; }
            if (!this.isQuickOpen_) {
                this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
            }
            requestAnimationFrame(function () {
                _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
                if (_this.isQuickOpen_) {
                    _this.adapter_.notifyClose();
                }
                else {
                    _this.closeAnimationEndTimerId_ = setTimeout(function () {
                        _this.closeAnimationEndTimerId_ = 0;
                        _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
                        _this.adapter_.notifyClose();
                    }, numbers.TRANSITION_CLOSE_DURATION);
                }
            });
            this.isOpen_ = false;
            if (!skipRestoreFocus) {
                this.maybeRestoreFocus_();
            }
        };
        /** Handle clicks and close if not within menu-surface element. */
        MDCMenuSurfaceFoundation.prototype.handleBodyClick = function (evt) {
            var el = evt.target;
            if (this.adapter_.isElementInContainer(el)) {
                return;
            }
            this.close();
        };
        /** Handle keys that close the surface. */
        MDCMenuSurfaceFoundation.prototype.handleKeydown = function (evt) {
            var keyCode = evt.keyCode, key = evt.key;
            var isEscape = key === 'Escape' || keyCode === 27;
            if (isEscape) {
                this.close();
            }
        };
        MDCMenuSurfaceFoundation.prototype.autoPosition_ = function () {
            var _a;
            // Compute measurements for autoposition methods reuse.
            this.measurements_ = this.getAutoLayoutMeasurements_();
            var corner = this.getOriginCorner_();
            var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight_(corner);
            var verticalAlignment = this.hasBit_(corner, CornerBit.BOTTOM) ? 'bottom' : 'top';
            var horizontalAlignment = this.hasBit_(corner, CornerBit.RIGHT) ? 'right' : 'left';
            var horizontalOffset = this.getHorizontalOriginOffset_(corner);
            var verticalOffset = this.getVerticalOriginOffset_(corner);
            var _b = this.measurements_, anchorSize = _b.anchorSize, surfaceSize = _b.surfaceSize;
            var position = (_a = {},
                _a[horizontalAlignment] = horizontalOffset,
                _a[verticalAlignment] = verticalOffset,
                _a);
            // Center align when anchor width is comparable or greater than menu surface, otherwise keep corner.
            if (anchorSize.width / surfaceSize.width > numbers.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
                horizontalAlignment = 'center';
            }
            // If the menu-surface has been hoisted to the body, it's no longer relative to the anchor element
            if (this.isHoistedElement_ || this.isFixedPosition_) {
                this.adjustPositionForHoistedElement_(position);
            }
            this.adapter_.setTransformOrigin(horizontalAlignment + " " + verticalAlignment);
            this.adapter_.setPosition(position);
            this.adapter_.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : '');
        };
        /**
         * @return Measurements used to position menu surface popup.
         */
        MDCMenuSurfaceFoundation.prototype.getAutoLayoutMeasurements_ = function () {
            var anchorRect = this.adapter_.getAnchorDimensions();
            var bodySize = this.adapter_.getBodyDimensions();
            var viewportSize = this.adapter_.getWindowDimensions();
            var windowScroll = this.adapter_.getWindowScroll();
            if (!anchorRect) {
                // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together
                anchorRect = {
                    top: this.position_.y,
                    right: this.position_.x,
                    bottom: this.position_.y,
                    left: this.position_.x,
                    width: 0,
                    height: 0,
                };
                // tslint:enable:object-literal-sort-keys
            }
            return {
                anchorSize: anchorRect,
                bodySize: bodySize,
                surfaceSize: this.dimensions_,
                viewportDistance: {
                    // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together
                    top: anchorRect.top,
                    right: viewportSize.width - anchorRect.right,
                    bottom: viewportSize.height - anchorRect.bottom,
                    left: anchorRect.left,
                },
                viewportSize: viewportSize,
                windowScroll: windowScroll,
            };
        };
        /**
         * Computes the corner of the anchor from which to animate and position the menu surface.
         */
        MDCMenuSurfaceFoundation.prototype.getOriginCorner_ = function () {
            // Defaults: open from the top left.
            var corner = Corner.TOP_LEFT;
            var _a = this.measurements_, viewportDistance = _a.viewportDistance, anchorSize = _a.anchorSize, surfaceSize = _a.surfaceSize;
            var isBottomAligned = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);
            var availableTop = isBottomAligned ? viewportDistance.top + anchorSize.height + this.anchorMargin_.bottom
                : viewportDistance.top + this.anchorMargin_.top;
            var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom
                : viewportDistance.bottom + anchorSize.height - this.anchorMargin_.top;
            var topOverflow = surfaceSize.height - availableTop;
            var bottomOverflow = surfaceSize.height - availableBottom;
            if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
                corner = this.setBit_(corner, CornerBit.BOTTOM);
            }
            var isRtl = this.adapter_.isRtl();
            var isFlipRtl = this.hasBit_(this.anchorCorner_, CornerBit.FLIP_RTL);
            var avoidHorizontalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.RIGHT);
            var isAlignedRight = (avoidHorizontalOverlap && !isRtl) ||
                (!avoidHorizontalOverlap && isFlipRtl && isRtl);
            var availableLeft = isAlignedRight ? viewportDistance.left + anchorSize.width + this.anchorMargin_.right :
                viewportDistance.left + this.anchorMargin_.left;
            var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right :
                viewportDistance.right + anchorSize.width - this.anchorMargin_.left;
            var leftOverflow = surfaceSize.width - availableLeft;
            var rightOverflow = surfaceSize.width - availableRight;
            if ((leftOverflow < 0 && isAlignedRight && isRtl) ||
                (avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0) ||
                (rightOverflow > 0 && leftOverflow < rightOverflow)) {
                corner = this.setBit_(corner, CornerBit.RIGHT);
            }
            return corner;
        };
        /**
         * @param corner Origin corner of the menu surface.
         * @return Maximum height of the menu surface, based on available space. 0 indicates should not be set.
         */
        MDCMenuSurfaceFoundation.prototype.getMenuSurfaceMaxHeight_ = function (corner) {
            var viewportDistance = this.measurements_.viewportDistance;
            var maxHeight = 0;
            var isBottomAligned = this.hasBit_(corner, CornerBit.BOTTOM);
            var isBottomAnchored = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);
            var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;
            // When maximum height is not specified, it is handled from CSS.
            if (isBottomAligned) {
                maxHeight = viewportDistance.top + this.anchorMargin_.top - MARGIN_TO_EDGE;
                if (!isBottomAnchored) {
                    maxHeight += this.measurements_.anchorSize.height;
                }
            }
            else {
                maxHeight =
                    viewportDistance.bottom - this.anchorMargin_.bottom + this.measurements_.anchorSize.height - MARGIN_TO_EDGE;
                if (isBottomAnchored) {
                    maxHeight -= this.measurements_.anchorSize.height;
                }
            }
            return maxHeight;
        };
        /**
         * @param corner Origin corner of the menu surface.
         * @return Horizontal offset of menu surface origin corner from corresponding anchor corner.
         */
        MDCMenuSurfaceFoundation.prototype.getHorizontalOriginOffset_ = function (corner) {
            var anchorSize = this.measurements_.anchorSize;
            // isRightAligned corresponds to using the 'right' property on the surface.
            var isRightAligned = this.hasBit_(corner, CornerBit.RIGHT);
            var avoidHorizontalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.RIGHT);
            if (isRightAligned) {
                var rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin_.left : this.anchorMargin_.right;
                // For hoisted or fixed elements, adjust the offset by the difference between viewport width and body width so
                // when we calculate the right value (`adjustPositionForHoistedElement_`) based on the element position,
                // the right property is correct.
                if (this.isHoistedElement_ || this.isFixedPosition_) {
                    return rightOffset - (this.measurements_.viewportSize.width - this.measurements_.bodySize.width);
                }
                return rightOffset;
            }
            return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin_.right : this.anchorMargin_.left;
        };
        /**
         * @param corner Origin corner of the menu surface.
         * @return Vertical offset of menu surface origin corner from corresponding anchor corner.
         */
        MDCMenuSurfaceFoundation.prototype.getVerticalOriginOffset_ = function (corner) {
            var anchorSize = this.measurements_.anchorSize;
            var isBottomAligned = this.hasBit_(corner, CornerBit.BOTTOM);
            var avoidVerticalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);
            var y = 0;
            if (isBottomAligned) {
                y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin_.top : -this.anchorMargin_.bottom;
            }
            else {
                y = avoidVerticalOverlap ? (anchorSize.height + this.anchorMargin_.bottom) : this.anchorMargin_.top;
            }
            return y;
        };
        /** Calculates the offsets for positioning the menu-surface when the menu-surface has been hoisted to the body. */
        MDCMenuSurfaceFoundation.prototype.adjustPositionForHoistedElement_ = function (position) {
            var e_1, _a;
            var _b = this.measurements_, windowScroll = _b.windowScroll, viewportDistance = _b.viewportDistance;
            var props = Object.keys(position);
            try {
                for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
                    var prop = props_1_1.value;
                    var value = position[prop] || 0;
                    // Hoisted surfaces need to have the anchor elements location on the page added to the
                    // position properties for proper alignment on the body.
                    value += viewportDistance[prop];
                    // Surfaces that are absolutely positioned need to have additional calculations for scroll
                    // and bottom positioning.
                    if (!this.isFixedPosition_) {
                        if (prop === 'top') {
                            value += windowScroll.y;
                        }
                        else if (prop === 'bottom') {
                            value -= windowScroll.y;
                        }
                        else if (prop === 'left') {
                            value += windowScroll.x;
                        }
                        else { // prop === 'right'
                            value -= windowScroll.x;
                        }
                    }
                    position[prop] = value;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        /**
         * The last focused element when the menu surface was opened should regain focus, if the user is
         * focused on or within the menu surface when it is closed.
         */
        MDCMenuSurfaceFoundation.prototype.maybeRestoreFocus_ = function () {
            var isRootFocused = this.adapter_.isFocused();
            var childHasFocus = document.activeElement && this.adapter_.isElementInContainer(document.activeElement);
            if (isRootFocused || childHasFocus) {
                this.adapter_.restoreFocus();
            }
        };
        MDCMenuSurfaceFoundation.prototype.hasBit_ = function (corner, bit) {
            return Boolean(corner & bit); // tslint:disable-line:no-bitwise
        };
        MDCMenuSurfaceFoundation.prototype.setBit_ = function (corner, bit) {
            return corner | bit; // tslint:disable-line:no-bitwise
        };
        /**
         * isFinite that doesn't force conversion to number type.
         * Equivalent to Number.isFinite in ES2015, which is not supported in IE.
         */
        MDCMenuSurfaceFoundation.prototype.isFinite_ = function (num) {
            return typeof num === 'number' && isFinite(num);
        };
        return MDCMenuSurfaceFoundation;
    }(MDCFoundation));
    //# sourceMappingURL=foundation.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCMenuSurface = /** @class */ (function (_super) {
        __extends(MDCMenuSurface, _super);
        function MDCMenuSurface() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCMenuSurface.attachTo = function (root) {
            return new MDCMenuSurface(root);
        };
        MDCMenuSurface.prototype.initialSyncWithDOM = function () {
            var _this = this;
            var parentEl = this.root_.parentElement;
            this.anchorElement = parentEl && parentEl.classList.contains(cssClasses.ANCHOR) ? parentEl : null;
            if (this.root_.classList.contains(cssClasses.FIXED)) {
                this.setFixedPosition(true);
            }
            this.handleKeydown_ = function (evt) { return _this.foundation_.handleKeydown(evt); };
            this.handleBodyClick_ = function (evt) { return _this.foundation_.handleBodyClick(evt); };
            this.registerBodyClickListener_ = function () { return document.body.addEventListener('click', _this.handleBodyClick_); };
            this.deregisterBodyClickListener_ = function () { return document.body.removeEventListener('click', _this.handleBodyClick_); };
            this.listen('keydown', this.handleKeydown_);
            this.listen(strings.OPENED_EVENT, this.registerBodyClickListener_);
            this.listen(strings.CLOSED_EVENT, this.deregisterBodyClickListener_);
        };
        MDCMenuSurface.prototype.destroy = function () {
            this.unlisten('keydown', this.handleKeydown_);
            this.unlisten(strings.OPENED_EVENT, this.registerBodyClickListener_);
            this.unlisten(strings.CLOSED_EVENT, this.deregisterBodyClickListener_);
            _super.prototype.destroy.call(this);
        };
        MDCMenuSurface.prototype.isOpen = function () {
            return this.foundation_.isOpen();
        };
        MDCMenuSurface.prototype.open = function () {
            this.foundation_.open();
        };
        MDCMenuSurface.prototype.close = function (skipRestoreFocus) {
            if (skipRestoreFocus === void 0) { skipRestoreFocus = false; }
            this.foundation_.close(skipRestoreFocus);
        };
        Object.defineProperty(MDCMenuSurface.prototype, "quickOpen", {
            set: function (quickOpen) {
                this.foundation_.setQuickOpen(quickOpen);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Removes the menu-surface from it's current location and appends it to the
         * body to overcome any overflow:hidden issues.
         */
        MDCMenuSurface.prototype.hoistMenuToBody = function () {
            document.body.appendChild(this.root_);
            this.setIsHoisted(true);
        };
        /** Sets the foundation to use page offsets for an positioning when the menu is hoisted to the body. */
        MDCMenuSurface.prototype.setIsHoisted = function (isHoisted) {
            this.foundation_.setIsHoisted(isHoisted);
        };
        /** Sets the element that the menu-surface is anchored to. */
        MDCMenuSurface.prototype.setMenuSurfaceAnchorElement = function (element) {
            this.anchorElement = element;
        };
        /** Sets the menu-surface to position: fixed. */
        MDCMenuSurface.prototype.setFixedPosition = function (isFixed) {
            if (isFixed) {
                this.root_.classList.add(cssClasses.FIXED);
            }
            else {
                this.root_.classList.remove(cssClasses.FIXED);
            }
            this.foundation_.setFixedPosition(isFixed);
        };
        /** Sets the absolute x/y position to position based on. Requires the menu to be hoisted. */
        MDCMenuSurface.prototype.setAbsolutePosition = function (x, y) {
            this.foundation_.setAbsolutePosition(x, y);
            this.setIsHoisted(true);
        };
        /**
         * @param corner Default anchor corner alignment of top-left surface corner.
         */
        MDCMenuSurface.prototype.setAnchorCorner = function (corner) {
            this.foundation_.setAnchorCorner(corner);
        };
        MDCMenuSurface.prototype.setAnchorMargin = function (margin) {
            this.foundation_.setAnchorMargin(margin);
        };
        MDCMenuSurface.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                hasClass: function (className) { return _this.root_.classList.contains(className); },
                hasAnchor: function () { return !!_this.anchorElement; },
                notifyClose: function () { return _this.emit(MDCMenuSurfaceFoundation.strings.CLOSED_EVENT, {}); },
                notifyOpen: function () { return _this.emit(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, {}); },
                isElementInContainer: function (el) { return _this.root_.contains(el); },
                isRtl: function () { return getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl'; },
                setTransformOrigin: function (origin) {
                    var propertyName = getTransformPropertyName(window) + "-origin";
                    _this.root_.style.setProperty(propertyName, origin);
                },
                isFocused: function () { return document.activeElement === _this.root_; },
                saveFocus: function () {
                    _this.previousFocus_ = document.activeElement;
                },
                restoreFocus: function () {
                    if (_this.root_.contains(document.activeElement)) {
                        if (_this.previousFocus_ && _this.previousFocus_.focus) {
                            _this.previousFocus_.focus();
                        }
                    }
                },
                getInnerDimensions: function () {
                    return { width: _this.root_.offsetWidth, height: _this.root_.offsetHeight };
                },
                getAnchorDimensions: function () { return _this.anchorElement ? _this.anchorElement.getBoundingClientRect() : null; },
                getWindowDimensions: function () {
                    return { width: window.innerWidth, height: window.innerHeight };
                },
                getBodyDimensions: function () {
                    return { width: document.body.clientWidth, height: document.body.clientHeight };
                },
                getWindowScroll: function () {
                    return { x: window.pageXOffset, y: window.pageYOffset };
                },
                setPosition: function (position) {
                    _this.root_.style.left = 'left' in position ? position.left + "px" : '';
                    _this.root_.style.right = 'right' in position ? position.right + "px" : '';
                    _this.root_.style.top = 'top' in position ? position.top + "px" : '';
                    _this.root_.style.bottom = 'bottom' in position ? position.bottom + "px" : '';
                },
                setMaxHeight: function (height) {
                    _this.root_.style.maxHeight = height;
                },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCMenuSurfaceFoundation(adapter);
        };
        return MDCMenuSurface;
    }(MDCComponent));
    //# sourceMappingURL=component.js.map

    function forwardEventsBuilder(component, additionalEvents = []) {
      const events = [
        'focus', 'blur',
        'fullscreenchange', 'fullscreenerror', 'scroll',
        'cut', 'copy', 'paste',
        'keydown', 'keypress', 'keyup',
        'auxclick', 'click', 'contextmenu', 'dblclick', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseover', 'mouseout', 'mouseup', 'pointerlockchange', 'pointerlockerror', 'select', 'wheel',
        'drag', 'dragend', 'dragenter', 'dragstart', 'dragleave', 'dragover', 'drop',
        'touchcancel', 'touchend', 'touchmove', 'touchstart',
        'pointerover', 'pointerenter', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerout', 'pointerleave', 'gotpointercapture', 'lostpointercapture',
        ...additionalEvents
      ];

      function forward(e) {
        bubble(component, e);
      }

      return node => {
        const destructors = [];

        for (let i = 0; i < events.length; i++) {
          destructors.push(listen(node, events[i], forward));
        }

        return {
          destroy: () => {
            for (let i = 0; i < destructors.length; i++) {
              destructors[i]();
            }
          }
        }
      };
    }

    function exclude(obj, keys) {
      let names = Object.getOwnPropertyNames(obj);
      const newObj = {};

      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        const cashIndex = name.indexOf('$');
        if (cashIndex !== -1 && keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
          continue;
        }
        if (keys.indexOf(name) !== -1) {
          continue;
        }
        newObj[name] = obj[name];
      }

      return newObj;
    }

    function useActions(node, actions) {
      let objects = [];

      if (actions) {
        for (let i = 0; i < actions.length; i++) {
          const isArray = Array.isArray(actions[i]);
          const action = isArray ? actions[i][0] : actions[i];
          if (isArray && actions[i].length > 1) {
            objects.push(action(node, actions[i][1]));
          } else {
            objects.push(action(node));
          }
        }
      }

      return {
        update(actions) {
          if ((actions && actions.length || 0) != objects.length) {
            throw new Error('You must not change the length of an actions array.');
          }

          if (actions) {
            for (let i = 0; i < actions.length; i++) {
              if (objects[i] && 'update' in objects[i]) {
                const isArray = Array.isArray(actions[i]);
                if (isArray && actions[i].length > 1) {
                  objects[i].update(actions[i][1]);
                } else {
                  objects[i].update();
                }
              }
            }
          }
        },

        destroy() {
          for (let i = 0; i < objects.length; i++) {
            if (objects[i] && 'destroy' in objects[i]) {
              objects[i].destroy();
            }
          }
        }
      }
    }

    /* node_modules\@smui\menu-surface\MenuSurface.svelte generated by Svelte v3.18.1 */
    const file = "node_modules\\@smui\\menu-surface\\MenuSurface.svelte";

    function create_fragment(ctx) {
    	let div;
    	let useActions_action;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[27].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[26], null);

    	let div_levels = [
    		{
    			class: "\n    mdc-menu-surface\n    " + /*className*/ ctx[3] + "\n    " + (/*fixed*/ ctx[0] ? "mdc-menu-surface--fixed" : "") + "\n    " + (/*isStatic*/ ctx[4] ? "mdc-menu-surface--open" : "") + "\n    " + (/*isStatic*/ ctx[4] ? "smui-menu-surface--static" : "") + "\n  "
    		},
    		exclude(/*$$props*/ ctx[7], [
    			"use",
    			"class",
    			"static",
    			"anchor",
    			"fixed",
    			"open",
    			"quickOpen",
    			"anchorElement",
    			"anchorCorner",
    			"element"
    		])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[28](div);
    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[2])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[5].call(null, div)),
    				listen_dev(div, "MDCMenuSurface:closed", /*updateOpen*/ ctx[6], false, false, false),
    				listen_dev(div, "MDCMenuSurface:opened", /*updateOpen*/ ctx[6], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 67108864) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[26], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[26], dirty, null));
    			}

    			set_attributes(div, get_spread_update(div_levels, [
    				dirty & /*className, fixed, isStatic*/ 25 && {
    					class: "\n    mdc-menu-surface\n    " + /*className*/ ctx[3] + "\n    " + (/*fixed*/ ctx[0] ? "mdc-menu-surface--fixed" : "") + "\n    " + (/*isStatic*/ ctx[4] ? "mdc-menu-surface--open" : "") + "\n    " + (/*isStatic*/ ctx[4] ? "smui-menu-surface--static" : "") + "\n  "
    				},
    				dirty & /*exclude, $$props*/ 128 && exclude(/*$$props*/ ctx[7], [
    					"use",
    					"class",
    					"static",
    					"anchor",
    					"fixed",
    					"open",
    					"quickOpen",
    					"anchorElement",
    					"anchorCorner",
    					"element"
    				])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 4) useActions_action.update.call(null, /*use*/ ctx[2]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[28](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component, ["MDCMenuSurface:closed", "MDCMenuSurface:opened"]);
    	let { use = [] } = $$props;
    	let { class: className = "" } = $$props;
    	let { static: isStatic = false } = $$props;
    	let { anchor = true } = $$props;
    	let { fixed = false } = $$props;
    	let { open = isStatic } = $$props;
    	let { quickOpen = false } = $$props;
    	let { anchorElement = null } = $$props;
    	let { anchorCorner = null } = $$props;
    	let { element = undefined } = $$props; // This is exported because Menu needs it.
    	let menuSurface;
    	let instantiate = getContext("SMUI:menu-surface:instantiate");
    	let getInstance = getContext("SMUI:menu-surface:getInstance");
    	setContext("SMUI:list:role", "menu");
    	setContext("SMUI:list:item:role", "menuitem");
    	let oldFixed = null;

    	onMount(async () => {
    		if (instantiate !== false) {
    			$$invalidate(22, menuSurface = new MDCMenuSurface(element));
    		} else {
    			$$invalidate(22, menuSurface = await getInstance());
    		}
    	});

    	onDestroy(() => {
    		if (anchor) {
    			element && element.parentNode.classList.remove("mdc-menu-surface--anchor");
    		}

    		let isHoisted = false;

    		if (menuSurface) {
    			isHoisted = menuSurface.foundation_.isHoistedElement_;

    			if (instantiate !== false) {
    				menuSurface.destroy();
    			}
    		}

    		if (isHoisted) {
    			element.parentNode.removeChild(element);
    		}
    	});

    	function updateOpen() {
    		if (menuSurface) {
    			if (isStatic) {
    				$$invalidate(8, open = true);
    			} else {
    				$$invalidate(8, open = menuSurface.isOpen());
    			}
    		}
    	}

    	function setOpen(value) {
    		$$invalidate(8, open = value);
    	}

    	function setAnchorCorner(...args) {
    		return menuSurface.setAnchorCorner(...args);
    	}

    	function setAnchorMargin(...args) {
    		return menuSurface.setAnchorMargin(...args);
    	}

    	function setFixedPosition(isFixed, ...args) {
    		$$invalidate(0, fixed = isFixed);
    		return menuSurface.setFixedPosition(isFixed, ...args);
    	}

    	function setAbsolutePosition(...args) {
    		return menuSurface.setAbsolutePosition(...args);
    	}

    	function setMenuSurfaceAnchorElement(...args) {
    		return menuSurface.setMenuSurfaceAnchorElement(...args);
    	}

    	function hoistMenuToBody(...args) {
    		return menuSurface.hoistMenuToBody(...args);
    	}

    	function setIsHoisted(...args) {
    		return menuSurface.setIsHoisted(...args);
    	}

    	function getDefaultFoundation(...args) {
    		return menuSurface.getDefaultFoundation(...args);
    	}

    	let { $$slots = {}, $$scope } = $$props;

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(1, element = $$value);
    		});
    	}

    	$$self.$set = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(2, use = $$new_props.use);
    		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ("static" in $$new_props) $$invalidate(4, isStatic = $$new_props.static);
    		if ("anchor" in $$new_props) $$invalidate(10, anchor = $$new_props.anchor);
    		if ("fixed" in $$new_props) $$invalidate(0, fixed = $$new_props.fixed);
    		if ("open" in $$new_props) $$invalidate(8, open = $$new_props.open);
    		if ("quickOpen" in $$new_props) $$invalidate(11, quickOpen = $$new_props.quickOpen);
    		if ("anchorElement" in $$new_props) $$invalidate(9, anchorElement = $$new_props.anchorElement);
    		if ("anchorCorner" in $$new_props) $$invalidate(12, anchorCorner = $$new_props.anchorCorner);
    		if ("element" in $$new_props) $$invalidate(1, element = $$new_props.element);
    		if ("$$scope" in $$new_props) $$invalidate(26, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			use,
    			className,
    			isStatic,
    			anchor,
    			fixed,
    			open,
    			quickOpen,
    			anchorElement,
    			anchorCorner,
    			element,
    			menuSurface,
    			instantiate,
    			getInstance,
    			oldFixed
    		};
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(2, use = $$new_props.use);
    		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
    		if ("isStatic" in $$props) $$invalidate(4, isStatic = $$new_props.isStatic);
    		if ("anchor" in $$props) $$invalidate(10, anchor = $$new_props.anchor);
    		if ("fixed" in $$props) $$invalidate(0, fixed = $$new_props.fixed);
    		if ("open" in $$props) $$invalidate(8, open = $$new_props.open);
    		if ("quickOpen" in $$props) $$invalidate(11, quickOpen = $$new_props.quickOpen);
    		if ("anchorElement" in $$props) $$invalidate(9, anchorElement = $$new_props.anchorElement);
    		if ("anchorCorner" in $$props) $$invalidate(12, anchorCorner = $$new_props.anchorCorner);
    		if ("element" in $$props) $$invalidate(1, element = $$new_props.element);
    		if ("menuSurface" in $$props) $$invalidate(22, menuSurface = $$new_props.menuSurface);
    		if ("instantiate" in $$props) instantiate = $$new_props.instantiate;
    		if ("getInstance" in $$props) getInstance = $$new_props.getInstance;
    		if ("oldFixed" in $$props) $$invalidate(23, oldFixed = $$new_props.oldFixed);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*element, anchor*/ 1026) {
    			 if (element && anchor && !element.parentNode.classList.contains("mdc-menu-surface--anchor")) {
    				element.parentNode.classList.add("mdc-menu-surface--anchor");
    				$$invalidate(9, anchorElement = element.parentNode);
    			}
    		}

    		if ($$self.$$.dirty & /*menuSurface, quickOpen*/ 4196352) {
    			 if (menuSurface && menuSurface.quickOpen !== quickOpen) {
    				$$invalidate(22, menuSurface.quickOpen = quickOpen, menuSurface);
    			}
    		}

    		if ($$self.$$.dirty & /*menuSurface, anchorElement*/ 4194816) {
    			 if (menuSurface && menuSurface.anchorElement !== anchorElement) {
    				$$invalidate(22, menuSurface.anchorElement = anchorElement, menuSurface);
    			}
    		}

    		if ($$self.$$.dirty & /*menuSurface, open*/ 4194560) {
    			 if (menuSurface && menuSurface.isOpen() !== open) {
    				if (open) {
    					menuSurface.open();
    				} else {
    					menuSurface.close();
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*menuSurface, oldFixed, fixed*/ 12582913) {
    			 if (menuSurface && oldFixed !== fixed) {
    				menuSurface.setFixedPosition(fixed);
    				$$invalidate(23, oldFixed = fixed);
    			}
    		}

    		if ($$self.$$.dirty & /*menuSurface, anchorCorner*/ 4198400) {
    			 if (menuSurface && anchorCorner != null) {
    				if (Corner.hasOwnProperty(anchorCorner)) {
    					menuSurface.setAnchorCorner(Corner[anchorCorner]);
    				} else if (CornerBit.hasOwnProperty(anchorCorner)) {
    					menuSurface.setAnchorCorner(Corner[anchorCorner]);
    				} else {
    					menuSurface.setAnchorCorner(anchorCorner);
    				}
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		fixed,
    		element,
    		use,
    		className,
    		isStatic,
    		forwardEvents,
    		updateOpen,
    		$$props,
    		open,
    		anchorElement,
    		anchor,
    		quickOpen,
    		anchorCorner,
    		setOpen,
    		setAnchorCorner,
    		setAnchorMargin,
    		setFixedPosition,
    		setAbsolutePosition,
    		setMenuSurfaceAnchorElement,
    		hoistMenuToBody,
    		setIsHoisted,
    		getDefaultFoundation,
    		menuSurface,
    		oldFixed,
    		instantiate,
    		getInstance,
    		$$scope,
    		$$slots,
    		div_binding
    	];
    }

    class MenuSurface extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance, create_fragment, safe_not_equal, {
    			use: 2,
    			class: 3,
    			static: 4,
    			anchor: 10,
    			fixed: 0,
    			open: 8,
    			quickOpen: 11,
    			anchorElement: 9,
    			anchorCorner: 12,
    			element: 1,
    			setOpen: 13,
    			setAnchorCorner: 14,
    			setAnchorMargin: 15,
    			setFixedPosition: 16,
    			setAbsolutePosition: 17,
    			setMenuSurfaceAnchorElement: 18,
    			hoistMenuToBody: 19,
    			setIsHoisted: 20,
    			getDefaultFoundation: 21
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MenuSurface",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get use() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get static() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set static(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchor() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchor(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fixed() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fixed(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get open() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get quickOpen() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set quickOpen(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchorElement() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchorElement(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchorCorner() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchorCorner(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setOpen() {
    		return this.$$.ctx[13];
    	}

    	set setOpen(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setAnchorCorner() {
    		return this.$$.ctx[14];
    	}

    	set setAnchorCorner(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setAnchorMargin() {
    		return this.$$.ctx[15];
    	}

    	set setAnchorMargin(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setFixedPosition() {
    		return this.$$.ctx[16];
    	}

    	set setFixedPosition(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setAbsolutePosition() {
    		return this.$$.ctx[17];
    	}

    	set setAbsolutePosition(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setMenuSurfaceAnchorElement() {
    		return this.$$.ctx[18];
    	}

    	set setMenuSurfaceAnchorElement(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hoistMenuToBody() {
    		return this.$$.ctx[19];
    	}

    	set hoistMenuToBody(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setIsHoisted() {
    		return this.$$.ctx[20];
    	}

    	set setIsHoisted(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getDefaultFoundation() {
    		return this.$$.ctx[21];
    	}

    	set getDefaultFoundation(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function Anchor(node) {
      node.classList.add('mdc-menu-surface--anchor');

      return {
        destroy() {
          node.classList.remove('mdc-menu-surface--anchor');
        }
      }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    function getCjsExportFromNamespace (n) {
    	return n && n['default'] || n;
    }

    var lazysizes = createCommonjsModule(function (module) {
    (function(window, factory) {
    	var lazySizes = factory(window, window.document, Date);
    	window.lazySizes = lazySizes;
    	if( module.exports){
    		module.exports = lazySizes;
    	}
    }(typeof window != 'undefined' ?
          window : {}, function l(window, document, Date) { // Pass in the windoe Date function also for SSR because the Date class can be lost
    	/*jshint eqnull:true */

    	var lazysizes, lazySizesCfg;

    	(function(){
    		var prop;

    		var lazySizesDefaults = {
    			lazyClass: 'lazyload',
    			loadedClass: 'lazyloaded',
    			loadingClass: 'lazyloading',
    			preloadClass: 'lazypreload',
    			errorClass: 'lazyerror',
    			//strictClass: 'lazystrict',
    			autosizesClass: 'lazyautosizes',
    			srcAttr: 'data-src',
    			srcsetAttr: 'data-srcset',
    			sizesAttr: 'data-sizes',
    			//preloadAfterLoad: false,
    			minSize: 40,
    			customMedia: {},
    			init: true,
    			expFactor: 1.5,
    			hFac: 0.8,
    			loadMode: 2,
    			loadHidden: true,
    			ricTimeout: 0,
    			throttleDelay: 125,
    		};

    		lazySizesCfg = window.lazySizesConfig || window.lazysizesConfig || {};

    		for(prop in lazySizesDefaults){
    			if(!(prop in lazySizesCfg)){
    				lazySizesCfg[prop] = lazySizesDefaults[prop];
    			}
    		}
    	})();

    	if (!document || !document.getElementsByClassName) {
    		return {
    			init: function () {},
    			cfg: lazySizesCfg,
    			noSupport: true,
    		};
    	}

    	var docElem = document.documentElement;

    	var supportPicture = window.HTMLPictureElement;

    	var _addEventListener = 'addEventListener';

    	var _getAttribute = 'getAttribute';

    	/**
    	 * Update to bind to window because 'this' becomes null during SSR
    	 * builds.
    	 */
    	var addEventListener = window[_addEventListener].bind(window);

    	var setTimeout = window.setTimeout;

    	var requestAnimationFrame = window.requestAnimationFrame || setTimeout;

    	var requestIdleCallback = window.requestIdleCallback;

    	var regPicture = /^picture$/i;

    	var loadEvents = ['load', 'error', 'lazyincluded', '_lazyloaded'];

    	var regClassCache = {};

    	var forEach = Array.prototype.forEach;

    	var hasClass = function(ele, cls) {
    		if(!regClassCache[cls]){
    			regClassCache[cls] = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    		}
    		return regClassCache[cls].test(ele[_getAttribute]('class') || '') && regClassCache[cls];
    	};

    	var addClass = function(ele, cls) {
    		if (!hasClass(ele, cls)){
    			ele.setAttribute('class', (ele[_getAttribute]('class') || '').trim() + ' ' + cls);
    		}
    	};

    	var removeClass = function(ele, cls) {
    		var reg;
    		if ((reg = hasClass(ele,cls))) {
    			ele.setAttribute('class', (ele[_getAttribute]('class') || '').replace(reg, ' '));
    		}
    	};

    	var addRemoveLoadEvents = function(dom, fn, add){
    		var action = add ? _addEventListener : 'removeEventListener';
    		if(add){
    			addRemoveLoadEvents(dom, fn);
    		}
    		loadEvents.forEach(function(evt){
    			dom[action](evt, fn);
    		});
    	};

    	var triggerEvent = function(elem, name, detail, noBubbles, noCancelable){
    		var event = document.createEvent('Event');

    		if(!detail){
    			detail = {};
    		}

    		detail.instance = lazysizes;

    		event.initEvent(name, !noBubbles, !noCancelable);

    		event.detail = detail;

    		elem.dispatchEvent(event);
    		return event;
    	};

    	var updatePolyfill = function (el, full){
    		var polyfill;
    		if( !supportPicture && ( polyfill = (window.picturefill || lazySizesCfg.pf) ) ){
    			if(full && full.src && !el[_getAttribute]('srcset')){
    				el.setAttribute('srcset', full.src);
    			}
    			polyfill({reevaluate: true, elements: [el]});
    		} else if(full && full.src){
    			el.src = full.src;
    		}
    	};

    	var getCSS = function (elem, style){
    		return (getComputedStyle(elem, null) || {})[style];
    	};

    	var getWidth = function(elem, parent, width){
    		width = width || elem.offsetWidth;

    		while(width < lazySizesCfg.minSize && parent && !elem._lazysizesWidth){
    			width =  parent.offsetWidth;
    			parent = parent.parentNode;
    		}

    		return width;
    	};

    	var rAF = (function(){
    		var running, waiting;
    		var firstFns = [];
    		var secondFns = [];
    		var fns = firstFns;

    		var run = function(){
    			var runFns = fns;

    			fns = firstFns.length ? secondFns : firstFns;

    			running = true;
    			waiting = false;

    			while(runFns.length){
    				runFns.shift()();
    			}

    			running = false;
    		};

    		var rafBatch = function(fn, queue){
    			if(running && !queue){
    				fn.apply(this, arguments);
    			} else {
    				fns.push(fn);

    				if(!waiting){
    					waiting = true;
    					(document.hidden ? setTimeout : requestAnimationFrame)(run);
    				}
    			}
    		};

    		rafBatch._lsFlush = run;

    		return rafBatch;
    	})();

    	var rAFIt = function(fn, simple){
    		return simple ?
    			function() {
    				rAF(fn);
    			} :
    			function(){
    				var that = this;
    				var args = arguments;
    				rAF(function(){
    					fn.apply(that, args);
    				});
    			}
    		;
    	};

    	var throttle = function(fn){
    		var running;
    		var lastTime = 0;
    		var gDelay = lazySizesCfg.throttleDelay;
    		var rICTimeout = lazySizesCfg.ricTimeout;
    		var run = function(){
    			running = false;
    			lastTime = Date.now();
    			fn();
    		};
    		var idleCallback = requestIdleCallback && rICTimeout > 49 ?
    			function(){
    				requestIdleCallback(run, {timeout: rICTimeout});

    				if(rICTimeout !== lazySizesCfg.ricTimeout){
    					rICTimeout = lazySizesCfg.ricTimeout;
    				}
    			} :
    			rAFIt(function(){
    				setTimeout(run);
    			}, true)
    		;

    		return function(isPriority){
    			var delay;

    			if((isPriority = isPriority === true)){
    				rICTimeout = 33;
    			}

    			if(running){
    				return;
    			}

    			running =  true;

    			delay = gDelay - (Date.now() - lastTime);

    			if(delay < 0){
    				delay = 0;
    			}

    			if(isPriority || delay < 9){
    				idleCallback();
    			} else {
    				setTimeout(idleCallback, delay);
    			}
    		};
    	};

    	//based on http://modernjavascript.blogspot.de/2013/08/building-better-debounce.html
    	var debounce = function(func) {
    		var timeout, timestamp;
    		var wait = 99;
    		var run = function(){
    			timeout = null;
    			func();
    		};
    		var later = function() {
    			var last = Date.now() - timestamp;

    			if (last < wait) {
    				setTimeout(later, wait - last);
    			} else {
    				(requestIdleCallback || run)(run);
    			}
    		};

    		return function() {
    			timestamp = Date.now();

    			if (!timeout) {
    				timeout = setTimeout(later, wait);
    			}
    		};
    	};

    	var loader = (function(){
    		var preloadElems, isCompleted, resetPreloadingTimer, loadMode, started;

    		var eLvW, elvH, eLtop, eLleft, eLright, eLbottom, isBodyHidden;

    		var regImg = /^img$/i;
    		var regIframe = /^iframe$/i;

    		var supportScroll = ('onscroll' in window) && !(/(gle|ing)bot/.test(navigator.userAgent));

    		var shrinkExpand = 0;
    		var currentExpand = 0;

    		var isLoading = 0;
    		var lowRuns = -1;

    		var resetPreloading = function(e){
    			isLoading--;
    			if(!e || isLoading < 0 || !e.target){
    				isLoading = 0;
    			}
    		};

    		var isVisible = function (elem) {
    			if (isBodyHidden == null) {
    				isBodyHidden = getCSS(document.body, 'visibility') == 'hidden';
    			}

    			return isBodyHidden || !(getCSS(elem.parentNode, 'visibility') == 'hidden' && getCSS(elem, 'visibility') == 'hidden');
    		};

    		var isNestedVisible = function(elem, elemExpand){
    			var outerRect;
    			var parent = elem;
    			var visible = isVisible(elem);

    			eLtop -= elemExpand;
    			eLbottom += elemExpand;
    			eLleft -= elemExpand;
    			eLright += elemExpand;

    			while(visible && (parent = parent.offsetParent) && parent != document.body && parent != docElem){
    				visible = ((getCSS(parent, 'opacity') || 1) > 0);

    				if(visible && getCSS(parent, 'overflow') != 'visible'){
    					outerRect = parent.getBoundingClientRect();
    					visible = eLright > outerRect.left &&
    						eLleft < outerRect.right &&
    						eLbottom > outerRect.top - 1 &&
    						eLtop < outerRect.bottom + 1
    					;
    				}
    			}

    			return visible;
    		};

    		var checkElements = function() {
    			var eLlen, i, rect, autoLoadElem, loadedSomething, elemExpand, elemNegativeExpand, elemExpandVal,
    				beforeExpandVal, defaultExpand, preloadExpand, hFac;
    			var lazyloadElems = lazysizes.elements;

    			if((loadMode = lazySizesCfg.loadMode) && isLoading < 8 && (eLlen = lazyloadElems.length)){

    				i = 0;

    				lowRuns++;

    				for(; i < eLlen; i++){

    					if(!lazyloadElems[i] || lazyloadElems[i]._lazyRace){continue;}

    					if(!supportScroll || (lazysizes.prematureUnveil && lazysizes.prematureUnveil(lazyloadElems[i]))){unveilElement(lazyloadElems[i]);continue;}

    					if(!(elemExpandVal = lazyloadElems[i][_getAttribute]('data-expand')) || !(elemExpand = elemExpandVal * 1)){
    						elemExpand = currentExpand;
    					}

    					if (!defaultExpand) {
    						defaultExpand = (!lazySizesCfg.expand || lazySizesCfg.expand < 1) ?
    							docElem.clientHeight > 500 && docElem.clientWidth > 500 ? 500 : 370 :
    							lazySizesCfg.expand;

    						lazysizes._defEx = defaultExpand;

    						preloadExpand = defaultExpand * lazySizesCfg.expFactor;
    						hFac = lazySizesCfg.hFac;
    						isBodyHidden = null;

    						if(currentExpand < preloadExpand && isLoading < 1 && lowRuns > 2 && loadMode > 2 && !document.hidden){
    							currentExpand = preloadExpand;
    							lowRuns = 0;
    						} else if(loadMode > 1 && lowRuns > 1 && isLoading < 6){
    							currentExpand = defaultExpand;
    						} else {
    							currentExpand = shrinkExpand;
    						}
    					}

    					if(beforeExpandVal !== elemExpand){
    						eLvW = innerWidth + (elemExpand * hFac);
    						elvH = innerHeight + elemExpand;
    						elemNegativeExpand = elemExpand * -1;
    						beforeExpandVal = elemExpand;
    					}

    					rect = lazyloadElems[i].getBoundingClientRect();

    					if ((eLbottom = rect.bottom) >= elemNegativeExpand &&
    						(eLtop = rect.top) <= elvH &&
    						(eLright = rect.right) >= elemNegativeExpand * hFac &&
    						(eLleft = rect.left) <= eLvW &&
    						(eLbottom || eLright || eLleft || eLtop) &&
    						(lazySizesCfg.loadHidden || isVisible(lazyloadElems[i])) &&
    						((isCompleted && isLoading < 3 && !elemExpandVal && (loadMode < 3 || lowRuns < 4)) || isNestedVisible(lazyloadElems[i], elemExpand))){
    						unveilElement(lazyloadElems[i]);
    						loadedSomething = true;
    						if(isLoading > 9){break;}
    					} else if(!loadedSomething && isCompleted && !autoLoadElem &&
    						isLoading < 4 && lowRuns < 4 && loadMode > 2 &&
    						(preloadElems[0] || lazySizesCfg.preloadAfterLoad) &&
    						(preloadElems[0] || (!elemExpandVal && ((eLbottom || eLright || eLleft || eLtop) || lazyloadElems[i][_getAttribute](lazySizesCfg.sizesAttr) != 'auto')))){
    						autoLoadElem = preloadElems[0] || lazyloadElems[i];
    					}
    				}

    				if(autoLoadElem && !loadedSomething){
    					unveilElement(autoLoadElem);
    				}
    			}
    		};

    		var throttledCheckElements = throttle(checkElements);

    		var switchLoadingClass = function(e){
    			var elem = e.target;

    			if (elem._lazyCache) {
    				delete elem._lazyCache;
    				return;
    			}

    			resetPreloading(e);
    			addClass(elem, lazySizesCfg.loadedClass);
    			removeClass(elem, lazySizesCfg.loadingClass);
    			addRemoveLoadEvents(elem, rafSwitchLoadingClass);
    			triggerEvent(elem, 'lazyloaded');
    		};
    		var rafedSwitchLoadingClass = rAFIt(switchLoadingClass);
    		var rafSwitchLoadingClass = function(e){
    			rafedSwitchLoadingClass({target: e.target});
    		};

    		var changeIframeSrc = function(elem, src){
    			try {
    				elem.contentWindow.location.replace(src);
    			} catch(e){
    				elem.src = src;
    			}
    		};

    		var handleSources = function(source){
    			var customMedia;

    			var sourceSrcset = source[_getAttribute](lazySizesCfg.srcsetAttr);

    			if( (customMedia = lazySizesCfg.customMedia[source[_getAttribute]('data-media') || source[_getAttribute]('media')]) ){
    				source.setAttribute('media', customMedia);
    			}

    			if(sourceSrcset){
    				source.setAttribute('srcset', sourceSrcset);
    			}
    		};

    		var lazyUnveil = rAFIt(function (elem, detail, isAuto, sizes, isImg){
    			var src, srcset, parent, isPicture, event, firesLoad;

    			if(!(event = triggerEvent(elem, 'lazybeforeunveil', detail)).defaultPrevented){

    				if(sizes){
    					if(isAuto){
    						addClass(elem, lazySizesCfg.autosizesClass);
    					} else {
    						elem.setAttribute('sizes', sizes);
    					}
    				}

    				srcset = elem[_getAttribute](lazySizesCfg.srcsetAttr);
    				src = elem[_getAttribute](lazySizesCfg.srcAttr);

    				if(isImg) {
    					parent = elem.parentNode;
    					isPicture = parent && regPicture.test(parent.nodeName || '');
    				}

    				firesLoad = detail.firesLoad || (('src' in elem) && (srcset || src || isPicture));

    				event = {target: elem};

    				addClass(elem, lazySizesCfg.loadingClass);

    				if(firesLoad){
    					clearTimeout(resetPreloadingTimer);
    					resetPreloadingTimer = setTimeout(resetPreloading, 2500);
    					addRemoveLoadEvents(elem, rafSwitchLoadingClass, true);
    				}

    				if(isPicture){
    					forEach.call(parent.getElementsByTagName('source'), handleSources);
    				}

    				if(srcset){
    					elem.setAttribute('srcset', srcset);
    				} else if(src && !isPicture){
    					if(regIframe.test(elem.nodeName)){
    						changeIframeSrc(elem, src);
    					} else {
    						elem.src = src;
    					}
    				}

    				if(isImg && (srcset || isPicture)){
    					updatePolyfill(elem, {src: src});
    				}
    			}

    			if(elem._lazyRace){
    				delete elem._lazyRace;
    			}
    			removeClass(elem, lazySizesCfg.lazyClass);

    			rAF(function(){
    				// Part of this can be removed as soon as this fix is older: https://bugs.chromium.org/p/chromium/issues/detail?id=7731 (2015)
    				var isLoaded = elem.complete && elem.naturalWidth > 1;

    				if( !firesLoad || isLoaded){
    					if (isLoaded) {
    						addClass(elem, 'ls-is-cached');
    					}
    					switchLoadingClass(event);
    					elem._lazyCache = true;
    					setTimeout(function(){
    						if ('_lazyCache' in elem) {
    							delete elem._lazyCache;
    						}
    					}, 9);
    				}
    				if (elem.loading == 'lazy') {
    					isLoading--;
    				}
    			}, true);
    		});

    		var unveilElement = function (elem){
    			if (elem._lazyRace) {return;}
    			var detail;

    			var isImg = regImg.test(elem.nodeName);

    			//allow using sizes="auto", but don't use. it's invalid. Use data-sizes="auto" or a valid value for sizes instead (i.e.: sizes="80vw")
    			var sizes = isImg && (elem[_getAttribute](lazySizesCfg.sizesAttr) || elem[_getAttribute]('sizes'));
    			var isAuto = sizes == 'auto';

    			if( (isAuto || !isCompleted) && isImg && (elem[_getAttribute]('src') || elem.srcset) && !elem.complete && !hasClass(elem, lazySizesCfg.errorClass) && hasClass(elem, lazySizesCfg.lazyClass)){return;}

    			detail = triggerEvent(elem, 'lazyunveilread').detail;

    			if(isAuto){
    				 autoSizer.updateElem(elem, true, elem.offsetWidth);
    			}

    			elem._lazyRace = true;
    			isLoading++;

    			lazyUnveil(elem, detail, isAuto, sizes, isImg);
    		};

    		var afterScroll = debounce(function(){
    			lazySizesCfg.loadMode = 3;
    			throttledCheckElements();
    		});

    		var altLoadmodeScrollListner = function(){
    			if(lazySizesCfg.loadMode == 3){
    				lazySizesCfg.loadMode = 2;
    			}
    			afterScroll();
    		};

    		var onload = function(){
    			if(isCompleted){return;}
    			if(Date.now() - started < 999){
    				setTimeout(onload, 999);
    				return;
    			}


    			isCompleted = true;

    			lazySizesCfg.loadMode = 3;

    			throttledCheckElements();

    			addEventListener('scroll', altLoadmodeScrollListner, true);
    		};

    		return {
    			_: function(){
    				started = Date.now();

    				lazysizes.elements = document.getElementsByClassName(lazySizesCfg.lazyClass);
    				preloadElems = document.getElementsByClassName(lazySizesCfg.lazyClass + ' ' + lazySizesCfg.preloadClass);

    				addEventListener('scroll', throttledCheckElements, true);

    				addEventListener('resize', throttledCheckElements, true);

    				addEventListener('pageshow', function (e) {
    					if (e.persisted) {
    						var loadingElements = document.querySelectorAll('.' + lazySizesCfg.loadingClass);

    						if (loadingElements.length && loadingElements.forEach) {
    							requestAnimationFrame(function () {
    								loadingElements.forEach( function (img) {
    									if (img.complete) {
    										unveilElement(img);
    									}
    								});
    							});
    						}
    					}
    				});

    				if(window.MutationObserver){
    					new MutationObserver( throttledCheckElements ).observe( docElem, {childList: true, subtree: true, attributes: true} );
    				} else {
    					docElem[_addEventListener]('DOMNodeInserted', throttledCheckElements, true);
    					docElem[_addEventListener]('DOMAttrModified', throttledCheckElements, true);
    					setInterval(throttledCheckElements, 999);
    				}

    				addEventListener('hashchange', throttledCheckElements, true);

    				//, 'fullscreenchange'
    				['focus', 'mouseover', 'click', 'load', 'transitionend', 'animationend'].forEach(function(name){
    					document[_addEventListener](name, throttledCheckElements, true);
    				});

    				if((/d$|^c/.test(document.readyState))){
    					onload();
    				} else {
    					addEventListener('load', onload);
    					document[_addEventListener]('DOMContentLoaded', throttledCheckElements);
    					setTimeout(onload, 20000);
    				}

    				if(lazysizes.elements.length){
    					checkElements();
    					rAF._lsFlush();
    				} else {
    					throttledCheckElements();
    				}
    			},
    			checkElems: throttledCheckElements,
    			unveil: unveilElement,
    			_aLSL: altLoadmodeScrollListner,
    		};
    	})();


    	var autoSizer = (function(){
    		var autosizesElems;

    		var sizeElement = rAFIt(function(elem, parent, event, width){
    			var sources, i, len;
    			elem._lazysizesWidth = width;
    			width += 'px';

    			elem.setAttribute('sizes', width);

    			if(regPicture.test(parent.nodeName || '')){
    				sources = parent.getElementsByTagName('source');
    				for(i = 0, len = sources.length; i < len; i++){
    					sources[i].setAttribute('sizes', width);
    				}
    			}

    			if(!event.detail.dataAttr){
    				updatePolyfill(elem, event.detail);
    			}
    		});
    		var getSizeElement = function (elem, dataAttr, width){
    			var event;
    			var parent = elem.parentNode;

    			if(parent){
    				width = getWidth(elem, parent, width);
    				event = triggerEvent(elem, 'lazybeforesizes', {width: width, dataAttr: !!dataAttr});

    				if(!event.defaultPrevented){
    					width = event.detail.width;

    					if(width && width !== elem._lazysizesWidth){
    						sizeElement(elem, parent, event, width);
    					}
    				}
    			}
    		};

    		var updateElementsSizes = function(){
    			var i;
    			var len = autosizesElems.length;
    			if(len){
    				i = 0;

    				for(; i < len; i++){
    					getSizeElement(autosizesElems[i]);
    				}
    			}
    		};

    		var debouncedUpdateElementsSizes = debounce(updateElementsSizes);

    		return {
    			_: function(){
    				autosizesElems = document.getElementsByClassName(lazySizesCfg.autosizesClass);
    				addEventListener('resize', debouncedUpdateElementsSizes);
    			},
    			checkElems: debouncedUpdateElementsSizes,
    			updateElem: getSizeElement
    		};
    	})();

    	var init = function(){
    		if(!init.i && document.getElementsByClassName){
    			init.i = true;
    			autoSizer._();
    			loader._();
    		}
    	};

    	setTimeout(function(){
    		if(lazySizesCfg.init){
    			init();
    		}
    	});

    	lazysizes = {
    		cfg: lazySizesCfg,
    		autoSizer: autoSizer,
    		loader: loader,
    		init: init,
    		uP: updatePolyfill,
    		aC: addClass,
    		rC: removeClass,
    		hC: hasClass,
    		fire: triggerEvent,
    		gW: getWidth,
    		rAF: rAF,
    	};

    	return lazysizes;
    }
    ));
    });

    /* src\components\Linkpreview.svelte generated by Svelte v3.18.1 */
    const file$1 = "src\\components\\Linkpreview.svelte";

    function create_fragment$1(ctx) {
    	let a;
    	let span;
    	let img;
    	let img_src_value;
    	let t0;
    	let h3;
    	let t1;
    	let t2;
    	let p;
    	let t3;
    	let t4;
    	let h5;
    	let t5;

    	const block = {
    		c: function create() {
    			a = element("a");
    			span = element("span");
    			img = element("img");
    			t0 = space();
    			h3 = element("h3");
    			t1 = text(/*title*/ ctx[0]);
    			t2 = space();
    			p = element("p");
    			t3 = text(/*description*/ ctx[2]);
    			t4 = space();
    			h5 = element("h5");
    			t5 = text(/*url*/ ctx[1]);
    			attr_dev(img, "await", "");
    			if (img.src !== (img_src_value = /*image*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "lazyload svelte-1dv8vd1");
    			attr_dev(img, "alt", "Web logo");
    			add_location(img, file$1, 51, 4, 774);
    			attr_dev(h3, "class", "webtitle svelte-1dv8vd1");
    			add_location(h3, file$1, 52, 4, 835);
    			attr_dev(p, "class", "svelte-1dv8vd1");
    			add_location(p, file$1, 53, 4, 874);
    			attr_dev(h5, "class", "svelte-1dv8vd1");
    			add_location(h5, file$1, 54, 4, 900);
    			attr_dev(span, "class", "linkp svelte-1dv8vd1");
    			attr_dev(span, "href", /*url*/ ctx[1]);
    			add_location(span, file$1, 50, 0, 737);
    			attr_dev(a, "href", /*url*/ ctx[1]);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "class", "svelte-1dv8vd1");
    			add_location(a, file$1, 49, 0, 705);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, span);
    			append_dev(span, img);
    			append_dev(span, t0);
    			append_dev(span, h3);
    			append_dev(h3, t1);
    			append_dev(span, t2);
    			append_dev(span, p);
    			append_dev(p, t3);
    			append_dev(span, t4);
    			append_dev(span, h5);
    			append_dev(h5, t5);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*image*/ 8 && img.src !== (img_src_value = /*image*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*title*/ 1) set_data_dev(t1, /*title*/ ctx[0]);
    			if (dirty & /*description*/ 4) set_data_dev(t3, /*description*/ ctx[2]);
    			if (dirty & /*url*/ 2) set_data_dev(t5, /*url*/ ctx[1]);

    			if (dirty & /*url*/ 2) {
    				attr_dev(span, "href", /*url*/ ctx[1]);
    			}

    			if (dirty & /*url*/ 2) {
    				attr_dev(a, "href", /*url*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { title } = $$props,
    		{ url } = $$props,
    		{ description } = $$props,
    		{ image } = $$props;

    	const writable_props = ["title", "url", "description", "image"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Linkpreview> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("url" in $$props) $$invalidate(1, url = $$props.url);
    		if ("description" in $$props) $$invalidate(2, description = $$props.description);
    		if ("image" in $$props) $$invalidate(3, image = $$props.image);
    	};

    	$$self.$capture_state = () => {
    		return { title, url, description, image };
    	};

    	$$self.$inject_state = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("url" in $$props) $$invalidate(1, url = $$props.url);
    		if ("description" in $$props) $$invalidate(2, description = $$props.description);
    		if ("image" in $$props) $$invalidate(3, image = $$props.image);
    	};

    	return [title, url, description, image];
    }

    class Linkpreview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
    			title: 0,
    			url: 1,
    			description: 2,
    			image: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Linkpreview",
    			options,
    			id: create_fragment$1.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*title*/ ctx[0] === undefined && !("title" in props)) {
    			console.warn("<Linkpreview> was created without expected prop 'title'");
    		}

    		if (/*url*/ ctx[1] === undefined && !("url" in props)) {
    			console.warn("<Linkpreview> was created without expected prop 'url'");
    		}

    		if (/*description*/ ctx[2] === undefined && !("description" in props)) {
    			console.warn("<Linkpreview> was created without expected prop 'description'");
    		}

    		if (/*image*/ ctx[3] === undefined && !("image" in props)) {
    			console.warn("<Linkpreview> was created without expected prop 'image'");
    		}
    	}

    	get title() {
    		throw new Error("<Linkpreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Linkpreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<Linkpreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Linkpreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get description() {
    		throw new Error("<Linkpreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set description(value) {
    		throw new Error("<Linkpreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get image() {
    		throw new Error("<Linkpreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set image(value) {
    		throw new Error("<Linkpreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var css$1 = ".mdc-button{padding:0;min-width:24px}.mdc-button:after,.mdc-button:before{background:none}.mdc-menu{max-width:450px}.mdc-menu-surface{top:50px!important}.mdc-tab-bar{position:static}.mdc-list{height:300px;overflow:hidden;overflow-y:scroll;scroll-behavior:smooth;scrollbar-width:5px}::-webkit-scrollbar{width:5px}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px rgba(0,0,0,.3);-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);-webkit-border-radius:5px;border-radius:5px}::-webkit-scrollbar-thumb{-webkit-border-radius:5px;border-radius:5px;background:rgba(196,183,183,.8);-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.5);box-shadow:inset 0 0 6px rgba(0,0,0,.5)}::-webkit-scrollbar-thumb:window-inactive{background:rgba(138,129,129,.4)}.mdc-dialog,.mdc-dialog__scrim{position:fixed;top:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;width:100%;height:100%}.mdc-dialog{display:none;z-index:7}.mdc-dialog .mdc-dialog__surface{background-color:#fff;background-color:var(--mdc-theme-surface,#fff)}.mdc-dialog .mdc-dialog__scrim{background-color:rgba(0,0,0,.32)}.mdc-dialog .mdc-dialog__title{color:rgba(0,0,0,.87)}.mdc-dialog .mdc-dialog__content{color:rgba(0,0,0,.6)}.mdc-dialog.mdc-dialog--scrollable .mdc-dialog__actions,.mdc-dialog.mdc-dialog--scrollable .mdc-dialog__title{border-color:rgba(0,0,0,.12)}.mdc-dialog .mdc-dialog__surface{min-width:280px}@media (max-width:592px){.mdc-dialog .mdc-dialog__surface{max-width:calc(100vw - 32px)}}@media (min-width:592px){.mdc-dialog .mdc-dialog__surface{max-width:560px}}.mdc-dialog .mdc-dialog__surface{max-height:calc(100% - 32px)}.mdc-dialog .mdc-dialog__surface{border-radius:4px}.mdc-dialog__scrim{opacity:0;z-index:-1}.mdc-dialog__container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;transform:scale(.8);opacity:0;pointer-events:none}.mdc-dialog__surface{box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12);display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;max-width:100%;max-height:100%;pointer-events:auto;overflow-y:auto}.mdc-dialog[dir=rtl] .mdc-dialog__surface,[dir=rtl] .mdc-dialog .mdc-dialog__surface{text-align:right}.mdc-dialog__title{line-height:normal;font-family:Roboto,sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:1.25rem;line-height:2rem;font-weight:500;letter-spacing:.0125em;text-decoration:inherit;text-transform:inherit;display:block;position:relative;flex-shrink:0;box-sizing:border-box;margin:0;padding:0 24px 9px;border-bottom:1px solid transparent}.mdc-dialog__title:before{display:inline-block;width:0;height:40px;content:\"\";vertical-align:0}.mdc-dialog[dir=rtl] .mdc-dialog__title,[dir=rtl] .mdc-dialog .mdc-dialog__title{text-align:right}.mdc-dialog--scrollable .mdc-dialog__title{padding-bottom:15px}.mdc-dialog__content{font-family:Roboto,sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:1rem;line-height:1.5rem;font-weight:400;letter-spacing:.03125em;text-decoration:inherit;text-transform:inherit;flex-grow:1;box-sizing:border-box;margin:0;padding:20px 24px;overflow:auto;-webkit-overflow-scrolling:touch}.mdc-dialog__content>:first-child{margin-top:0}.mdc-dialog__content>:last-child{margin-bottom:0}.mdc-dialog__title+.mdc-dialog__content{padding-top:0}.mdc-dialog--scrollable .mdc-dialog__content{padding-top:8px;padding-bottom:8px}.mdc-dialog__content .mdc-list:first-child:last-child{padding:6px 0 0}.mdc-dialog--scrollable .mdc-dialog__content .mdc-list:first-child:last-child{padding:0}.mdc-dialog__actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid transparent}.mdc-dialog--stacked .mdc-dialog__actions{flex-direction:column;align-items:flex-end}.mdc-dialog__button{margin-left:8px;margin-right:0;max-width:100%;text-align:right}.mdc-dialog__button[dir=rtl],[dir=rtl] .mdc-dialog__button{margin-left:0;margin-right:8px}.mdc-dialog__button:first-child,.mdc-dialog__button:first-child[dir=rtl],[dir=rtl] .mdc-dialog__button:first-child{margin-left:0;margin-right:0}.mdc-dialog[dir=rtl] .mdc-dialog__button,[dir=rtl] .mdc-dialog .mdc-dialog__button{text-align:left}.mdc-dialog--stacked .mdc-dialog__button:not(:first-child){margin-top:12px}.mdc-dialog--closing,.mdc-dialog--open,.mdc-dialog--opening{display:flex}.mdc-dialog--opening .mdc-dialog__scrim{transition:opacity .15s linear}.mdc-dialog--opening .mdc-dialog__container{transition:opacity 75ms linear,transform .15s cubic-bezier(0,0,.2,1) 0ms}.mdc-dialog--closing .mdc-dialog__container,.mdc-dialog--closing .mdc-dialog__scrim{transition:opacity 75ms linear}.mdc-dialog--closing .mdc-dialog__container{transform:scale(1)}.mdc-dialog--open .mdc-dialog__scrim{opacity:1}.mdc-dialog--open .mdc-dialog__container{transform:scale(1);opacity:1}.mdc-dialog-scroll-lock{overflow:hidden}";
    styleInject(css$1);

    var candidateSelectors = [
      'input',
      'select',
      'textarea',
      'a[href]',
      'button',
      '[tabindex]',
      'audio[controls]',
      'video[controls]',
      '[contenteditable]:not([contenteditable="false"])',
    ];
    var candidateSelector = candidateSelectors.join(',');

    var matches = typeof Element === 'undefined'
      ? function () {}
      : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

    function tabbable(el, options) {
      options = options || {};

      var regularTabbables = [];
      var orderedTabbables = [];

      var candidates = el.querySelectorAll(candidateSelector);

      if (options.includeContainer) {
        if (matches.call(el, candidateSelector)) {
          candidates = Array.prototype.slice.apply(candidates);
          candidates.unshift(el);
        }
      }

      var i, candidate, candidateTabindex;
      for (i = 0; i < candidates.length; i++) {
        candidate = candidates[i];

        if (!isNodeMatchingSelectorTabbable(candidate)) continue;

        candidateTabindex = getTabindex(candidate);
        if (candidateTabindex === 0) {
          regularTabbables.push(candidate);
        } else {
          orderedTabbables.push({
            documentOrder: i,
            tabIndex: candidateTabindex,
            node: candidate,
          });
        }
      }

      var tabbableNodes = orderedTabbables
        .sort(sortOrderedTabbables)
        .map(function(a) { return a.node })
        .concat(regularTabbables);

      return tabbableNodes;
    }

    tabbable.isTabbable = isTabbable;
    tabbable.isFocusable = isFocusable;

    function isNodeMatchingSelectorTabbable(node) {
      if (
        !isNodeMatchingSelectorFocusable(node)
        || isNonTabbableRadio(node)
        || getTabindex(node) < 0
      ) {
        return false;
      }
      return true;
    }

    function isTabbable(node) {
      if (!node) throw new Error('No node provided');
      if (matches.call(node, candidateSelector) === false) return false;
      return isNodeMatchingSelectorTabbable(node);
    }

    function isNodeMatchingSelectorFocusable(node) {
      if (
        node.disabled
        || isHiddenInput(node)
        || isHidden(node)
      ) {
        return false;
      }
      return true;
    }

    var focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');
    function isFocusable(node) {
      if (!node) throw new Error('No node provided');
      if (matches.call(node, focusableCandidateSelector) === false) return false;
      return isNodeMatchingSelectorFocusable(node);
    }

    function getTabindex(node) {
      var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);
      if (!isNaN(tabindexAttr)) return tabindexAttr;
      // Browsers do not return `tabIndex` correctly for contentEditable nodes;
      // so if they don't have a tabindex attribute specifically set, assume it's 0.
      if (isContentEditable(node)) return 0;
      return node.tabIndex;
    }

    function sortOrderedTabbables(a, b) {
      return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
    }

    function isContentEditable(node) {
      return node.contentEditable === 'true';
    }

    function isInput(node) {
      return node.tagName === 'INPUT';
    }

    function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    }

    function isRadio(node) {
      return isInput(node) && node.type === 'radio';
    }

    function isNonTabbableRadio(node) {
      return isRadio(node) && !isTabbableRadio(node);
    }

    function getCheckedRadio(nodes) {
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].checked) {
          return nodes[i];
        }
      }
    }

    function isTabbableRadio(node) {
      if (!node.name) return true;
      // This won't account for the edge case where you have radio groups with the same
      // in separate forms on the same page.
      var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
      var checked = getCheckedRadio(radioSet);
      return !checked || checked === node;
    }

    function isHidden(node) {
      // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,
      // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.
      return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';
    }

    var tabbable_1 = tabbable;

    var immutable = extend;

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function extend() {
        var target = {};

        for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target
    }

    var activeFocusDelay;

    var activeFocusTraps = (function() {
      var trapQueue = [];
      return {
        activateTrap: function(trap) {
          if (trapQueue.length > 0) {
            var activeTrap = trapQueue[trapQueue.length - 1];
            if (activeTrap !== trap) {
              activeTrap.pause();
            }
          }

          var trapIndex = trapQueue.indexOf(trap);
          if (trapIndex === -1) {
            trapQueue.push(trap);
          } else {
            // move this existing trap to the front of the queue
            trapQueue.splice(trapIndex, 1);
            trapQueue.push(trap);
          }
        },

        deactivateTrap: function(trap) {
          var trapIndex = trapQueue.indexOf(trap);
          if (trapIndex !== -1) {
            trapQueue.splice(trapIndex, 1);
          }

          if (trapQueue.length > 0) {
            trapQueue[trapQueue.length - 1].unpause();
          }
        }
      };
    })();

    function focusTrap(element, userOptions) {
      var doc = document;
      var container =
        typeof element === 'string' ? doc.querySelector(element) : element;

      var config = immutable(
        {
          returnFocusOnDeactivate: true,
          escapeDeactivates: true
        },
        userOptions
      );

      var state = {
        firstTabbableNode: null,
        lastTabbableNode: null,
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false
      };

      var trap = {
        activate: activate,
        deactivate: deactivate,
        pause: pause,
        unpause: unpause
      };

      return trap;

      function activate(activateOptions) {
        if (state.active) return;

        updateTabbableNodes();

        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = doc.activeElement;

        var onActivate =
          activateOptions && activateOptions.onActivate
            ? activateOptions.onActivate
            : config.onActivate;
        if (onActivate) {
          onActivate();
        }

        addListeners();
        return trap;
      }

      function deactivate(deactivateOptions) {
        if (!state.active) return;

        clearTimeout(activeFocusDelay);

        removeListeners();
        state.active = false;
        state.paused = false;

        activeFocusTraps.deactivateTrap(trap);

        var onDeactivate =
          deactivateOptions && deactivateOptions.onDeactivate !== undefined
            ? deactivateOptions.onDeactivate
            : config.onDeactivate;
        if (onDeactivate) {
          onDeactivate();
        }

        var returnFocus =
          deactivateOptions && deactivateOptions.returnFocus !== undefined
            ? deactivateOptions.returnFocus
            : config.returnFocusOnDeactivate;
        if (returnFocus) {
          delay(function() {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          });
        }

        return trap;
      }

      function pause() {
        if (state.paused || !state.active) return;
        state.paused = true;
        removeListeners();
      }

      function unpause() {
        if (!state.paused || !state.active) return;
        state.paused = false;
        updateTabbableNodes();
        addListeners();
      }

      function addListeners() {
        if (!state.active) return;

        // There can be only one listening focus trap at a time
        activeFocusTraps.activateTrap(trap);

        // Delay ensures that the focused element doesn't capture the event
        // that caused the focus trap activation.
        activeFocusDelay = delay(function() {
          tryFocus(getInitialFocusNode());
        });

        doc.addEventListener('focusin', checkFocusIn, true);
        doc.addEventListener('mousedown', checkPointerDown, {
          capture: true,
          passive: false
        });
        doc.addEventListener('touchstart', checkPointerDown, {
          capture: true,
          passive: false
        });
        doc.addEventListener('click', checkClick, {
          capture: true,
          passive: false
        });
        doc.addEventListener('keydown', checkKey, {
          capture: true,
          passive: false
        });

        return trap;
      }

      function removeListeners() {
        if (!state.active) return;

        doc.removeEventListener('focusin', checkFocusIn, true);
        doc.removeEventListener('mousedown', checkPointerDown, true);
        doc.removeEventListener('touchstart', checkPointerDown, true);
        doc.removeEventListener('click', checkClick, true);
        doc.removeEventListener('keydown', checkKey, true);

        return trap;
      }

      function getNodeForOption(optionName) {
        var optionValue = config[optionName];
        var node = optionValue;
        if (!optionValue) {
          return null;
        }
        if (typeof optionValue === 'string') {
          node = doc.querySelector(optionValue);
          if (!node) {
            throw new Error('`' + optionName + '` refers to no known node');
          }
        }
        if (typeof optionValue === 'function') {
          node = optionValue();
          if (!node) {
            throw new Error('`' + optionName + '` did not return a node');
          }
        }
        return node;
      }

      function getInitialFocusNode() {
        var node;
        if (getNodeForOption('initialFocus') !== null) {
          node = getNodeForOption('initialFocus');
        } else if (container.contains(doc.activeElement)) {
          node = doc.activeElement;
        } else {
          node = state.firstTabbableNode || getNodeForOption('fallbackFocus');
        }

        if (!node) {
          throw new Error(
            'Your focus-trap needs to have at least one focusable element'
          );
        }

        return node;
      }

      function getReturnFocusNode(previousActiveElement) {
        var node = getNodeForOption('setReturnFocus');
        return node ? node : previousActiveElement;
      }

      // This needs to be done on mousedown and touchstart instead of click
      // so that it precedes the focus event.
      function checkPointerDown(e) {
        if (container.contains(e.target)) return;
        if (config.clickOutsideDeactivates) {
          deactivate({
            returnFocus: !tabbable_1.isFocusable(e.target)
          });
          return;
        }
        // This is needed for mobile devices.
        // (If we'll only let `click` events through,
        // then on mobile they will be blocked anyways if `touchstart` is blocked.)
        if (config.allowOutsideClick && config.allowOutsideClick(e)) {
          return;
        }
        e.preventDefault();
      }

      // In case focus escapes the trap for some strange reason, pull it back in.
      function checkFocusIn(e) {
        // In Firefox when you Tab out of an iframe the Document is briefly focused.
        if (container.contains(e.target) || e.target instanceof Document) {
          return;
        }
        e.stopImmediatePropagation();
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }

      function checkKey(e) {
        if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
          e.preventDefault();
          deactivate();
          return;
        }
        if (isTabEvent(e)) {
          checkTab(e);
          return;
        }
      }

      // Hijack Tab events on the first and last focusable nodes of the trap,
      // in order to prevent focus from escaping. If it escapes for even a
      // moment it can end up scrolling the page and causing confusion so we
      // kind of need to capture the action at the keydown phase.
      function checkTab(e) {
        updateTabbableNodes();
        if (e.shiftKey && e.target === state.firstTabbableNode) {
          e.preventDefault();
          tryFocus(state.lastTabbableNode);
          return;
        }
        if (!e.shiftKey && e.target === state.lastTabbableNode) {
          e.preventDefault();
          tryFocus(state.firstTabbableNode);
          return;
        }
      }

      function checkClick(e) {
        if (config.clickOutsideDeactivates) return;
        if (container.contains(e.target)) return;
        if (config.allowOutsideClick && config.allowOutsideClick(e)) {
          return;
        }
        e.preventDefault();
        e.stopImmediatePropagation();
      }

      function updateTabbableNodes() {
        var tabbableNodes = tabbable_1(container);
        state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();
        state.lastTabbableNode =
          tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();
      }

      function tryFocus(node) {
        if (node === doc.activeElement) return;
        if (!node || !node.focus) {
          tryFocus(getInitialFocusNode());
          return;
        }
        node.focus();
        state.mostRecentlyFocusedNode = node;
        if (isSelectableInput(node)) {
          node.select();
        }
      }
    }

    function isSelectableInput(node) {
      return (
        node.tagName &&
        node.tagName.toLowerCase() === 'input' &&
        typeof node.select === 'function'
      );
    }

    function isEscapeEvent(e) {
      return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
    }

    function isTabEvent(e) {
      return e.key === 'Tab' || e.keyCode === 9;
    }

    function delay(fn) {
      return setTimeout(fn, 0);
    }

    var focusTrap_1 = focusTrap;

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    function createFocusTrapInstance(surfaceEl, focusTrapFactory, initialFocusEl) {
        if (focusTrapFactory === void 0) { focusTrapFactory = focusTrap_1; }
        return focusTrapFactory(surfaceEl, {
            clickOutsideDeactivates: true,
            escapeDeactivates: false,
            initialFocus: initialFocusEl,
        });
    }
    function isScrollable(el) {
        return el ? el.scrollHeight > el.offsetHeight : false;
    }
    function areTopsMisaligned(els) {
        var tops = new Set();
        [].forEach.call(els, function (el) { return tops.add(el.offsetTop); });
        return tops.size > 1;
    }
    //# sourceMappingURL=util.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
     * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
     */
    function closest(element, selector) {
        if (element.closest) {
            return element.closest(selector);
        }
        var el = element;
        while (el) {
            if (matches$1(el, selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    function matches$1(element, selector) {
        var nativeMatches = element.matches
            || element.webkitMatchesSelector
            || element.msMatchesSelector;
        return nativeMatches.call(element, selector);
    }
    //# sourceMappingURL=ponyfill.js.map

    /**
     * @license
     * Copyright 2019 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * Stores result from applyPassive to avoid redundant processing to detect
     * passive event listener support.
     */
    var supportsPassive_;
    /**
     * Determine whether the current browser supports passive event listeners, and
     * if so, use them.
     */
    function applyPassive(globalObj, forceRefresh) {
        if (globalObj === void 0) { globalObj = window; }
        if (forceRefresh === void 0) { forceRefresh = false; }
        if (supportsPassive_ === undefined || forceRefresh) {
            var isSupported_1 = false;
            try {
                globalObj.document.addEventListener('test', function () { return undefined; }, {
                    get passive() {
                        isSupported_1 = true;
                        return isSupported_1;
                    },
                });
            }
            catch (e) {
            } // tslint:disable-line:no-empty cannot throw error due to tests. tslint also disables console.log.
            supportsPassive_ = isSupported_1;
        }
        return supportsPassive_ ? { passive: true } : false;
    }
    //# sourceMappingURL=events.js.map

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$1 = {
        // Ripple is a special case where the "root" component is really a "mixin" of sorts,
        // given that it's an 'upgrade' to an existing component. That being said it is the root
        // CSS class that all other CSS classes derive from.
        BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
        FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
        FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation',
        ROOT: 'mdc-ripple-upgraded',
        UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
    };
    var strings$1 = {
        VAR_FG_SCALE: '--mdc-ripple-fg-scale',
        VAR_FG_SIZE: '--mdc-ripple-fg-size',
        VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end',
        VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
        VAR_LEFT: '--mdc-ripple-left',
        VAR_TOP: '--mdc-ripple-top',
    };
    var numbers$1 = {
        DEACTIVATION_TIMEOUT_MS: 225,
        FG_DEACTIVATION_MS: 150,
        INITIAL_ORIGIN_SCALE: 0.6,
        PADDING: 10,
        TAP_DELAY_MS: 300,
    };
    //# sourceMappingURL=constants.js.map

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to
     * detect CSS custom variable support.
     */
    var supportsCssVariables_;
    function detectEdgePseudoVarBug(windowObj) {
        // Detect versions of Edge with buggy var() support
        // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
        var document = windowObj.document;
        var node = document.createElement('div');
        node.className = 'mdc-ripple-surface--test-edge-var-bug';
        // Append to head instead of body because this script might be invoked in the
        // head, in which case the body doesn't exist yet. The probe works either way.
        document.head.appendChild(node);
        // The bug exists if ::before style ends up propagating to the parent element.
        // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
        // but Firefox is known to support CSS custom properties correctly.
        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
        var computedStyle = windowObj.getComputedStyle(node);
        var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
        return hasPseudoVarBug;
    }
    function supportsCssVariables(windowObj, forceRefresh) {
        if (forceRefresh === void 0) { forceRefresh = false; }
        var CSS = windowObj.CSS;
        var supportsCssVars = supportsCssVariables_;
        if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
            return supportsCssVariables_;
        }
        var supportsFunctionPresent = CSS && typeof CSS.supports === 'function';
        if (!supportsFunctionPresent) {
            return false;
        }
        var explicitlySupportsCssVars = CSS.supports('--css-vars', 'yes');
        // See: https://bugs.webkit.org/show_bug.cgi?id=154669
        // See: README section on Safari
        var weAreFeatureDetectingSafari10plus = (CSS.supports('(--css-vars: yes)') &&
            CSS.supports('color', '#00000000'));
        if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
            supportsCssVars = !detectEdgePseudoVarBug(windowObj);
        }
        else {
            supportsCssVars = false;
        }
        if (!forceRefresh) {
            supportsCssVariables_ = supportsCssVars;
        }
        return supportsCssVars;
    }
    function getNormalizedEventCoords(evt, pageOffset, clientRect) {
        if (!evt) {
            return { x: 0, y: 0 };
        }
        var x = pageOffset.x, y = pageOffset.y;
        var documentX = x + clientRect.left;
        var documentY = y + clientRect.top;
        var normalizedX;
        var normalizedY;
        // Determine touch point relative to the ripple container.
        if (evt.type === 'touchstart') {
            var touchEvent = evt;
            normalizedX = touchEvent.changedTouches[0].pageX - documentX;
            normalizedY = touchEvent.changedTouches[0].pageY - documentY;
        }
        else {
            var mouseEvent = evt;
            normalizedX = mouseEvent.pageX - documentX;
            normalizedY = mouseEvent.pageY - documentY;
        }
        return { x: normalizedX, y: normalizedY };
    }
    //# sourceMappingURL=util.js.map

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    // Activation events registered on the root element of each instance for activation
    var ACTIVATION_EVENT_TYPES = [
        'touchstart', 'pointerdown', 'mousedown', 'keydown',
    ];
    // Deactivation events registered on documentElement when a pointer-related down event occurs
    var POINTER_DEACTIVATION_EVENT_TYPES = [
        'touchend', 'pointerup', 'mouseup', 'contextmenu',
    ];
    // simultaneous nested activations
    var activatedTargets = [];
    var MDCRippleFoundation = /** @class */ (function (_super) {
        __extends(MDCRippleFoundation, _super);
        function MDCRippleFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCRippleFoundation.defaultAdapter, adapter)) || this;
            _this.activationAnimationHasEnded_ = false;
            _this.activationTimer_ = 0;
            _this.fgDeactivationRemovalTimer_ = 0;
            _this.fgScale_ = '0';
            _this.frame_ = { width: 0, height: 0 };
            _this.initialSize_ = 0;
            _this.layoutFrame_ = 0;
            _this.maxRadius_ = 0;
            _this.unboundedCoords_ = { left: 0, top: 0 };
            _this.activationState_ = _this.defaultActivationState_();
            _this.activationTimerCallback_ = function () {
                _this.activationAnimationHasEnded_ = true;
                _this.runDeactivationUXLogicIfReady_();
            };
            _this.activateHandler_ = function (e) { return _this.activate_(e); };
            _this.deactivateHandler_ = function () { return _this.deactivate_(); };
            _this.focusHandler_ = function () { return _this.handleFocus(); };
            _this.blurHandler_ = function () { return _this.handleBlur(); };
            _this.resizeHandler_ = function () { return _this.layout(); };
            return _this;
        }
        Object.defineProperty(MDCRippleFoundation, "cssClasses", {
            get: function () {
                return cssClasses$1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRippleFoundation, "strings", {
            get: function () {
                return strings$1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRippleFoundation, "numbers", {
            get: function () {
                return numbers$1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRippleFoundation, "defaultAdapter", {
            get: function () {
                return {
                    addClass: function () { return undefined; },
                    browserSupportsCssVars: function () { return true; },
                    computeBoundingRect: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                    containsEventTarget: function () { return true; },
                    deregisterDocumentInteractionHandler: function () { return undefined; },
                    deregisterInteractionHandler: function () { return undefined; },
                    deregisterResizeHandler: function () { return undefined; },
                    getWindowPageOffset: function () { return ({ x: 0, y: 0 }); },
                    isSurfaceActive: function () { return true; },
                    isSurfaceDisabled: function () { return true; },
                    isUnbounded: function () { return true; },
                    registerDocumentInteractionHandler: function () { return undefined; },
                    registerInteractionHandler: function () { return undefined; },
                    registerResizeHandler: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    updateCssVariable: function () { return undefined; },
                };
            },
            enumerable: true,
            configurable: true
        });
        MDCRippleFoundation.prototype.init = function () {
            var _this = this;
            var supportsPressRipple = this.supportsPressRipple_();
            this.registerRootHandlers_(supportsPressRipple);
            if (supportsPressRipple) {
                var _a = MDCRippleFoundation.cssClasses, ROOT_1 = _a.ROOT, UNBOUNDED_1 = _a.UNBOUNDED;
                requestAnimationFrame(function () {
                    _this.adapter_.addClass(ROOT_1);
                    if (_this.adapter_.isUnbounded()) {
                        _this.adapter_.addClass(UNBOUNDED_1);
                        // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
                        _this.layoutInternal_();
                    }
                });
            }
        };
        MDCRippleFoundation.prototype.destroy = function () {
            var _this = this;
            if (this.supportsPressRipple_()) {
                if (this.activationTimer_) {
                    clearTimeout(this.activationTimer_);
                    this.activationTimer_ = 0;
                    this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
                }
                if (this.fgDeactivationRemovalTimer_) {
                    clearTimeout(this.fgDeactivationRemovalTimer_);
                    this.fgDeactivationRemovalTimer_ = 0;
                    this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
                }
                var _a = MDCRippleFoundation.cssClasses, ROOT_2 = _a.ROOT, UNBOUNDED_2 = _a.UNBOUNDED;
                requestAnimationFrame(function () {
                    _this.adapter_.removeClass(ROOT_2);
                    _this.adapter_.removeClass(UNBOUNDED_2);
                    _this.removeCssVars_();
                });
            }
            this.deregisterRootHandlers_();
            this.deregisterDeactivationHandlers_();
        };
        /**
         * @param evt Optional event containing position information.
         */
        MDCRippleFoundation.prototype.activate = function (evt) {
            this.activate_(evt);
        };
        MDCRippleFoundation.prototype.deactivate = function () {
            this.deactivate_();
        };
        MDCRippleFoundation.prototype.layout = function () {
            var _this = this;
            if (this.layoutFrame_) {
                cancelAnimationFrame(this.layoutFrame_);
            }
            this.layoutFrame_ = requestAnimationFrame(function () {
                _this.layoutInternal_();
                _this.layoutFrame_ = 0;
            });
        };
        MDCRippleFoundation.prototype.setUnbounded = function (unbounded) {
            var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;
            if (unbounded) {
                this.adapter_.addClass(UNBOUNDED);
            }
            else {
                this.adapter_.removeClass(UNBOUNDED);
            }
        };
        MDCRippleFoundation.prototype.handleFocus = function () {
            var _this = this;
            requestAnimationFrame(function () {
                return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
            });
        };
        MDCRippleFoundation.prototype.handleBlur = function () {
            var _this = this;
            requestAnimationFrame(function () {
                return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
            });
        };
        /**
         * We compute this property so that we are not querying information about the client
         * until the point in time where the foundation requests it. This prevents scenarios where
         * client-side feature-detection may happen too early, such as when components are rendered on the server
         * and then initialized at mount time on the client.
         */
        MDCRippleFoundation.prototype.supportsPressRipple_ = function () {
            return this.adapter_.browserSupportsCssVars();
        };
        MDCRippleFoundation.prototype.defaultActivationState_ = function () {
            return {
                activationEvent: undefined,
                hasDeactivationUXRun: false,
                isActivated: false,
                isProgrammatic: false,
                wasActivatedByPointer: false,
                wasElementMadeActive: false,
            };
        };
        /**
         * supportsPressRipple Passed from init to save a redundant function call
         */
        MDCRippleFoundation.prototype.registerRootHandlers_ = function (supportsPressRipple) {
            var _this = this;
            if (supportsPressRipple) {
                ACTIVATION_EVENT_TYPES.forEach(function (evtType) {
                    _this.adapter_.registerInteractionHandler(evtType, _this.activateHandler_);
                });
                if (this.adapter_.isUnbounded()) {
                    this.adapter_.registerResizeHandler(this.resizeHandler_);
                }
            }
            this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
            this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        };
        MDCRippleFoundation.prototype.registerDeactivationHandlers_ = function (evt) {
            var _this = this;
            if (evt.type === 'keydown') {
                this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
            }
            else {
                POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (evtType) {
                    _this.adapter_.registerDocumentInteractionHandler(evtType, _this.deactivateHandler_);
                });
            }
        };
        MDCRippleFoundation.prototype.deregisterRootHandlers_ = function () {
            var _this = this;
            ACTIVATION_EVENT_TYPES.forEach(function (evtType) {
                _this.adapter_.deregisterInteractionHandler(evtType, _this.activateHandler_);
            });
            this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
            this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
            if (this.adapter_.isUnbounded()) {
                this.adapter_.deregisterResizeHandler(this.resizeHandler_);
            }
        };
        MDCRippleFoundation.prototype.deregisterDeactivationHandlers_ = function () {
            var _this = this;
            this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
            POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (evtType) {
                _this.adapter_.deregisterDocumentInteractionHandler(evtType, _this.deactivateHandler_);
            });
        };
        MDCRippleFoundation.prototype.removeCssVars_ = function () {
            var _this = this;
            var rippleStrings = MDCRippleFoundation.strings;
            var keys = Object.keys(rippleStrings);
            keys.forEach(function (key) {
                if (key.indexOf('VAR_') === 0) {
                    _this.adapter_.updateCssVariable(rippleStrings[key], null);
                }
            });
        };
        MDCRippleFoundation.prototype.activate_ = function (evt) {
            var _this = this;
            if (this.adapter_.isSurfaceDisabled()) {
                return;
            }
            var activationState = this.activationState_;
            if (activationState.isActivated) {
                return;
            }
            // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
            var previousActivationEvent = this.previousActivationEvent_;
            var isSameInteraction = previousActivationEvent && evt !== undefined && previousActivationEvent.type !== evt.type;
            if (isSameInteraction) {
                return;
            }
            activationState.isActivated = true;
            activationState.isProgrammatic = evt === undefined;
            activationState.activationEvent = evt;
            activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== undefined && (evt.type === 'mousedown' || evt.type === 'touchstart' || evt.type === 'pointerdown');
            var hasActivatedChild = evt !== undefined && activatedTargets.length > 0 && activatedTargets.some(function (target) { return _this.adapter_.containsEventTarget(target); });
            if (hasActivatedChild) {
                // Immediately reset activation state, while preserving logic that prevents touch follow-on events
                this.resetActivationState_();
                return;
            }
            if (evt !== undefined) {
                activatedTargets.push(evt.target);
                this.registerDeactivationHandlers_(evt);
            }
            activationState.wasElementMadeActive = this.checkElementMadeActive_(evt);
            if (activationState.wasElementMadeActive) {
                this.animateActivation_();
            }
            requestAnimationFrame(function () {
                // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
                activatedTargets = [];
                if (!activationState.wasElementMadeActive
                    && evt !== undefined
                    && (evt.key === ' ' || evt.keyCode === 32)) {
                    // If space was pressed, try again within an rAF call to detect :active, because different UAs report
                    // active states inconsistently when they're called within event handling code:
                    // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
                    // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
                    // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
                    // variable is set within a rAF callback for a submit button interaction (#2241).
                    activationState.wasElementMadeActive = _this.checkElementMadeActive_(evt);
                    if (activationState.wasElementMadeActive) {
                        _this.animateActivation_();
                    }
                }
                if (!activationState.wasElementMadeActive) {
                    // Reset activation state immediately if element was not made active.
                    _this.activationState_ = _this.defaultActivationState_();
                }
            });
        };
        MDCRippleFoundation.prototype.checkElementMadeActive_ = function (evt) {
            return (evt !== undefined && evt.type === 'keydown') ? this.adapter_.isSurfaceActive() : true;
        };
        MDCRippleFoundation.prototype.animateActivation_ = function () {
            var _this = this;
            var _a = MDCRippleFoundation.strings, VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;
            var _b = MDCRippleFoundation.cssClasses, FG_DEACTIVATION = _b.FG_DEACTIVATION, FG_ACTIVATION = _b.FG_ACTIVATION;
            var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
            this.layoutInternal_();
            var translateStart = '';
            var translateEnd = '';
            if (!this.adapter_.isUnbounded()) {
                var _c = this.getFgTranslationCoordinates_(), startPoint = _c.startPoint, endPoint = _c.endPoint;
                translateStart = startPoint.x + "px, " + startPoint.y + "px";
                translateEnd = endPoint.x + "px, " + endPoint.y + "px";
            }
            this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
            this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
            // Cancel any ongoing activation/deactivation animations
            clearTimeout(this.activationTimer_);
            clearTimeout(this.fgDeactivationRemovalTimer_);
            this.rmBoundedActivationClasses_();
            this.adapter_.removeClass(FG_DEACTIVATION);
            // Force layout in order to re-trigger the animation.
            this.adapter_.computeBoundingRect();
            this.adapter_.addClass(FG_ACTIVATION);
            this.activationTimer_ = setTimeout(function () { return _this.activationTimerCallback_(); }, DEACTIVATION_TIMEOUT_MS);
        };
        MDCRippleFoundation.prototype.getFgTranslationCoordinates_ = function () {
            var _a = this.activationState_, activationEvent = _a.activationEvent, wasActivatedByPointer = _a.wasActivatedByPointer;
            var startPoint;
            if (wasActivatedByPointer) {
                startPoint = getNormalizedEventCoords(activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
            }
            else {
                startPoint = {
                    x: this.frame_.width / 2,
                    y: this.frame_.height / 2,
                };
            }
            // Center the element around the start point.
            startPoint = {
                x: startPoint.x - (this.initialSize_ / 2),
                y: startPoint.y - (this.initialSize_ / 2),
            };
            var endPoint = {
                x: (this.frame_.width / 2) - (this.initialSize_ / 2),
                y: (this.frame_.height / 2) - (this.initialSize_ / 2),
            };
            return { startPoint: startPoint, endPoint: endPoint };
        };
        MDCRippleFoundation.prototype.runDeactivationUXLogicIfReady_ = function () {
            var _this = this;
            // This method is called both when a pointing device is released, and when the activation animation ends.
            // The deactivation animation should only run after both of those occur.
            var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
            var _a = this.activationState_, hasDeactivationUXRun = _a.hasDeactivationUXRun, isActivated = _a.isActivated;
            var activationHasEnded = hasDeactivationUXRun || !isActivated;
            if (activationHasEnded && this.activationAnimationHasEnded_) {
                this.rmBoundedActivationClasses_();
                this.adapter_.addClass(FG_DEACTIVATION);
                this.fgDeactivationRemovalTimer_ = setTimeout(function () {
                    _this.adapter_.removeClass(FG_DEACTIVATION);
                }, numbers$1.FG_DEACTIVATION_MS);
            }
        };
        MDCRippleFoundation.prototype.rmBoundedActivationClasses_ = function () {
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
            this.activationAnimationHasEnded_ = false;
            this.adapter_.computeBoundingRect();
        };
        MDCRippleFoundation.prototype.resetActivationState_ = function () {
            var _this = this;
            this.previousActivationEvent_ = this.activationState_.activationEvent;
            this.activationState_ = this.defaultActivationState_();
            // Touch devices may fire additional events for the same interaction within a short time.
            // Store the previous event until it's safe to assume that subsequent events are for new interactions.
            setTimeout(function () { return _this.previousActivationEvent_ = undefined; }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        };
        MDCRippleFoundation.prototype.deactivate_ = function () {
            var _this = this;
            var activationState = this.activationState_;
            // This can happen in scenarios such as when you have a keyup event that blurs the element.
            if (!activationState.isActivated) {
                return;
            }
            var state = __assign({}, activationState);
            if (activationState.isProgrammatic) {
                requestAnimationFrame(function () { return _this.animateDeactivation_(state); });
                this.resetActivationState_();
            }
            else {
                this.deregisterDeactivationHandlers_();
                requestAnimationFrame(function () {
                    _this.activationState_.hasDeactivationUXRun = true;
                    _this.animateDeactivation_(state);
                    _this.resetActivationState_();
                });
            }
        };
        MDCRippleFoundation.prototype.animateDeactivation_ = function (_a) {
            var wasActivatedByPointer = _a.wasActivatedByPointer, wasElementMadeActive = _a.wasElementMadeActive;
            if (wasActivatedByPointer || wasElementMadeActive) {
                this.runDeactivationUXLogicIfReady_();
            }
        };
        MDCRippleFoundation.prototype.layoutInternal_ = function () {
            var _this = this;
            this.frame_ = this.adapter_.computeBoundingRect();
            var maxDim = Math.max(this.frame_.height, this.frame_.width);
            // Surface diameter is treated differently for unbounded vs. bounded ripples.
            // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
            // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
            // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
            // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
            // `overflow: hidden`.
            var getBoundedRadius = function () {
                var hypotenuse = Math.sqrt(Math.pow(_this.frame_.width, 2) + Math.pow(_this.frame_.height, 2));
                return hypotenuse + MDCRippleFoundation.numbers.PADDING;
            };
            this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();
            // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
            this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
            this.fgScale_ = "" + this.maxRadius_ / this.initialSize_;
            this.updateLayoutCssVars_();
        };
        MDCRippleFoundation.prototype.updateLayoutCssVars_ = function () {
            var _a = MDCRippleFoundation.strings, VAR_FG_SIZE = _a.VAR_FG_SIZE, VAR_LEFT = _a.VAR_LEFT, VAR_TOP = _a.VAR_TOP, VAR_FG_SCALE = _a.VAR_FG_SCALE;
            this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + "px");
            this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);
            if (this.adapter_.isUnbounded()) {
                this.unboundedCoords_ = {
                    left: Math.round((this.frame_.width / 2) - (this.initialSize_ / 2)),
                    top: Math.round((this.frame_.height / 2) - (this.initialSize_ / 2)),
                };
                this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + "px");
                this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + "px");
            }
        };
        return MDCRippleFoundation;
    }(MDCFoundation));
    //# sourceMappingURL=foundation.js.map

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCRipple = /** @class */ (function (_super) {
        __extends(MDCRipple, _super);
        function MDCRipple() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.disabled = false;
            return _this;
        }
        MDCRipple.attachTo = function (root, opts) {
            if (opts === void 0) { opts = { isUnbounded: undefined }; }
            var ripple = new MDCRipple(root);
            // Only override unbounded behavior if option is explicitly specified
            if (opts.isUnbounded !== undefined) {
                ripple.unbounded = opts.isUnbounded;
            }
            return ripple;
        };
        MDCRipple.createAdapter = function (instance) {
            return {
                addClass: function (className) { return instance.root_.classList.add(className); },
                browserSupportsCssVars: function () { return supportsCssVariables(window); },
                computeBoundingRect: function () { return instance.root_.getBoundingClientRect(); },
                containsEventTarget: function (target) { return instance.root_.contains(target); },
                deregisterDocumentInteractionHandler: function (evtType, handler) {
                    return document.documentElement.removeEventListener(evtType, handler, applyPassive());
                },
                deregisterInteractionHandler: function (evtType, handler) {
                    return instance.root_.removeEventListener(evtType, handler, applyPassive());
                },
                deregisterResizeHandler: function (handler) { return window.removeEventListener('resize', handler); },
                getWindowPageOffset: function () { return ({ x: window.pageXOffset, y: window.pageYOffset }); },
                isSurfaceActive: function () { return matches$1(instance.root_, ':active'); },
                isSurfaceDisabled: function () { return Boolean(instance.disabled); },
                isUnbounded: function () { return Boolean(instance.unbounded); },
                registerDocumentInteractionHandler: function (evtType, handler) {
                    return document.documentElement.addEventListener(evtType, handler, applyPassive());
                },
                registerInteractionHandler: function (evtType, handler) {
                    return instance.root_.addEventListener(evtType, handler, applyPassive());
                },
                registerResizeHandler: function (handler) { return window.addEventListener('resize', handler); },
                removeClass: function (className) { return instance.root_.classList.remove(className); },
                updateCssVariable: function (varName, value) { return instance.root_.style.setProperty(varName, value); },
            };
        };
        Object.defineProperty(MDCRipple.prototype, "unbounded", {
            get: function () {
                return Boolean(this.unbounded_);
            },
            set: function (unbounded) {
                this.unbounded_ = Boolean(unbounded);
                this.setUnbounded_();
            },
            enumerable: true,
            configurable: true
        });
        MDCRipple.prototype.activate = function () {
            this.foundation_.activate();
        };
        MDCRipple.prototype.deactivate = function () {
            this.foundation_.deactivate();
        };
        MDCRipple.prototype.layout = function () {
            this.foundation_.layout();
        };
        MDCRipple.prototype.getDefaultFoundation = function () {
            return new MDCRippleFoundation(MDCRipple.createAdapter(this));
        };
        MDCRipple.prototype.initialSyncWithDOM = function () {
            var root = this.root_;
            this.unbounded = 'mdcRippleIsUnbounded' in root.dataset;
        };
        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         */
        MDCRipple.prototype.setUnbounded_ = function () {
            this.foundation_.setUnbounded(Boolean(this.unbounded_));
        };
        return MDCRipple;
    }(MDCComponent));
    //# sourceMappingURL=component.js.map

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$2 = {
        CLOSING: 'mdc-dialog--closing',
        OPEN: 'mdc-dialog--open',
        OPENING: 'mdc-dialog--opening',
        SCROLLABLE: 'mdc-dialog--scrollable',
        SCROLL_LOCK: 'mdc-dialog-scroll-lock',
        STACKED: 'mdc-dialog--stacked',
    };
    var strings$2 = {
        ACTION_ATTRIBUTE: 'data-mdc-dialog-action',
        BUTTON_DEFAULT_ATTRIBUTE: 'data-mdc-dialog-button-default',
        BUTTON_SELECTOR: '.mdc-dialog__button',
        CLOSED_EVENT: 'MDCDialog:closed',
        CLOSE_ACTION: 'close',
        CLOSING_EVENT: 'MDCDialog:closing',
        CONTAINER_SELECTOR: '.mdc-dialog__container',
        CONTENT_SELECTOR: '.mdc-dialog__content',
        DESTROY_ACTION: 'destroy',
        INITIAL_FOCUS_ATTRIBUTE: 'data-mdc-dialog-initial-focus',
        OPENED_EVENT: 'MDCDialog:opened',
        OPENING_EVENT: 'MDCDialog:opening',
        SCRIM_SELECTOR: '.mdc-dialog__scrim',
        SUPPRESS_DEFAULT_PRESS_SELECTOR: [
            'textarea',
            '.mdc-menu .mdc-list-item',
        ].join(', '),
        SURFACE_SELECTOR: '.mdc-dialog__surface',
    };
    var numbers$2 = {
        DIALOG_ANIMATION_CLOSE_TIME_MS: 75,
        DIALOG_ANIMATION_OPEN_TIME_MS: 150,
    };
    //# sourceMappingURL=constants.js.map

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCDialogFoundation = /** @class */ (function (_super) {
        __extends(MDCDialogFoundation, _super);
        function MDCDialogFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCDialogFoundation.defaultAdapter, adapter)) || this;
            _this.isOpen_ = false;
            _this.animationFrame_ = 0;
            _this.animationTimer_ = 0;
            _this.layoutFrame_ = 0;
            _this.escapeKeyAction_ = strings$2.CLOSE_ACTION;
            _this.scrimClickAction_ = strings$2.CLOSE_ACTION;
            _this.autoStackButtons_ = true;
            _this.areButtonsStacked_ = false;
            return _this;
        }
        Object.defineProperty(MDCDialogFoundation, "cssClasses", {
            get: function () {
                return cssClasses$2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCDialogFoundation, "strings", {
            get: function () {
                return strings$2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCDialogFoundation, "numbers", {
            get: function () {
                return numbers$2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCDialogFoundation, "defaultAdapter", {
            get: function () {
                return {
                    addBodyClass: function () { return undefined; },
                    addClass: function () { return undefined; },
                    areButtonsStacked: function () { return false; },
                    clickDefaultButton: function () { return undefined; },
                    eventTargetMatches: function () { return false; },
                    getActionFromEvent: function () { return ''; },
                    getInitialFocusEl: function () { return null; },
                    hasClass: function () { return false; },
                    isContentScrollable: function () { return false; },
                    notifyClosed: function () { return undefined; },
                    notifyClosing: function () { return undefined; },
                    notifyOpened: function () { return undefined; },
                    notifyOpening: function () { return undefined; },
                    releaseFocus: function () { return undefined; },
                    removeBodyClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    reverseButtons: function () { return undefined; },
                    trapFocus: function () { return undefined; },
                };
            },
            enumerable: true,
            configurable: true
        });
        MDCDialogFoundation.prototype.init = function () {
            if (this.adapter_.hasClass(cssClasses$2.STACKED)) {
                this.setAutoStackButtons(false);
            }
        };
        MDCDialogFoundation.prototype.destroy = function () {
            if (this.isOpen_) {
                this.close(strings$2.DESTROY_ACTION);
            }
            if (this.animationTimer_) {
                clearTimeout(this.animationTimer_);
                this.handleAnimationTimerEnd_();
            }
            if (this.layoutFrame_) {
                cancelAnimationFrame(this.layoutFrame_);
                this.layoutFrame_ = 0;
            }
        };
        MDCDialogFoundation.prototype.open = function () {
            var _this = this;
            this.isOpen_ = true;
            this.adapter_.notifyOpening();
            this.adapter_.addClass(cssClasses$2.OPENING);
            // Wait a frame once display is no longer "none", to establish basis for animation
            this.runNextAnimationFrame_(function () {
                _this.adapter_.addClass(cssClasses$2.OPEN);
                _this.adapter_.addBodyClass(cssClasses$2.SCROLL_LOCK);
                _this.layout();
                _this.animationTimer_ = setTimeout(function () {
                    _this.handleAnimationTimerEnd_();
                    _this.adapter_.trapFocus(_this.adapter_.getInitialFocusEl());
                    _this.adapter_.notifyOpened();
                }, numbers$2.DIALOG_ANIMATION_OPEN_TIME_MS);
            });
        };
        MDCDialogFoundation.prototype.close = function (action) {
            var _this = this;
            if (action === void 0) { action = ''; }
            if (!this.isOpen_) {
                // Avoid redundant close calls (and events), e.g. from keydown on elements that inherently emit click
                return;
            }
            this.isOpen_ = false;
            this.adapter_.notifyClosing(action);
            this.adapter_.addClass(cssClasses$2.CLOSING);
            this.adapter_.removeClass(cssClasses$2.OPEN);
            this.adapter_.removeBodyClass(cssClasses$2.SCROLL_LOCK);
            cancelAnimationFrame(this.animationFrame_);
            this.animationFrame_ = 0;
            clearTimeout(this.animationTimer_);
            this.animationTimer_ = setTimeout(function () {
                _this.adapter_.releaseFocus();
                _this.handleAnimationTimerEnd_();
                _this.adapter_.notifyClosed(action);
            }, numbers$2.DIALOG_ANIMATION_CLOSE_TIME_MS);
        };
        MDCDialogFoundation.prototype.isOpen = function () {
            return this.isOpen_;
        };
        MDCDialogFoundation.prototype.getEscapeKeyAction = function () {
            return this.escapeKeyAction_;
        };
        MDCDialogFoundation.prototype.setEscapeKeyAction = function (action) {
            this.escapeKeyAction_ = action;
        };
        MDCDialogFoundation.prototype.getScrimClickAction = function () {
            return this.scrimClickAction_;
        };
        MDCDialogFoundation.prototype.setScrimClickAction = function (action) {
            this.scrimClickAction_ = action;
        };
        MDCDialogFoundation.prototype.getAutoStackButtons = function () {
            return this.autoStackButtons_;
        };
        MDCDialogFoundation.prototype.setAutoStackButtons = function (autoStack) {
            this.autoStackButtons_ = autoStack;
        };
        MDCDialogFoundation.prototype.layout = function () {
            var _this = this;
            if (this.layoutFrame_) {
                cancelAnimationFrame(this.layoutFrame_);
            }
            this.layoutFrame_ = requestAnimationFrame(function () {
                _this.layoutInternal_();
                _this.layoutFrame_ = 0;
            });
        };
        /** Handles click on the dialog root element. */
        MDCDialogFoundation.prototype.handleClick = function (evt) {
            var isScrim = this.adapter_.eventTargetMatches(evt.target, strings$2.SCRIM_SELECTOR);
            // Check for scrim click first since it doesn't require querying ancestors.
            if (isScrim && this.scrimClickAction_ !== '') {
                this.close(this.scrimClickAction_);
            }
            else {
                var action = this.adapter_.getActionFromEvent(evt);
                if (action) {
                    this.close(action);
                }
            }
        };
        /** Handles keydown on the dialog root element. */
        MDCDialogFoundation.prototype.handleKeydown = function (evt) {
            var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
            if (!isEnter) {
                return;
            }
            var action = this.adapter_.getActionFromEvent(evt);
            if (action) {
                // Action button callback is handled in `handleClick`,
                // since space/enter keydowns on buttons trigger click events.
                return;
            }
            var isDefault = !this.adapter_.eventTargetMatches(evt.target, strings$2.SUPPRESS_DEFAULT_PRESS_SELECTOR);
            if (isEnter && isDefault) {
                this.adapter_.clickDefaultButton();
            }
        };
        /** Handles keydown on the document. */
        MDCDialogFoundation.prototype.handleDocumentKeydown = function (evt) {
            var isEscape = evt.key === 'Escape' || evt.keyCode === 27;
            if (isEscape && this.escapeKeyAction_ !== '') {
                this.close(this.escapeKeyAction_);
            }
        };
        MDCDialogFoundation.prototype.layoutInternal_ = function () {
            if (this.autoStackButtons_) {
                this.detectStackedButtons_();
            }
            this.detectScrollableContent_();
        };
        MDCDialogFoundation.prototype.handleAnimationTimerEnd_ = function () {
            this.animationTimer_ = 0;
            this.adapter_.removeClass(cssClasses$2.OPENING);
            this.adapter_.removeClass(cssClasses$2.CLOSING);
        };
        /**
         * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
         */
        MDCDialogFoundation.prototype.runNextAnimationFrame_ = function (callback) {
            var _this = this;
            cancelAnimationFrame(this.animationFrame_);
            this.animationFrame_ = requestAnimationFrame(function () {
                _this.animationFrame_ = 0;
                clearTimeout(_this.animationTimer_);
                _this.animationTimer_ = setTimeout(callback, 0);
            });
        };
        MDCDialogFoundation.prototype.detectStackedButtons_ = function () {
            // Remove the class first to let us measure the buttons' natural positions.
            this.adapter_.removeClass(cssClasses$2.STACKED);
            var areButtonsStacked = this.adapter_.areButtonsStacked();
            if (areButtonsStacked) {
                this.adapter_.addClass(cssClasses$2.STACKED);
            }
            if (areButtonsStacked !== this.areButtonsStacked_) {
                this.adapter_.reverseButtons();
                this.areButtonsStacked_ = areButtonsStacked;
            }
        };
        MDCDialogFoundation.prototype.detectScrollableContent_ = function () {
            // Remove the class first to let us measure the natural height of the content.
            this.adapter_.removeClass(cssClasses$2.SCROLLABLE);
            if (this.adapter_.isContentScrollable()) {
                this.adapter_.addClass(cssClasses$2.SCROLLABLE);
            }
        };
        return MDCDialogFoundation;
    }(MDCFoundation));
    //# sourceMappingURL=foundation.js.map

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings$3 = MDCDialogFoundation.strings;
    var MDCDialog = /** @class */ (function (_super) {
        __extends(MDCDialog, _super);
        function MDCDialog() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(MDCDialog.prototype, "isOpen", {
            get: function () {
                return this.foundation_.isOpen();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCDialog.prototype, "escapeKeyAction", {
            get: function () {
                return this.foundation_.getEscapeKeyAction();
            },
            set: function (action) {
                this.foundation_.setEscapeKeyAction(action);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCDialog.prototype, "scrimClickAction", {
            get: function () {
                return this.foundation_.getScrimClickAction();
            },
            set: function (action) {
                this.foundation_.setScrimClickAction(action);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCDialog.prototype, "autoStackButtons", {
            get: function () {
                return this.foundation_.getAutoStackButtons();
            },
            set: function (autoStack) {
                this.foundation_.setAutoStackButtons(autoStack);
            },
            enumerable: true,
            configurable: true
        });
        MDCDialog.attachTo = function (root) {
            return new MDCDialog(root);
        };
        MDCDialog.prototype.initialize = function (focusTrapFactory) {
            var e_1, _a;
            var container = this.root_.querySelector(strings$3.CONTAINER_SELECTOR);
            if (!container) {
                throw new Error("Dialog component requires a " + strings$3.CONTAINER_SELECTOR + " container element");
            }
            this.container_ = container;
            this.content_ = this.root_.querySelector(strings$3.CONTENT_SELECTOR);
            this.buttons_ = [].slice.call(this.root_.querySelectorAll(strings$3.BUTTON_SELECTOR));
            this.defaultButton_ = this.root_.querySelector("[" + strings$3.BUTTON_DEFAULT_ATTRIBUTE + "]");
            this.focusTrapFactory_ = focusTrapFactory;
            this.buttonRipples_ = [];
            try {
                for (var _b = __values(this.buttons_), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var buttonEl = _c.value;
                    this.buttonRipples_.push(new MDCRipple(buttonEl));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        MDCDialog.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.focusTrap_ = createFocusTrapInstance(this.container_, this.focusTrapFactory_, this.getInitialFocusEl_() || undefined);
            this.handleClick_ = this.foundation_.handleClick.bind(this.foundation_);
            this.handleKeydown_ = this.foundation_.handleKeydown.bind(this.foundation_);
            this.handleDocumentKeydown_ = this.foundation_.handleDocumentKeydown.bind(this.foundation_);
            this.handleLayout_ = this.layout.bind(this);
            var LAYOUT_EVENTS = ['resize', 'orientationchange'];
            this.handleOpening_ = function () {
                LAYOUT_EVENTS.forEach(function (evtType) { return window.addEventListener(evtType, _this.handleLayout_); });
                document.addEventListener('keydown', _this.handleDocumentKeydown_);
            };
            this.handleClosing_ = function () {
                LAYOUT_EVENTS.forEach(function (evtType) { return window.removeEventListener(evtType, _this.handleLayout_); });
                document.removeEventListener('keydown', _this.handleDocumentKeydown_);
            };
            this.listen('click', this.handleClick_);
            this.listen('keydown', this.handleKeydown_);
            this.listen(strings$3.OPENING_EVENT, this.handleOpening_);
            this.listen(strings$3.CLOSING_EVENT, this.handleClosing_);
        };
        MDCDialog.prototype.destroy = function () {
            this.unlisten('click', this.handleClick_);
            this.unlisten('keydown', this.handleKeydown_);
            this.unlisten(strings$3.OPENING_EVENT, this.handleOpening_);
            this.unlisten(strings$3.CLOSING_EVENT, this.handleClosing_);
            this.handleClosing_();
            this.buttonRipples_.forEach(function (ripple) { return ripple.destroy(); });
            _super.prototype.destroy.call(this);
        };
        MDCDialog.prototype.layout = function () {
            this.foundation_.layout();
        };
        MDCDialog.prototype.open = function () {
            this.foundation_.open();
        };
        MDCDialog.prototype.close = function (action) {
            if (action === void 0) { action = ''; }
            this.foundation_.close(action);
        };
        MDCDialog.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            var adapter = {
                addBodyClass: function (className) { return document.body.classList.add(className); },
                addClass: function (className) { return _this.root_.classList.add(className); },
                areButtonsStacked: function () { return areTopsMisaligned(_this.buttons_); },
                clickDefaultButton: function () { return _this.defaultButton_ && _this.defaultButton_.click(); },
                eventTargetMatches: function (target, selector) { return target ? matches$1(target, selector) : false; },
                getActionFromEvent: function (evt) {
                    if (!evt.target) {
                        return '';
                    }
                    var element = closest(evt.target, "[" + strings$3.ACTION_ATTRIBUTE + "]");
                    return element && element.getAttribute(strings$3.ACTION_ATTRIBUTE);
                },
                getInitialFocusEl: function () { return _this.getInitialFocusEl_(); },
                hasClass: function (className) { return _this.root_.classList.contains(className); },
                isContentScrollable: function () { return isScrollable(_this.content_); },
                notifyClosed: function (action) { return _this.emit(strings$3.CLOSED_EVENT, action ? { action: action } : {}); },
                notifyClosing: function (action) { return _this.emit(strings$3.CLOSING_EVENT, action ? { action: action } : {}); },
                notifyOpened: function () { return _this.emit(strings$3.OPENED_EVENT, {}); },
                notifyOpening: function () { return _this.emit(strings$3.OPENING_EVENT, {}); },
                releaseFocus: function () { return _this.focusTrap_.deactivate(); },
                removeBodyClass: function (className) { return document.body.classList.remove(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                reverseButtons: function () {
                    _this.buttons_.reverse();
                    _this.buttons_.forEach(function (button) {
                        button.parentElement.appendChild(button);
                    });
                },
                trapFocus: function () { return _this.focusTrap_.activate(); },
            };
            return new MDCDialogFoundation(adapter);
        };
        MDCDialog.prototype.getInitialFocusEl_ = function () {
            return document.querySelector("[" + strings$3.INITIAL_FOCUS_ATTRIBUTE + "]");
        };
        return MDCDialog;
    }(MDCComponent));
    //# sourceMappingURL=component.js.map

    /* node_modules\@smui\dialog\Dialog.svelte generated by Svelte v3.18.1 */
    const file$2 = "node_modules\\@smui\\dialog\\Dialog.svelte";

    function create_fragment$2(ctx) {
    	let div3;
    	let div1;
    	let div0;
    	let t;
    	let div2;
    	let useActions_action;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[19].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

    	let div3_levels = [
    		{
    			class: "mdc-dialog " + /*className*/ ctx[1]
    		},
    		{ role: "alertdialog" },
    		{ "aria-modal": "true" },
    		exclude(/*$$props*/ ctx[5], ["use", "class"])
    	];

    	let div3_data = {};

    	for (let i = 0; i < div3_levels.length; i += 1) {
    		div3_data = assign(div3_data, div3_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			t = space();
    			div2 = element("div");
    			attr_dev(div0, "class", "mdc-dialog__surface");
    			add_location(div0, file$2, 11, 4, 273);
    			attr_dev(div1, "class", "mdc-dialog__container");
    			add_location(div1, file$2, 10, 2, 233);
    			attr_dev(div2, "class", "mdc-dialog__scrim");
    			add_location(div2, file$2, 15, 2, 349);
    			set_attributes(div3, div3_data);
    			add_location(div3, file$2, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			append_dev(div3, t);
    			append_dev(div3, div2);
    			/*div3_binding*/ ctx[20](div3);
    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, div3, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[3].call(null, div3)),
    				listen_dev(div3, "MDCDialog:opened", /*handleDialogOpened*/ ctx[4], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 262144) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[18], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null));
    			}

    			set_attributes(div3, get_spread_update(div3_levels, [
    				dirty & /*className*/ 2 && {
    					class: "mdc-dialog " + /*className*/ ctx[1]
    				},
    				{ role: "alertdialog" },
    				{ "aria-modal": "true" },
    				dirty & /*exclude, $$props*/ 32 && exclude(/*$$props*/ ctx[5], ["use", "class"])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (default_slot) default_slot.d(detaching);
    			/*div3_binding*/ ctx[20](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component, [
    		"MDCDialog:opening",
    		"MDCDialog:opened",
    		"MDCDialog:closing",
    		"MDCDialog:closed"
    	]);

    	let { use = [] } = $$props;
    	let { class: className = "" } = $$props;
    	let { escapeKeyAction = "close" } = $$props;
    	let { scrimClickAction = "close" } = $$props;
    	let { autoStackButtons = true } = $$props;
    	let element;
    	let dialog;
    	let addLayoutListener = getContext("SMUI:addLayoutListener");
    	let removeLayoutListener;
    	let layoutListeners = [];

    	let addLayoutListenerFn = listener => {
    		layoutListeners.push(listener);

    		return () => {
    			const idx = layoutListeners.indexOf(listener);

    			if (idx >= 0) {
    				layoutListeners.splice(idx, 1);
    			}
    		};
    	};

    	setContext("SMUI:addLayoutListener", addLayoutListenerFn);

    	if (addLayoutListener) {
    		removeLayoutListener = addLayoutListener(layout);
    	}

    	onMount(() => {
    		$$invalidate(13, dialog = new MDCDialog(element));
    	});

    	onDestroy(() => {
    		dialog && dialog.destroy();

    		if (removeLayoutListener) {
    			removeLayoutListener();
    		}
    	});

    	function handleDialogOpened() {
    		layoutListeners.forEach(listener => listener());
    	}

    	function open(...args) {
    		return dialog.open(...args);
    	}

    	function close(...args) {
    		return dialog.close(...args);
    	}

    	function isOpen() {
    		return dialog.isOpen;
    	}

    	function layout(...args) {
    		return dialog.layout(...args);
    	}

    	let { $$slots = {}, $$scope } = $$props;

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(2, element = $$value);
    		});
    	}

    	$$self.$set = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ("escapeKeyAction" in $$new_props) $$invalidate(6, escapeKeyAction = $$new_props.escapeKeyAction);
    		if ("scrimClickAction" in $$new_props) $$invalidate(7, scrimClickAction = $$new_props.scrimClickAction);
    		if ("autoStackButtons" in $$new_props) $$invalidate(8, autoStackButtons = $$new_props.autoStackButtons);
    		if ("$$scope" in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			use,
    			className,
    			escapeKeyAction,
    			scrimClickAction,
    			autoStackButtons,
    			element,
    			dialog,
    			addLayoutListener,
    			removeLayoutListener,
    			layoutListeners,
    			addLayoutListenerFn
    		};
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
    		if ("escapeKeyAction" in $$props) $$invalidate(6, escapeKeyAction = $$new_props.escapeKeyAction);
    		if ("scrimClickAction" in $$props) $$invalidate(7, scrimClickAction = $$new_props.scrimClickAction);
    		if ("autoStackButtons" in $$props) $$invalidate(8, autoStackButtons = $$new_props.autoStackButtons);
    		if ("element" in $$props) $$invalidate(2, element = $$new_props.element);
    		if ("dialog" in $$props) $$invalidate(13, dialog = $$new_props.dialog);
    		if ("addLayoutListener" in $$props) addLayoutListener = $$new_props.addLayoutListener;
    		if ("removeLayoutListener" in $$props) removeLayoutListener = $$new_props.removeLayoutListener;
    		if ("layoutListeners" in $$props) layoutListeners = $$new_props.layoutListeners;
    		if ("addLayoutListenerFn" in $$props) addLayoutListenerFn = $$new_props.addLayoutListenerFn;
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*dialog, escapeKeyAction*/ 8256) {
    			 dialog && $$invalidate(13, dialog.escapeKeyAction = escapeKeyAction, dialog);
    		}

    		if ($$self.$$.dirty & /*dialog, scrimClickAction*/ 8320) {
    			 dialog && $$invalidate(13, dialog.scrimClickAction = scrimClickAction, dialog);
    		}

    		if ($$self.$$.dirty & /*dialog, autoStackButtons*/ 8448) {
    			 dialog && $$invalidate(13, dialog.autoStackButtons = autoStackButtons, dialog);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		element,
    		forwardEvents,
    		handleDialogOpened,
    		$$props,
    		escapeKeyAction,
    		scrimClickAction,
    		autoStackButtons,
    		open,
    		close,
    		isOpen,
    		layout,
    		dialog,
    		removeLayoutListener,
    		addLayoutListener,
    		layoutListeners,
    		addLayoutListenerFn,
    		$$scope,
    		$$slots,
    		div3_binding
    	];
    }

    class Dialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
    			use: 0,
    			class: 1,
    			escapeKeyAction: 6,
    			scrimClickAction: 7,
    			autoStackButtons: 8,
    			open: 9,
    			close: 10,
    			isOpen: 11,
    			layout: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dialog",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get use() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get escapeKeyAction() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set escapeKeyAction(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrimClickAction() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrimClickAction(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autoStackButtons() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autoStackButtons(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get open() {
    		return this.$$.ctx[9];
    	}

    	set open(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get close() {
    		return this.$$.ctx[10];
    	}

    	set close(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isOpen() {
    		return this.$$.ctx[11];
    	}

    	set isOpen(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layout() {
    		return this.$$.ctx[12];
    	}

    	set layout(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\common\ClassAdder.svelte generated by Svelte v3.18.1 */

    // (1:0) <svelte:component   this={component}   use={[forwardEvents, ...use]}   class="{smuiClass} {className}"   {...exclude($$props, ['use', 'class', 'component', 'forwardEvents'])} >
    function create_default_slot(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 512) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[9], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(1:0) <svelte:component   this={component}   use={[forwardEvents, ...use]}   class=\\\"{smuiClass} {className}\\\"   {...exclude($$props, ['use', 'class', 'component', 'forwardEvents'])} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{
    			use: [/*forwardEvents*/ ctx[4], .../*use*/ ctx[0]]
    		},
    		{
    			class: "" + (/*smuiClass*/ ctx[3] + " " + /*className*/ ctx[1])
    		},
    		exclude(/*$$props*/ ctx[5], ["use", "class", "component", "forwardEvents"])
    	];

    	var switch_value = /*component*/ ctx[2];

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			$$slots: { default: [create_default_slot] },
    			$$scope: { ctx }
    		};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = (dirty & /*forwardEvents, use, smuiClass, className, exclude, $$props*/ 59)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*forwardEvents, use*/ 17 && {
    						use: [/*forwardEvents*/ ctx[4], .../*use*/ ctx[0]]
    					},
    					dirty & /*smuiClass, className*/ 10 && {
    						class: "" + (/*smuiClass*/ ctx[3] + " " + /*className*/ ctx[1])
    					},
    					dirty & /*exclude, $$props*/ 32 && get_spread_object(exclude(/*$$props*/ ctx[5], ["use", "class", "component", "forwardEvents"]))
    				])
    			: {};

    			if (dirty & /*$$scope*/ 512) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*component*/ ctx[2])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const internals = {
    	component: null,
    	smuiClass: null,
    	contexts: {}
    };

    function instance$3($$self, $$props, $$invalidate) {
    	let { use = [] } = $$props;
    	let { class: className = "" } = $$props;
    	let { component = internals.component } = $$props;
    	let { forwardEvents: smuiForwardEvents = [] } = $$props;
    	const smuiClass = internals.class;
    	const contexts = internals.contexts;
    	const forwardEvents = forwardEventsBuilder(current_component, smuiForwardEvents);

    	for (let context in contexts) {
    		if (contexts.hasOwnProperty(context)) {
    			setContext(context, contexts[context]);
    		}
    	}

    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ("component" in $$new_props) $$invalidate(2, component = $$new_props.component);
    		if ("forwardEvents" in $$new_props) $$invalidate(6, smuiForwardEvents = $$new_props.forwardEvents);
    		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			use,
    			className,
    			component,
    			smuiForwardEvents
    		};
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
    		if ("component" in $$props) $$invalidate(2, component = $$new_props.component);
    		if ("smuiForwardEvents" in $$props) $$invalidate(6, smuiForwardEvents = $$new_props.smuiForwardEvents);
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		component,
    		smuiClass,
    		forwardEvents,
    		$$props,
    		smuiForwardEvents,
    		contexts,
    		$$slots,
    		$$scope
    	];
    }

    class ClassAdder extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
    			use: 0,
    			class: 1,
    			component: 2,
    			forwardEvents: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ClassAdder",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get use() {
    		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get forwardEvents() {
    		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set forwardEvents(value) {
    		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function classAdderBuilder(props) {
      function Component(...args) {
        Object.assign(internals, props);
        return new ClassAdder(...args);
      }

      Component.prototype = ClassAdder;

      // SSR support
      if (ClassAdder.$$render) {
        Component.$$render = (...args) => Object.assign(internals, props) && ClassAdder.$$render(...args);
      }
      if (ClassAdder.render) {
        Component.render = (...args) => Object.assign(internals, props) && ClassAdder.render(...args);
      }

      return Component;
    }

    /* node_modules\@smui\common\H2.svelte generated by Svelte v3.18.1 */
    const file$3 = "node_modules\\@smui\\common\\H2.svelte";

    function create_fragment$4(ctx) {
    	let h2;
    	let useActions_action;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let h2_levels = [exclude(/*$$props*/ ctx[2], ["use"])];
    	let h2_data = {};

    	for (let i = 0; i < h2_levels.length; i += 1) {
    		h2_data = assign(h2_data, h2_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			if (default_slot) default_slot.c();
    			set_attributes(h2, h2_data);
    			add_location(h2, file$3, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);

    			if (default_slot) {
    				default_slot.m(h2, null);
    			}

    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, h2, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[1].call(null, h2))
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 8) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[3], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null));
    			}

    			set_attributes(h2, get_spread_update(h2_levels, [dirty & /*exclude, $$props*/ 4 && exclude(/*$$props*/ ctx[2], ["use"])]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (default_slot) default_slot.d(detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { use = [] } = $$props;
    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return { use };
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    	};

    	$$props = exclude_internal_props($$props);
    	return [use, forwardEvents, $$props, $$scope, $$slots];
    }

    class H2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { use: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "H2",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get use() {
    		throw new Error("<H2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<H2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Title = classAdderBuilder({
      class: 'mdc-dialog__title',
      component: H2,
      contexts: {}
    });

    /* node_modules\@smui\common\Div.svelte generated by Svelte v3.18.1 */
    const file$4 = "node_modules\\@smui\\common\\Div.svelte";

    function create_fragment$5(ctx) {
    	let div;
    	let useActions_action;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let div_levels = [exclude(/*$$props*/ ctx[2], ["use"])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$4, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[1].call(null, div))
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 8) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[3], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null));
    			}

    			set_attributes(div, get_spread_update(div_levels, [dirty & /*exclude, $$props*/ 4 && exclude(/*$$props*/ ctx[2], ["use"])]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { use = [] } = $$props;
    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return { use };
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    	};

    	$$props = exclude_internal_props($$props);
    	return [use, forwardEvents, $$props, $$scope, $$slots];
    }

    class Div extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { use: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Div",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get use() {
    		throw new Error("<Div>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Div>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Content = classAdderBuilder({
      class: 'mdc-dialog__content',
      component: Div,
      contexts: {}
    });

    /* node_modules\@smui\common\Footer.svelte generated by Svelte v3.18.1 */
    const file$5 = "node_modules\\@smui\\common\\Footer.svelte";

    function create_fragment$6(ctx) {
    	let footer;
    	let useActions_action;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let footer_levels = [exclude(/*$$props*/ ctx[2], ["use"])];
    	let footer_data = {};

    	for (let i = 0; i < footer_levels.length; i += 1) {
    		footer_data = assign(footer_data, footer_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			footer = element("footer");
    			if (default_slot) default_slot.c();
    			set_attributes(footer, footer_data);
    			add_location(footer, file$5, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, footer, anchor);

    			if (default_slot) {
    				default_slot.m(footer, null);
    			}

    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, footer, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[1].call(null, footer))
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 8) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[3], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null));
    			}

    			set_attributes(footer, get_spread_update(footer_levels, [dirty & /*exclude, $$props*/ 4 && exclude(/*$$props*/ ctx[2], ["use"])]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(footer);
    			if (default_slot) default_slot.d(detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { use = [] } = $$props;
    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return { use };
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    	};

    	$$props = exclude_internal_props($$props);
    	return [use, forwardEvents, $$props, $$scope, $$slots];
    }

    class Footer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, { use: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Footer",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get use() {
    		throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Actions = classAdderBuilder({
      class: 'mdc-dialog__actions',
      component: Footer,
      contexts: {
        'SMUI:button:context': 'dialog:action'
      }
    });

    var css$2 = ".mdc-button{padding:0;min-width:24px}.mdc-button:after,.mdc-button:before{background:none}.mdc-menu{max-width:450px}.mdc-menu-surface{top:50px!important}.mdc-tab-bar{position:static}.mdc-list{height:300px;overflow:hidden;overflow-y:scroll;scroll-behavior:smooth;scrollbar-width:5px}::-webkit-scrollbar{width:5px}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px rgba(0,0,0,.3);-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);-webkit-border-radius:5px;border-radius:5px}::-webkit-scrollbar-thumb{-webkit-border-radius:5px;border-radius:5px;background:rgba(196,183,183,.8);-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.5);box-shadow:inset 0 0 6px rgba(0,0,0,.5)}::-webkit-scrollbar-thumb:window-inactive{background:rgba(138,129,129,.4)}.mdc-button{font-family:Roboto,sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:.875rem;line-height:2.25rem;font-weight:500;letter-spacing:.08929em;text-decoration:none;text-transform:uppercase;padding:0 8px;display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;height:36px;border:none;outline:none;line-height:inherit;user-select:none;-webkit-appearance:none;overflow:hidden;vertical-align:middle;border-radius:4px}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{background-color:transparent;color:rgba(0,0,0,.37);cursor:default;pointer-events:none}.mdc-button.mdc-button--dense{border-radius:4px}.mdc-button:not(:disabled){background-color:transparent}.mdc-button .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;width:18px;height:18px;font-size:18px;vertical-align:top}.mdc-button .mdc-button__icon[dir=rtl],[dir=rtl] .mdc-button .mdc-button__icon{margin-left:8px;margin-right:0}.mdc-button:not(:disabled){color:#6200ee;color:var(--mdc-theme-primary,#6200ee)}.mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:0}.mdc-button__label+.mdc-button__icon[dir=rtl],[dir=rtl] .mdc-button__label+.mdc-button__icon{margin-left:0;margin-right:8px}svg.mdc-button__icon{fill:currentColor}.mdc-button--outlined .mdc-button__icon,.mdc-button--raised .mdc-button__icon,.mdc-button--unelevated .mdc-button__icon{margin-left:-4px;margin-right:8px}.mdc-button--outlined .mdc-button__icon[dir=rtl],.mdc-button--outlined .mdc-button__label+.mdc-button__icon,.mdc-button--raised .mdc-button__icon[dir=rtl],.mdc-button--raised .mdc-button__label+.mdc-button__icon,.mdc-button--unelevated .mdc-button__icon[dir=rtl],.mdc-button--unelevated .mdc-button__label+.mdc-button__icon,[dir=rtl] .mdc-button--outlined .mdc-button__icon,[dir=rtl] .mdc-button--raised .mdc-button__icon,[dir=rtl] .mdc-button--unelevated .mdc-button__icon{margin-left:8px;margin-right:-4px}.mdc-button--outlined .mdc-button__label+.mdc-button__icon[dir=rtl],.mdc-button--raised .mdc-button__label+.mdc-button__icon[dir=rtl],.mdc-button--unelevated .mdc-button__label+.mdc-button__icon[dir=rtl],[dir=rtl] .mdc-button--outlined .mdc-button__label+.mdc-button__icon,[dir=rtl] .mdc-button--raised .mdc-button__label+.mdc-button__icon,[dir=rtl] .mdc-button--unelevated .mdc-button__label+.mdc-button__icon{margin-left:-4px;margin-right:8px}.mdc-button--raised,.mdc-button--unelevated{padding:0 16px}.mdc-button--raised:disabled,.mdc-button--unelevated:disabled{background-color:rgba(0,0,0,.12);color:rgba(0,0,0,.37)}.mdc-button--raised:not(:disabled),.mdc-button--unelevated:not(:disabled){background-color:#6200ee}@supports not (-ms-ime-align:auto){.mdc-button--raised:not(:disabled),.mdc-button--unelevated:not(:disabled){background-color:var(--mdc-theme-primary,#6200ee)}}.mdc-button--raised:not(:disabled),.mdc-button--unelevated:not(:disabled){color:#fff;color:var(--mdc-theme-on-primary,#fff)}.mdc-button--raised{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);transition:box-shadow .28s cubic-bezier(.4,0,.2,1)}.mdc-button--raised:focus,.mdc-button--raised:hover{box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)}.mdc-button--raised:active{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}.mdc-button--raised:disabled{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12)}.mdc-button--outlined{border-style:solid;padding:0 15px;border-width:1px}.mdc-button--outlined:disabled{border-color:rgba(0,0,0,.37)}.mdc-button--outlined:not(:disabled){border-color:#6200ee;border-color:var(--mdc-theme-primary,#6200ee)}.mdc-button--dense{height:32px;font-size:.8125rem}@keyframes mdc-ripple-fg-radius-in{0%{animation-timing-function:cubic-bezier(.4,0,.2,1);transform:translate(var(--mdc-ripple-fg-translate-start,0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}}@keyframes mdc-ripple-fg-opacity-in{0%{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity,0)}}@keyframes mdc-ripple-fg-opacity-out{0%{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity,0)}to{opacity:0}}.mdc-ripple-surface--test-edge-var-bug{--mdc-ripple-surface-test-edge-var:1px solid #000;visibility:hidden}.mdc-ripple-surface--test-edge-var-bug:before{border:var(--mdc-ripple-surface-test-edge-var)}.mdc-button{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mdc-button:after,.mdc-button:before{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:\"\"}.mdc-button:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1}.mdc-button.mdc-ripple-upgraded:before{transform:scale(var(--mdc-ripple-fg-scale,1))}.mdc-button.mdc-ripple-upgraded:after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-button.mdc-ripple-upgraded--unbounded:after{top:var(--mdc-ripple-top,0);left:var(--mdc-ripple-left,0)}.mdc-button.mdc-ripple-upgraded--foreground-activation:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-button.mdc-ripple-upgraded--foreground-deactivation:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}.mdc-button:after,.mdc-button:before{top:-50%;left:-50%;width:200%;height:200%}.mdc-button.mdc-ripple-upgraded:after{width:var(--mdc-ripple-fg-size,100%);height:var(--mdc-ripple-fg-size,100%)}.mdc-button:after,.mdc-button:before{background-color:#6200ee}@supports not (-ms-ime-align:auto){.mdc-button:after,.mdc-button:before{background-color:var(--mdc-theme-primary,#6200ee)}}.mdc-button:hover:before{opacity:.04}.mdc-button.mdc-ripple-upgraded--background-focused:before,.mdc-button:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.12}.mdc-button:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.mdc-button:not(.mdc-ripple-upgraded):active:after{transition-duration:75ms;opacity:.12}.mdc-button.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:0.12}.mdc-button--raised:after,.mdc-button--raised:before,.mdc-button--unelevated:after,.mdc-button--unelevated:before{background-color:#fff}@supports not (-ms-ime-align:auto){.mdc-button--raised:after,.mdc-button--raised:before,.mdc-button--unelevated:after,.mdc-button--unelevated:before{background-color:var(--mdc-theme-on-primary,#fff)}}.mdc-button--raised:hover:before,.mdc-button--unelevated:hover:before{opacity:.08}.mdc-button--raised.mdc-ripple-upgraded--background-focused:before,.mdc-button--raised:not(.mdc-ripple-upgraded):focus:before,.mdc-button--unelevated.mdc-ripple-upgraded--background-focused:before,.mdc-button--unelevated:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.24}.mdc-button--raised:not(.mdc-ripple-upgraded):after,.mdc-button--unelevated:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.mdc-button--raised:not(.mdc-ripple-upgraded):active:after,.mdc-button--unelevated:not(.mdc-ripple-upgraded):active:after{transition-duration:75ms;opacity:.24}.mdc-button--raised.mdc-ripple-upgraded,.mdc-button--unelevated.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:0.24}.mdc-ripple-surface{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);position:relative;outline:none;overflow:hidden}.mdc-ripple-surface:after,.mdc-ripple-surface:before{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:\"\"}.mdc-ripple-surface:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1}.mdc-ripple-surface.mdc-ripple-upgraded:before{transform:scale(var(--mdc-ripple-fg-scale,1))}.mdc-ripple-surface.mdc-ripple-upgraded:after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-ripple-surface.mdc-ripple-upgraded--unbounded:after{top:var(--mdc-ripple-top,0);left:var(--mdc-ripple-left,0)}.mdc-ripple-surface.mdc-ripple-upgraded--foreground-activation:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-ripple-surface.mdc-ripple-upgraded--foreground-deactivation:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}.mdc-ripple-surface:after,.mdc-ripple-surface:before{background-color:#000}.mdc-ripple-surface:hover:before{opacity:.04}.mdc-ripple-surface.mdc-ripple-upgraded--background-focused:before,.mdc-ripple-surface:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.12}.mdc-ripple-surface:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.mdc-ripple-surface:not(.mdc-ripple-upgraded):active:after{transition-duration:75ms;opacity:.12}.mdc-ripple-surface.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:0.12}.mdc-ripple-surface:after,.mdc-ripple-surface:before{top:-50%;left:-50%;width:200%;height:200%}.mdc-ripple-surface.mdc-ripple-upgraded:after{width:var(--mdc-ripple-fg-size,100%);height:var(--mdc-ripple-fg-size,100%)}.mdc-ripple-surface[data-mdc-ripple-is-unbounded]{overflow:visible}.mdc-ripple-surface[data-mdc-ripple-is-unbounded]:after,.mdc-ripple-surface[data-mdc-ripple-is-unbounded]:before{top:0;left:0;width:100%;height:100%}.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded:after,.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded:before{top:var(--mdc-ripple-top,0);left:var(--mdc-ripple-left,0);width:var(--mdc-ripple-fg-size,100%);height:var(--mdc-ripple-fg-size,100%)}.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded:after{width:var(--mdc-ripple-fg-size,100%);height:var(--mdc-ripple-fg-size,100%)}.mdc-ripple-surface--primary:after,.mdc-ripple-surface--primary:before{background-color:#6200ee}@supports not (-ms-ime-align:auto){.mdc-ripple-surface--primary:after,.mdc-ripple-surface--primary:before{background-color:var(--mdc-theme-primary,#6200ee)}}.mdc-ripple-surface--primary:hover:before{opacity:.04}.mdc-ripple-surface--primary.mdc-ripple-upgraded--background-focused:before,.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.12}.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded):active:after{transition-duration:75ms;opacity:.12}.mdc-ripple-surface--primary.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:0.12}.mdc-ripple-surface--accent:after,.mdc-ripple-surface--accent:before{background-color:#018786}@supports not (-ms-ime-align:auto){.mdc-ripple-surface--accent:after,.mdc-ripple-surface--accent:before{background-color:var(--mdc-theme-secondary,#018786)}}.mdc-ripple-surface--accent:hover:before{opacity:.04}.mdc-ripple-surface--accent.mdc-ripple-upgraded--background-focused:before,.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.12}.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded):active:after{transition-duration:75ms;opacity:.12}.mdc-ripple-surface--accent.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:0.12}.smui-button--color-secondary:not(:disabled){color:#018786;color:var(--mdc-theme-secondary,#018786)}.smui-button--color-secondary.mdc-button--raised:not(:disabled),.smui-button--color-secondary.mdc-button--unelevated:not(:disabled){background-color:#018786}@supports not (-ms-ime-align:auto){.smui-button--color-secondary.mdc-button--raised:not(:disabled),.smui-button--color-secondary.mdc-button--unelevated:not(:disabled){background-color:var(--mdc-theme-secondary,#018786)}}.smui-button--color-secondary.mdc-button--raised:not(:disabled),.smui-button--color-secondary.mdc-button--unelevated:not(:disabled){color:#fff;color:var(--mdc-theme-on-secondary,#fff)}.smui-button--color-secondary.mdc-button--outlined:not(:disabled){border-color:#018786;border-color:var(--mdc-theme-secondary,#018786)}.smui-button--color-secondary:after,.smui-button--color-secondary:before{background-color:#018786}@supports not (-ms-ime-align:auto){.smui-button--color-secondary:after,.smui-button--color-secondary:before{background-color:var(--mdc-theme-secondary,#018786)}}.smui-button--color-secondary:hover:before{opacity:.04}.smui-button--color-secondary.mdc-ripple-upgraded--background-focused:before,.smui-button--color-secondary:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.12}.smui-button--color-secondary:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.smui-button--color-secondary:not(.mdc-ripple-upgraded):active:after{transition-duration:75ms;opacity:.12}.smui-button--color-secondary.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:0.12}.smui-button--color-secondary.mdc-button--raised:after,.smui-button--color-secondary.mdc-button--raised:before,.smui-button--color-secondary.mdc-button--unelevated:after,.smui-button--color-secondary.mdc-button--unelevated:before{background-color:#fff}@supports not (-ms-ime-align:auto){.smui-button--color-secondary.mdc-button--raised:after,.smui-button--color-secondary.mdc-button--raised:before,.smui-button--color-secondary.mdc-button--unelevated:after,.smui-button--color-secondary.mdc-button--unelevated:before{background-color:var(--mdc-theme-on-secondary,#fff)}}.smui-button--color-secondary.mdc-button--raised:hover:before,.smui-button--color-secondary.mdc-button--unelevated:hover:before{opacity:.08}.smui-button--color-secondary.mdc-button--raised.mdc-ripple-upgraded--background-focused:before,.smui-button--color-secondary.mdc-button--raised:not(.mdc-ripple-upgraded):focus:before,.smui-button--color-secondary.mdc-button--unelevated.mdc-ripple-upgraded--background-focused:before,.smui-button--color-secondary.mdc-button--unelevated:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.24}.smui-button--color-secondary.mdc-button--raised:not(.mdc-ripple-upgraded):after,.smui-button--color-secondary.mdc-button--unelevated:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.smui-button--color-secondary.mdc-button--raised:not(.mdc-ripple-upgraded):active:after,.smui-button--color-secondary.mdc-button--unelevated:not(.mdc-ripple-upgraded):active:after{transition-duration:75ms;opacity:.24}.smui-button--color-secondary.mdc-button--raised.mdc-ripple-upgraded,.smui-button--color-secondary.mdc-button--unelevated.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:0.24}.smui-button__group{display:inline-flex}.smui-button__group>.mdc-button,.smui-button__group>.smui-button__group-item>.mdc-button{margin-left:0;margin-right:0}.smui-button__group>.mdc-button:not(:last-child),.smui-button__group>.smui-button__group-item:not(:last-child)>.mdc-button{border-top-right-radius:0;border-bottom-right-radius:0}.smui-button__group>.mdc-button:not(:first-child),.smui-button__group>.smui-button__group-item:not(:first-child)>.mdc-button{border-top-left-radius:0;border-bottom-left-radius:0}.smui-button__group.smui-button__group--raised{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}.smui-button__group>.mdc-button--raised,.smui-button__group>.smui-button__group-item>.mdc-button--raised{border-radius:4px;box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12)}.smui-button__group>.mdc-button--raised.mdc-button--dense,.smui-button__group>.smui-button__group-item>.mdc-button--raised.mdc-button--dense{border-radius:4px}.smui-button__group>.mdc-button--raised:active,.smui-button__group>.mdc-button--raised:disabled,.smui-button__group>.mdc-button--raised:focus,.smui-button__group>.mdc-button--raised:hover,.smui-button__group>.smui-button__group-item>.mdc-button--raised:active,.smui-button__group>.smui-button__group-item>.mdc-button--raised:disabled,.smui-button__group>.smui-button__group-item>.mdc-button--raised:focus,.smui-button__group>.smui-button__group-item>.mdc-button--raised:hover{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12)}.smui-button__group>.mdc-button--outlined:not(:last-child),.smui-button__group>.smui-button__group-item:not(:last-child)>.mdc-button--outlined{border-right-width:0}";
    styleInject(css$2);

    /* node_modules\@smui\common\A.svelte generated by Svelte v3.18.1 */
    const file$6 = "node_modules\\@smui\\common\\A.svelte";

    function create_fragment$7(ctx) {
    	let a;
    	let useActions_action;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
    	let a_levels = [{ href: /*href*/ ctx[1] }, exclude(/*$$props*/ ctx[3], ["use", "href"])];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$6, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, a, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[2].call(null, a))
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 16) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[4], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null));
    			}

    			set_attributes(a, get_spread_update(a_levels, [
    				dirty & /*href*/ 2 && { href: /*href*/ ctx[1] },
    				dirty & /*exclude, $$props*/ 8 && exclude(/*$$props*/ ctx[3], ["use", "href"])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { use = [] } = $$props;
    	let { href = "javascript:void(0);" } = $$props;
    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$new_props => {
    		$$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("href" in $$new_props) $$invalidate(1, href = $$new_props.href);
    		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return { use, href };
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    		if ("href" in $$props) $$invalidate(1, href = $$new_props.href);
    	};

    	$$props = exclude_internal_props($$props);
    	return [use, href, forwardEvents, $$props, $$scope, $$slots];
    }

    class A extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { use: 0, href: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "A",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get use() {
    		throw new Error("<A>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<A>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<A>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<A>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\common\Button.svelte generated by Svelte v3.18.1 */
    const file$7 = "node_modules\\@smui\\common\\Button.svelte";

    function create_fragment$8(ctx) {
    	let button;
    	let useActions_action;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let button_levels = [exclude(/*$$props*/ ctx[2], ["use"])];
    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			set_attributes(button, button_data);
    			add_location(button, file$7, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, button, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[1].call(null, button))
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 8) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[3], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null));
    			}

    			set_attributes(button, get_spread_update(button_levels, [dirty & /*exclude, $$props*/ 4 && exclude(/*$$props*/ ctx[2], ["use"])]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { use = [] } = $$props;
    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return { use };
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    	};

    	$$props = exclude_internal_props($$props);
    	return [use, forwardEvents, $$props, $$scope, $$slots];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { use: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get use() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function Ripple(node, props = {ripple: false, unbounded: false, color: null, classForward: () => {}}) {
      let instance = null;
      let addLayoutListener = getContext('SMUI:addLayoutListener');
      let removeLayoutListener;
      let classList = [];

      function addClass(className) {
        const idx = classList.indexOf(className);
        if (idx === -1) {
          node.classList.add(className);
          classList.push(className);
          if (props.classForward) {
            props.classForward(classList);
            console.log('addClass', className, classList);
          }
        }
      }

      function removeClass(className) {
        const idx = classList.indexOf(className);
        if (idx !== -1) {
          node.classList.remove(className);
          classList.splice(idx, 1);
          if (props.classForward) {
            props.classForward(classList);
            console.log('removeClass', className, classList);
          }
        }
      }

      function handleProps() {
        if (props.ripple && !instance) {
          // Override the Ripple component's adapter, so that we can forward classes
          // to Svelte components that overwrite Ripple's classes.
          const _createAdapter = MDCRipple.createAdapter;
          MDCRipple.createAdapter = function(...args) {
            const adapter = _createAdapter.apply(this, args);
            adapter.addClass = function(className) {
              return addClass(className);
            };
            adapter.removeClass = function(className) {
              return removeClass(className);
            };
            return adapter;
          };
          instance = new MDCRipple(node);
          MDCRipple.createAdapter = _createAdapter;
        } else if (instance && !props.ripple) {
          instance.destroy();
          instance = null;
        }
        if (props.ripple) {
          instance.unbounded = !!props.unbounded;
          switch (props.color) {
            case 'surface':
              addClass('mdc-ripple-surface');
              removeClass('mdc-ripple-surface--primary');
              removeClass('mdc-ripple-surface--accent');
              return;
            case 'primary':
              addClass('mdc-ripple-surface');
              addClass('mdc-ripple-surface--primary');
              removeClass('mdc-ripple-surface--accent');
              return;
            case 'secondary':
              addClass('mdc-ripple-surface');
              removeClass('mdc-ripple-surface--primary');
              addClass('mdc-ripple-surface--accent');
              return;
          }
        }
        removeClass('mdc-ripple-surface');
        removeClass('mdc-ripple-surface--primary');
        removeClass('mdc-ripple-surface--accent');
      }

      handleProps();

      if (addLayoutListener) {
        removeLayoutListener = addLayoutListener(layout);
      }

      function layout() {
        if (instance) {
          instance.layout();
        }
      }

      return {
        update(newProps = {ripple: false, unbounded: false, color: null, classForward: []}) {
          props = newProps;
          handleProps();
        },

        destroy() {
          if (instance) {
            instance.destroy();
            instance = null;
            removeClass('mdc-ripple-surface');
            removeClass('mdc-ripple-surface--primary');
            removeClass('mdc-ripple-surface--accent');
          }

          if (removeLayoutListener) {
            removeLayoutListener();
          }
        }
      }
    }

    /* node_modules\@smui\button\Button.svelte generated by Svelte v3.18.1 */

    // (1:0) <svelte:component   this={component}   use={[[Ripple, {ripple, unbounded: false, classForward: classes => rippleClasses = classes}], forwardEvents, ...use]}   class="     mdc-button     {className}     {rippleClasses.join(' ')}     {variant === 'raised' ? 'mdc-button--raised' : ''}     {variant === 'unelevated' ? 'mdc-button--unelevated' : ''}     {variant === 'outlined' ? 'mdc-button--outlined' : ''}     {dense ? 'mdc-button--dense' : ''}     {color === 'secondary' ? 'smui-button--color-secondary' : ''}     {context === 'card:action' ? 'mdc-card__action' : ''}     {context === 'card:action' ? 'mdc-card__action--button' : ''}     {context === 'dialog:action' ? 'mdc-dialog__button' : ''}     {context === 'top-app-bar:navigation' ? 'mdc-top-app-bar__navigation-icon' : ''}     {context === 'top-app-bar:action' ? 'mdc-top-app-bar__action-item' : ''}     {context === 'snackbar' ? 'mdc-snackbar__action' : ''}   "   {...actionProp}   {...defaultProp}   {...exclude($$props, ['use', 'class', 'ripple', 'color', 'variant', 'dense', ...dialogExcludes])} >
    function create_default_slot$1(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 524288) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[19], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(1:0) <svelte:component   this={component}   use={[[Ripple, {ripple, unbounded: false, classForward: classes => rippleClasses = classes}], forwardEvents, ...use]}   class=\\\"     mdc-button     {className}     {rippleClasses.join(' ')}     {variant === 'raised' ? 'mdc-button--raised' : ''}     {variant === 'unelevated' ? 'mdc-button--unelevated' : ''}     {variant === 'outlined' ? 'mdc-button--outlined' : ''}     {dense ? 'mdc-button--dense' : ''}     {color === 'secondary' ? 'smui-button--color-secondary' : ''}     {context === 'card:action' ? 'mdc-card__action' : ''}     {context === 'card:action' ? 'mdc-card__action--button' : ''}     {context === 'dialog:action' ? 'mdc-dialog__button' : ''}     {context === 'top-app-bar:navigation' ? 'mdc-top-app-bar__navigation-icon' : ''}     {context === 'top-app-bar:action' ? 'mdc-top-app-bar__action-item' : ''}     {context === 'snackbar' ? 'mdc-snackbar__action' : ''}   \\\"   {...actionProp}   {...defaultProp}   {...exclude($$props, ['use', 'class', 'ripple', 'color', 'variant', 'dense', ...dialogExcludes])} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{
    			use: [
    				[
    					Ripple,
    					{
    						ripple: /*ripple*/ ctx[2],
    						unbounded: false,
    						classForward: /*func*/ ctx[18]
    					}
    				],
    				/*forwardEvents*/ ctx[11],
    				.../*use*/ ctx[0]
    			]
    		},
    		{
    			class: "\n    mdc-button\n    " + /*className*/ ctx[1] + "\n    " + /*rippleClasses*/ ctx[7].join(" ") + "\n    " + (/*variant*/ ctx[4] === "raised"
    			? "mdc-button--raised"
    			: "") + "\n    " + (/*variant*/ ctx[4] === "unelevated"
    			? "mdc-button--unelevated"
    			: "") + "\n    " + (/*variant*/ ctx[4] === "outlined"
    			? "mdc-button--outlined"
    			: "") + "\n    " + (/*dense*/ ctx[5] ? "mdc-button--dense" : "") + "\n    " + (/*color*/ ctx[3] === "secondary"
    			? "smui-button--color-secondary"
    			: "") + "\n    " + (/*context*/ ctx[12] === "card:action"
    			? "mdc-card__action"
    			: "") + "\n    " + (/*context*/ ctx[12] === "card:action"
    			? "mdc-card__action--button"
    			: "") + "\n    " + (/*context*/ ctx[12] === "dialog:action"
    			? "mdc-dialog__button"
    			: "") + "\n    " + (/*context*/ ctx[12] === "top-app-bar:navigation"
    			? "mdc-top-app-bar__navigation-icon"
    			: "") + "\n    " + (/*context*/ ctx[12] === "top-app-bar:action"
    			? "mdc-top-app-bar__action-item"
    			: "") + "\n    " + (/*context*/ ctx[12] === "snackbar"
    			? "mdc-snackbar__action"
    			: "") + "\n  "
    		},
    		/*actionProp*/ ctx[9],
    		/*defaultProp*/ ctx[10],
    		exclude(/*$$props*/ ctx[13], [
    			"use",
    			"class",
    			"ripple",
    			"color",
    			"variant",
    			"dense",
    			.../*dialogExcludes*/ ctx[8]
    		])
    	];

    	var switch_value = /*component*/ ctx[6];

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			$$slots: { default: [create_default_slot$1] },
    			$$scope: { ctx }
    		};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = (dirty & /*Ripple, ripple, rippleClasses, forwardEvents, use, className, variant, dense, color, context, actionProp, defaultProp, exclude, $$props, dialogExcludes*/ 16319)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*Ripple, ripple, rippleClasses, forwardEvents, use*/ 2181 && {
    						use: [
    							[
    								Ripple,
    								{
    									ripple: /*ripple*/ ctx[2],
    									unbounded: false,
    									classForward: /*func*/ ctx[18]
    								}
    							],
    							/*forwardEvents*/ ctx[11],
    							.../*use*/ ctx[0]
    						]
    					},
    					dirty & /*className, rippleClasses, variant, dense, color, context*/ 4282 && {
    						class: "\n    mdc-button\n    " + /*className*/ ctx[1] + "\n    " + /*rippleClasses*/ ctx[7].join(" ") + "\n    " + (/*variant*/ ctx[4] === "raised"
    						? "mdc-button--raised"
    						: "") + "\n    " + (/*variant*/ ctx[4] === "unelevated"
    						? "mdc-button--unelevated"
    						: "") + "\n    " + (/*variant*/ ctx[4] === "outlined"
    						? "mdc-button--outlined"
    						: "") + "\n    " + (/*dense*/ ctx[5] ? "mdc-button--dense" : "") + "\n    " + (/*color*/ ctx[3] === "secondary"
    						? "smui-button--color-secondary"
    						: "") + "\n    " + (/*context*/ ctx[12] === "card:action"
    						? "mdc-card__action"
    						: "") + "\n    " + (/*context*/ ctx[12] === "card:action"
    						? "mdc-card__action--button"
    						: "") + "\n    " + (/*context*/ ctx[12] === "dialog:action"
    						? "mdc-dialog__button"
    						: "") + "\n    " + (/*context*/ ctx[12] === "top-app-bar:navigation"
    						? "mdc-top-app-bar__navigation-icon"
    						: "") + "\n    " + (/*context*/ ctx[12] === "top-app-bar:action"
    						? "mdc-top-app-bar__action-item"
    						: "") + "\n    " + (/*context*/ ctx[12] === "snackbar"
    						? "mdc-snackbar__action"
    						: "") + "\n  "
    					},
    					dirty & /*actionProp*/ 512 && get_spread_object(/*actionProp*/ ctx[9]),
    					dirty & /*defaultProp*/ 1024 && get_spread_object(/*defaultProp*/ ctx[10]),
    					dirty & /*exclude, $$props, dialogExcludes*/ 8448 && get_spread_object(exclude(/*$$props*/ ctx[13], [
    						"use",
    						"class",
    						"ripple",
    						"color",
    						"variant",
    						"dense",
    						.../*dialogExcludes*/ ctx[8]
    					]))
    				])
    			: {};

    			if (dirty & /*$$scope*/ 524288) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*component*/ ctx[6])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { use = [] } = $$props;
    	let { class: className = "" } = $$props;
    	let { ripple = true } = $$props;
    	let { color = "primary" } = $$props;
    	let { variant = "text" } = $$props;
    	let { dense = false } = $$props;
    	let { href = null } = $$props;
    	let { action = "close" } = $$props;
    	let { default: defaultAction = false } = $$props;
    	let { component = href == null ? Button : A } = $$props;
    	let context = getContext("SMUI:button:context");
    	let rippleClasses = [];
    	setContext("SMUI:label:context", "button");
    	setContext("SMUI:icon:context", "button");
    	let { $$slots = {}, $$scope } = $$props;
    	const func = classes => $$invalidate(7, rippleClasses = classes);

    	$$self.$set = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ("ripple" in $$new_props) $$invalidate(2, ripple = $$new_props.ripple);
    		if ("color" in $$new_props) $$invalidate(3, color = $$new_props.color);
    		if ("variant" in $$new_props) $$invalidate(4, variant = $$new_props.variant);
    		if ("dense" in $$new_props) $$invalidate(5, dense = $$new_props.dense);
    		if ("href" in $$new_props) $$invalidate(14, href = $$new_props.href);
    		if ("action" in $$new_props) $$invalidate(15, action = $$new_props.action);
    		if ("default" in $$new_props) $$invalidate(16, defaultAction = $$new_props.default);
    		if ("component" in $$new_props) $$invalidate(6, component = $$new_props.component);
    		if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			use,
    			className,
    			ripple,
    			color,
    			variant,
    			dense,
    			href,
    			action,
    			defaultAction,
    			component,
    			context,
    			rippleClasses,
    			dialogExcludes,
    			actionProp,
    			defaultProp
    		};
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
    		if ("ripple" in $$props) $$invalidate(2, ripple = $$new_props.ripple);
    		if ("color" in $$props) $$invalidate(3, color = $$new_props.color);
    		if ("variant" in $$props) $$invalidate(4, variant = $$new_props.variant);
    		if ("dense" in $$props) $$invalidate(5, dense = $$new_props.dense);
    		if ("href" in $$props) $$invalidate(14, href = $$new_props.href);
    		if ("action" in $$props) $$invalidate(15, action = $$new_props.action);
    		if ("defaultAction" in $$props) $$invalidate(16, defaultAction = $$new_props.defaultAction);
    		if ("component" in $$props) $$invalidate(6, component = $$new_props.component);
    		if ("context" in $$props) $$invalidate(12, context = $$new_props.context);
    		if ("rippleClasses" in $$props) $$invalidate(7, rippleClasses = $$new_props.rippleClasses);
    		if ("dialogExcludes" in $$props) $$invalidate(8, dialogExcludes = $$new_props.dialogExcludes);
    		if ("actionProp" in $$props) $$invalidate(9, actionProp = $$new_props.actionProp);
    		if ("defaultProp" in $$props) $$invalidate(10, defaultProp = $$new_props.defaultProp);
    	};

    	let dialogExcludes;
    	let actionProp;
    	let defaultProp;

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*action*/ 32768) {
    			 $$invalidate(9, actionProp = context === "dialog:action" && action !== null
    			? { "data-mdc-dialog-action": action }
    			: {});
    		}

    		if ($$self.$$.dirty & /*defaultAction*/ 65536) {
    			 $$invalidate(10, defaultProp = context === "dialog:action" && defaultAction
    			? { "data-mdc-dialog-button-default": "" }
    			: {});
    		}
    	};

    	 $$invalidate(8, dialogExcludes = context === "dialog:action" ? ["action", "default"] : []);
    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		ripple,
    		color,
    		variant,
    		dense,
    		component,
    		rippleClasses,
    		dialogExcludes,
    		actionProp,
    		defaultProp,
    		forwardEvents,
    		context,
    		$$props,
    		href,
    		action,
    		defaultAction,
    		$$slots,
    		func,
    		$$scope
    	];
    }

    class Button_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
    			use: 0,
    			class: 1,
    			ripple: 2,
    			color: 3,
    			variant: 4,
    			dense: 5,
    			href: 14,
    			action: 15,
    			default: 16,
    			component: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button_1",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get use() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ripple() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ripple(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dense() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dense(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get action() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set action(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get default() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set default(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\common\Label.svelte generated by Svelte v3.18.1 */
    const file$8 = "node_modules\\@smui\\common\\Label.svelte";

    function create_fragment$a(ctx) {
    	let span;
    	let useActions_action;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	let span_levels = [
    		{
    			class: "\n    " + /*className*/ ctx[1] + "\n    " + (/*context*/ ctx[3] === "button"
    			? "mdc-button__label"
    			: "") + "\n    " + (/*context*/ ctx[3] === "fab" ? "mdc-fab__label" : "") + "\n    " + (/*context*/ ctx[3] === "chip" ? "mdc-chip__text" : "") + "\n    " + (/*context*/ ctx[3] === "tab"
    			? "mdc-tab__text-label"
    			: "") + "\n    " + (/*context*/ ctx[3] === "image-list"
    			? "mdc-image-list__label"
    			: "") + "\n    " + (/*context*/ ctx[3] === "snackbar"
    			? "mdc-snackbar__label"
    			: "") + "\n  "
    		},
    		/*context*/ ctx[3] === "snackbar"
    		? { role: "status", "aria-live": "polite" }
    		: {},
    		exclude(/*$$props*/ ctx[4], ["use", "class"])
    	];

    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			set_attributes(span, span_data);
    			add_location(span, file$8, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[2].call(null, span))
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 32) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[5], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null));
    			}

    			set_attributes(span, get_spread_update(span_levels, [
    				dirty & /*className, context*/ 10 && {
    					class: "\n    " + /*className*/ ctx[1] + "\n    " + (/*context*/ ctx[3] === "button"
    					? "mdc-button__label"
    					: "") + "\n    " + (/*context*/ ctx[3] === "fab" ? "mdc-fab__label" : "") + "\n    " + (/*context*/ ctx[3] === "chip" ? "mdc-chip__text" : "") + "\n    " + (/*context*/ ctx[3] === "tab"
    					? "mdc-tab__text-label"
    					: "") + "\n    " + (/*context*/ ctx[3] === "image-list"
    					? "mdc-image-list__label"
    					: "") + "\n    " + (/*context*/ ctx[3] === "snackbar"
    					? "mdc-snackbar__label"
    					: "") + "\n  "
    				},
    				dirty & /*context*/ 8 && (/*context*/ ctx[3] === "snackbar"
    				? { role: "status", "aria-live": "polite" }
    				: {}),
    				dirty & /*exclude, $$props*/ 16 && exclude(/*$$props*/ ctx[4], ["use", "class"])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { use = [] } = $$props;
    	let { class: className = "" } = $$props;
    	const context = getContext("SMUI:label:context");
    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$new_props => {
    		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return { use, className };
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
    	};

    	$$props = exclude_internal_props($$props);
    	return [use, className, forwardEvents, context, $$props, $$scope, $$slots];
    }

    class Label extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { use: 0, class: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Label",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get use() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\common\Icon.svelte generated by Svelte v3.18.1 */
    const file$9 = "node_modules\\@smui\\common\\Icon.svelte";

    function create_fragment$b(ctx) {
    	let i;
    	let useActions_action;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	let i_levels = [
    		{
    			class: "\n    " + /*className*/ ctx[1] + "\n    " + (/*context*/ ctx[7] === "button"
    			? "mdc-button__icon"
    			: "") + "\n    " + (/*context*/ ctx[7] === "fab" ? "mdc-fab__icon" : "") + "\n    " + (/*context*/ ctx[7] === "icon-button"
    			? "mdc-icon-button__icon"
    			: "") + "\n    " + (/*context*/ ctx[7] === "icon-button" && /*on*/ ctx[2]
    			? "mdc-icon-button__icon--on"
    			: "") + "\n    " + (/*context*/ ctx[7] === "chip" ? "mdc-chip__icon" : "") + "\n    " + (/*context*/ ctx[7] === "chip" && /*leading*/ ctx[3]
    			? "mdc-chip__icon--leading"
    			: "") + "\n    " + (/*context*/ ctx[7] === "chip" && /*leadingHidden*/ ctx[4]
    			? "mdc-chip__icon--leading-hidden"
    			: "") + "\n    " + (/*context*/ ctx[7] === "chip" && /*trailing*/ ctx[5]
    			? "mdc-chip__icon--trailing"
    			: "") + "\n    " + (/*context*/ ctx[7] === "tab" ? "mdc-tab__icon" : "") + "\n  "
    		},
    		{ "aria-hidden": "true" },
    		exclude(/*$$props*/ ctx[8], ["use", "class", "on", "leading", "leadingHidden", "trailing"])
    	];

    	let i_data = {};

    	for (let i = 0; i < i_levels.length; i += 1) {
    		i_data = assign(i_data, i_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			i = element("i");
    			if (default_slot) default_slot.c();
    			set_attributes(i, i_data);
    			add_location(i, file$9, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (default_slot) {
    				default_slot.m(i, null);
    			}

    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, i, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[6].call(null, i))
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 512) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[9], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null));
    			}

    			set_attributes(i, get_spread_update(i_levels, [
    				dirty & /*className, context, on, leading, leadingHidden, trailing*/ 190 && {
    					class: "\n    " + /*className*/ ctx[1] + "\n    " + (/*context*/ ctx[7] === "button"
    					? "mdc-button__icon"
    					: "") + "\n    " + (/*context*/ ctx[7] === "fab" ? "mdc-fab__icon" : "") + "\n    " + (/*context*/ ctx[7] === "icon-button"
    					? "mdc-icon-button__icon"
    					: "") + "\n    " + (/*context*/ ctx[7] === "icon-button" && /*on*/ ctx[2]
    					? "mdc-icon-button__icon--on"
    					: "") + "\n    " + (/*context*/ ctx[7] === "chip" ? "mdc-chip__icon" : "") + "\n    " + (/*context*/ ctx[7] === "chip" && /*leading*/ ctx[3]
    					? "mdc-chip__icon--leading"
    					: "") + "\n    " + (/*context*/ ctx[7] === "chip" && /*leadingHidden*/ ctx[4]
    					? "mdc-chip__icon--leading-hidden"
    					: "") + "\n    " + (/*context*/ ctx[7] === "chip" && /*trailing*/ ctx[5]
    					? "mdc-chip__icon--trailing"
    					: "") + "\n    " + (/*context*/ ctx[7] === "tab" ? "mdc-tab__icon" : "") + "\n  "
    				},
    				{ "aria-hidden": "true" },
    				dirty & /*exclude, $$props*/ 256 && exclude(/*$$props*/ ctx[8], ["use", "class", "on", "leading", "leadingHidden", "trailing"])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			if (default_slot) default_slot.d(detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { use = [] } = $$props;
    	let { class: className = "" } = $$props;
    	let { on = false } = $$props;
    	let { leading = false } = $$props;
    	let { leadingHidden = false } = $$props;
    	let { trailing = false } = $$props;
    	const context = getContext("SMUI:icon:context");
    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ("on" in $$new_props) $$invalidate(2, on = $$new_props.on);
    		if ("leading" in $$new_props) $$invalidate(3, leading = $$new_props.leading);
    		if ("leadingHidden" in $$new_props) $$invalidate(4, leadingHidden = $$new_props.leadingHidden);
    		if ("trailing" in $$new_props) $$invalidate(5, trailing = $$new_props.trailing);
    		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			use,
    			className,
    			on,
    			leading,
    			leadingHidden,
    			trailing
    		};
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
    		if ("on" in $$props) $$invalidate(2, on = $$new_props.on);
    		if ("leading" in $$props) $$invalidate(3, leading = $$new_props.leading);
    		if ("leadingHidden" in $$props) $$invalidate(4, leadingHidden = $$new_props.leadingHidden);
    		if ("trailing" in $$props) $$invalidate(5, trailing = $$new_props.trailing);
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		on,
    		leading,
    		leadingHidden,
    		trailing,
    		forwardEvents,
    		context,
    		$$props,
    		$$scope,
    		$$slots
    	];
    }

    class Icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
    			use: 0,
    			class: 1,
    			on: 2,
    			leading: 3,
    			leadingHidden: 4,
    			trailing: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get use() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get on() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set on(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get leading() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set leading(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get leadingHidden() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set leadingHidden(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trailing() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trailing(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var css$3 = ".mdc-button{padding:0;min-width:24px}.mdc-button:after,.mdc-button:before{background:none}.mdc-menu{max-width:450px}.mdc-menu-surface{top:50px!important}.mdc-tab-bar{position:static}.mdc-list{height:300px;overflow:hidden;overflow-y:scroll;scroll-behavior:smooth;scrollbar-width:5px}::-webkit-scrollbar{width:5px}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px rgba(0,0,0,.3);-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);-webkit-border-radius:5px;border-radius:5px}::-webkit-scrollbar-thumb{-webkit-border-radius:5px;border-radius:5px;background:rgba(196,183,183,.8);-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.5);box-shadow:inset 0 0 6px rgba(0,0,0,.5)}::-webkit-scrollbar-thumb:window-inactive{background:rgba(138,129,129,.4)}.mdc-list{font-family:Roboto,sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:1rem;line-height:1.75rem;font-weight:400;letter-spacing:.00937em;text-decoration:inherit;text-transform:inherit;line-height:1.5rem;margin:0;padding:8px 0;list-style-type:none;color:rgba(0,0,0,.87);color:var(--mdc-theme-text-primary-on-background,rgba(0,0,0,.87))}.mdc-list:focus{outline:none}.mdc-list-item__secondary-text{color:rgba(0,0,0,.54);color:var(--mdc-theme-text-secondary-on-background,rgba(0,0,0,.54))}.mdc-list-item__graphic{background-color:transparent;color:rgba(0,0,0,.38);color:var(--mdc-theme-text-icon-on-background,rgba(0,0,0,.38))}.mdc-list-item__meta{color:rgba(0,0,0,.38);color:var(--mdc-theme-text-hint-on-background,rgba(0,0,0,.38))}.mdc-list-group__subheader{color:rgba(0,0,0,.87);color:var(--mdc-theme-text-primary-on-background,rgba(0,0,0,.87))}.mdc-list--dense{padding-top:4px;padding-bottom:4px;font-size:.812rem}.mdc-list-item{display:flex;position:relative;align-items:center;justify-content:flex-start;height:48px;padding:0 16px;overflow:hidden}.mdc-list-item:focus{outline:none}.mdc-list-item--activated,.mdc-list-item--activated .mdc-list-item__graphic,.mdc-list-item--selected,.mdc-list-item--selected .mdc-list-item__graphic{color:#6200ee;color:var(--mdc-theme-primary,#6200ee)}.mdc-list-item--disabled{color:rgba(0,0,0,.38);color:var(--mdc-theme-text-disabled-on-background,rgba(0,0,0,.38))}.mdc-list-item__graphic{margin-left:0;margin-right:32px;width:24px;height:24px;flex-shrink:0;align-items:center;justify-content:center;fill:currentColor}.mdc-list-item[dir=rtl] .mdc-list-item__graphic,[dir=rtl] .mdc-list-item .mdc-list-item__graphic{margin-left:32px;margin-right:0}.mdc-list .mdc-list-item__graphic{display:inline-flex}.mdc-list-item__meta{margin-left:auto;margin-right:0}.mdc-list-item__meta:not(.material-icons){font-family:Roboto,sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:.75rem;line-height:1.25rem;font-weight:400;letter-spacing:.03333em;text-decoration:inherit;text-transform:inherit}.mdc-list-item[dir=rtl] .mdc-list-item__meta,[dir=rtl] .mdc-list-item .mdc-list-item__meta{margin-left:0;margin-right:auto}.mdc-list-item__text{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.mdc-list-item__text[for]{pointer-events:none}.mdc-list-item__primary-text{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;margin-top:0;line-height:normal;margin-bottom:-20px;display:block}.mdc-list-item__primary-text:before{display:inline-block;width:0;height:32px;content:\"\";vertical-align:0}.mdc-list-item__primary-text:after{display:inline-block;width:0;height:20px;content:\"\";vertical-align:-20px}.mdc-list--dense .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list--dense .mdc-list-item__primary-text:before{display:inline-block;width:0;height:24px;content:\"\";vertical-align:0}.mdc-list--dense .mdc-list-item__primary-text:after{display:inline-block;width:0;height:20px;content:\"\";vertical-align:-20px}.mdc-list-item__secondary-text{font-family:Roboto,sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:.875rem;line-height:1.25rem;font-weight:400;letter-spacing:.01786em;text-decoration:inherit;text-transform:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;margin-top:0;line-height:normal;display:block}.mdc-list-item__secondary-text:before{display:inline-block;width:0;height:20px;content:\"\";vertical-align:0}.mdc-list--dense .mdc-list-item__secondary-text{display:block;margin-top:0;line-height:normal;font-size:inherit}.mdc-list--dense .mdc-list-item__secondary-text:before{display:inline-block;width:0;height:20px;content:\"\";vertical-align:0}.mdc-list--dense .mdc-list-item{height:40px}.mdc-list--dense .mdc-list-item__graphic{margin-left:0;margin-right:36px;width:20px;height:20px}.mdc-list-item[dir=rtl] .mdc-list--dense .mdc-list-item__graphic,[dir=rtl] .mdc-list-item .mdc-list--dense .mdc-list-item__graphic{margin-left:36px;margin-right:0}.mdc-list--avatar-list .mdc-list-item{height:56px}.mdc-list--avatar-list .mdc-list-item__graphic{margin-left:0;margin-right:16px;width:40px;height:40px;border-radius:50%}.mdc-list-item[dir=rtl] .mdc-list--avatar-list .mdc-list-item__graphic,[dir=rtl] .mdc-list-item .mdc-list--avatar-list .mdc-list-item__graphic{margin-left:16px;margin-right:0}.mdc-list--two-line .mdc-list-item__text{align-self:flex-start}.mdc-list--two-line .mdc-list-item{height:72px}.mdc-list--avatar-list.mdc-list--dense .mdc-list-item,.mdc-list--two-line.mdc-list--dense .mdc-list-item{height:60px}.mdc-list--avatar-list.mdc-list--dense .mdc-list-item__graphic{margin-left:0;margin-right:20px;width:36px;height:36px}.mdc-list-item[dir=rtl] .mdc-list--avatar-list.mdc-list--dense .mdc-list-item__graphic,[dir=rtl] .mdc-list-item .mdc-list--avatar-list.mdc-list--dense .mdc-list-item__graphic{margin-left:20px;margin-right:0}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item{cursor:pointer}a.mdc-list-item{color:inherit;text-decoration:none}.mdc-list-divider{height:0;margin:0;border:none;border-bottom:1px solid;border-bottom-color:rgba(0,0,0,.12)}.mdc-list-divider--padded{margin:0 16px}.mdc-list-divider--inset{margin-left:72px;margin-right:0;width:calc(100% - 72px)}.mdc-list-group[dir=rtl] .mdc-list-divider--inset,[dir=rtl] .mdc-list-group .mdc-list-divider--inset{margin-left:0;margin-right:72px}.mdc-list-divider--inset.mdc-list-divider--padded{width:calc(100% - 88px)}.mdc-list-group .mdc-list{padding:0}.mdc-list-group__subheader{font-family:Roboto,sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:1rem;line-height:1.75rem;font-weight:400;letter-spacing:.00937em;text-decoration:inherit;text-transform:inherit;margin:.75rem 16px}@keyframes mdc-ripple-fg-radius-in{0%{animation-timing-function:cubic-bezier(.4,0,.2,1);transform:translate(var(--mdc-ripple-fg-translate-start,0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}}@keyframes mdc-ripple-fg-opacity-in{0%{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity,0)}}@keyframes mdc-ripple-fg-opacity-out{0%{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity,0)}to{opacity:0}}.mdc-ripple-surface--test-edge-var-bug{--mdc-ripple-surface-test-edge-var:1px solid #000;visibility:hidden}.mdc-ripple-surface--test-edge-var-bug:before{border:var(--mdc-ripple-surface-test-edge-var)}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0)}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item:after,:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item:before{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:\"\"}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded:before{transform:scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded:after{top:0;left:0;transform:scale(0);transform-origin:center center}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded--unbounded:after{top:var(--mdc-ripple-top,0);left:var(--mdc-ripple-left,0)}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded--foreground-activation:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded--foreground-deactivation:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item:after,:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item:before{top:-50%;left:-50%;width:200%;height:200%}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded:after{width:var(--mdc-ripple-fg-size,100%);height:var(--mdc-ripple-fg-size,100%)}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item:after,:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item:before{background-color:#000}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item:hover:before{opacity:.04}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded--background-focused:before,:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.12}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item:not(.mdc-ripple-upgraded):active:after{transition-duration:75ms;opacity:.12}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:0.12}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--activated:before{opacity:.12}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--activated:after,:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--activated:before{background-color:#6200ee}@supports not (-ms-ime-align:auto){:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--activated:after,:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--activated:before{background-color:var(--mdc-theme-primary,#6200ee)}}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--activated:hover:before{opacity:.16}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--activated.mdc-ripple-upgraded--background-focused:before,:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--activated:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.24}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--activated:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--activated:not(.mdc-ripple-upgraded):active:after{transition-duration:75ms;opacity:.24}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--activated.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:0.24}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--selected:before{opacity:.08}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--selected:after,:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--selected:before{background-color:#6200ee}@supports not (-ms-ime-align:auto){:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--selected:after,:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--selected:before{background-color:var(--mdc-theme-primary,#6200ee)}}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--selected:hover:before{opacity:.12}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--selected.mdc-ripple-upgraded--background-focused:before,:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--selected:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.2}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--selected:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--selected:not(.mdc-ripple-upgraded):active:after{transition-duration:75ms;opacity:.2}:not(.mdc-list--non-interactive)>:not(.mdc-list-item--disabled).mdc-list-item--selected.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:0.2}:not(.mdc-list--non-interactive)>.mdc-list-item--disabled{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0)}:not(.mdc-list--non-interactive)>.mdc-list-item--disabled:after,:not(.mdc-list--non-interactive)>.mdc-list-item--disabled:before{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:\"\"}:not(.mdc-list--non-interactive)>.mdc-list-item--disabled:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1}:not(.mdc-list--non-interactive)>.mdc-list-item--disabled.mdc-ripple-upgraded:before{transform:scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-list--non-interactive)>.mdc-list-item--disabled.mdc-ripple-upgraded:after{top:0;left:0;transform:scale(0);transform-origin:center center}:not(.mdc-list--non-interactive)>.mdc-list-item--disabled.mdc-ripple-upgraded--unbounded:after{top:var(--mdc-ripple-top,0);left:var(--mdc-ripple-left,0)}:not(.mdc-list--non-interactive)>.mdc-list-item--disabled.mdc-ripple-upgraded--foreground-activation:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}:not(.mdc-list--non-interactive)>.mdc-list-item--disabled.mdc-ripple-upgraded--foreground-deactivation:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-list--non-interactive)>.mdc-list-item--disabled:after,:not(.mdc-list--non-interactive)>.mdc-list-item--disabled:before{top:-50%;left:-50%;width:200%;height:200%}:not(.mdc-list--non-interactive)>.mdc-list-item--disabled.mdc-ripple-upgraded:after{width:var(--mdc-ripple-fg-size,100%);height:var(--mdc-ripple-fg-size,100%)}:not(.mdc-list--non-interactive)>.mdc-list-item--disabled:after,:not(.mdc-list--non-interactive)>.mdc-list-item--disabled:before{background-color:#000}:not(.mdc-list--non-interactive)>.mdc-list-item--disabled.mdc-ripple-upgraded--background-focused:before,:not(.mdc-list--non-interactive)>.mdc-list-item--disabled:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.12}.mdc-ripple-surface{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);position:relative;outline:none;overflow:hidden}.mdc-ripple-surface:after,.mdc-ripple-surface:before{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:\"\"}.mdc-ripple-surface:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1}.mdc-ripple-surface.mdc-ripple-upgraded:before{transform:scale(var(--mdc-ripple-fg-scale,1))}.mdc-ripple-surface.mdc-ripple-upgraded:after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-ripple-surface.mdc-ripple-upgraded--unbounded:after{top:var(--mdc-ripple-top,0);left:var(--mdc-ripple-left,0)}.mdc-ripple-surface.mdc-ripple-upgraded--foreground-activation:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-ripple-surface.mdc-ripple-upgraded--foreground-deactivation:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}.mdc-ripple-surface:after,.mdc-ripple-surface:before{background-color:#000}.mdc-ripple-surface:hover:before{opacity:.04}.mdc-ripple-surface.mdc-ripple-upgraded--background-focused:before,.mdc-ripple-surface:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.12}.mdc-ripple-surface:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.mdc-ripple-surface:not(.mdc-ripple-upgraded):active:after{transition-duration:75ms;opacity:.12}.mdc-ripple-surface.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:0.12}.mdc-ripple-surface:after,.mdc-ripple-surface:before{top:-50%;left:-50%;width:200%;height:200%}.mdc-ripple-surface.mdc-ripple-upgraded:after{width:var(--mdc-ripple-fg-size,100%);height:var(--mdc-ripple-fg-size,100%)}.mdc-ripple-surface[data-mdc-ripple-is-unbounded]{overflow:visible}.mdc-ripple-surface[data-mdc-ripple-is-unbounded]:after,.mdc-ripple-surface[data-mdc-ripple-is-unbounded]:before{top:0;left:0;width:100%;height:100%}.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded:after,.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded:before{top:var(--mdc-ripple-top,0);left:var(--mdc-ripple-left,0);width:var(--mdc-ripple-fg-size,100%);height:var(--mdc-ripple-fg-size,100%)}.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded:after{width:var(--mdc-ripple-fg-size,100%);height:var(--mdc-ripple-fg-size,100%)}.mdc-ripple-surface--primary:after,.mdc-ripple-surface--primary:before{background-color:#6200ee}@supports not (-ms-ime-align:auto){.mdc-ripple-surface--primary:after,.mdc-ripple-surface--primary:before{background-color:var(--mdc-theme-primary,#6200ee)}}.mdc-ripple-surface--primary:hover:before{opacity:.04}.mdc-ripple-surface--primary.mdc-ripple-upgraded--background-focused:before,.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.12}.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded):active:after{transition-duration:75ms;opacity:.12}.mdc-ripple-surface--primary.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:0.12}.mdc-ripple-surface--accent:after,.mdc-ripple-surface--accent:before{background-color:#018786}@supports not (-ms-ime-align:auto){.mdc-ripple-surface--accent:after,.mdc-ripple-surface--accent:before{background-color:var(--mdc-theme-secondary,#018786)}}.mdc-ripple-surface--accent:hover:before{opacity:.04}.mdc-ripple-surface--accent.mdc-ripple-upgraded--background-focused:before,.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.12}.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded):active:after{transition-duration:75ms;opacity:.12}.mdc-ripple-surface--accent.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:0.12}.smui-list--three-line .mdc-list-item__text{align-self:flex-start}.smui-list--three-line .mdc-list-item{height:88px}.smui-list--three-line.mdc-list--dense .mdc-list-item{height:76px}";
    styleInject(css$3);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$3 = {
        LIST_ITEM_ACTIVATED_CLASS: 'mdc-list-item--activated',
        LIST_ITEM_CLASS: 'mdc-list-item',
        LIST_ITEM_DISABLED_CLASS: 'mdc-list-item--disabled',
        LIST_ITEM_SELECTED_CLASS: 'mdc-list-item--selected',
        ROOT: 'mdc-list',
    };
    var strings$4 = {
        ACTION_EVENT: 'MDCList:action',
        ARIA_CHECKED: 'aria-checked',
        ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
        ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
        ARIA_CURRENT: 'aria-current',
        ARIA_DISABLED: 'aria-disabled',
        ARIA_ORIENTATION: 'aria-orientation',
        ARIA_ORIENTATION_HORIZONTAL: 'horizontal',
        ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
        ARIA_SELECTED: 'aria-selected',
        CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"]:not(:disabled), input[type="radio"]:not(:disabled)',
        CHECKBOX_SELECTOR: 'input[type="checkbox"]:not(:disabled)',
        CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + cssClasses$3.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$3.LIST_ITEM_CLASS + " a\n  ",
        FOCUSABLE_CHILD_ELEMENTS: "\n    ." + cssClasses$3.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$3.LIST_ITEM_CLASS + " a,\n    ." + cssClasses$3.LIST_ITEM_CLASS + " input[type=\"radio\"]:not(:disabled),\n    ." + cssClasses$3.LIST_ITEM_CLASS + " input[type=\"checkbox\"]:not(:disabled)\n  ",
        RADIO_SELECTOR: 'input[type="radio"]:not(:disabled)',
    };
    var numbers$3 = {
        UNSET_INDEX: -1,
    };
    //# sourceMappingURL=constants.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];
    function isNumberArray(selectedIndex) {
        return selectedIndex instanceof Array;
    }
    var MDCListFoundation = /** @class */ (function (_super) {
        __extends(MDCListFoundation, _super);
        function MDCListFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCListFoundation.defaultAdapter, adapter)) || this;
            _this.wrapFocus_ = false;
            _this.isVertical_ = true;
            _this.isSingleSelectionList_ = false;
            _this.selectedIndex_ = numbers$3.UNSET_INDEX;
            _this.focusedItemIndex_ = numbers$3.UNSET_INDEX;
            _this.useActivatedClass_ = false;
            _this.ariaCurrentAttrValue_ = null;
            _this.isCheckboxList_ = false;
            _this.isRadioList_ = false;
            return _this;
        }
        Object.defineProperty(MDCListFoundation, "strings", {
            get: function () {
                return strings$4;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCListFoundation, "cssClasses", {
            get: function () {
                return cssClasses$3;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCListFoundation, "numbers", {
            get: function () {
                return numbers$3;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCListFoundation, "defaultAdapter", {
            get: function () {
                return {
                    addClassForElementIndex: function () { return undefined; },
                    focusItemAtIndex: function () { return undefined; },
                    getAttributeForElementIndex: function () { return null; },
                    getFocusedElementIndex: function () { return 0; },
                    getListItemCount: function () { return 0; },
                    hasCheckboxAtIndex: function () { return false; },
                    hasRadioAtIndex: function () { return false; },
                    isCheckboxCheckedAtIndex: function () { return false; },
                    isFocusInsideList: function () { return false; },
                    isRootFocused: function () { return false; },
                    notifyAction: function () { return undefined; },
                    removeClassForElementIndex: function () { return undefined; },
                    setAttributeForElementIndex: function () { return undefined; },
                    setCheckedCheckboxOrRadioAtIndex: function () { return undefined; },
                    setTabIndexForListItemChildren: function () { return undefined; },
                };
            },
            enumerable: true,
            configurable: true
        });
        MDCListFoundation.prototype.layout = function () {
            if (this.adapter_.getListItemCount() === 0) {
                return;
            }
            if (this.adapter_.hasCheckboxAtIndex(0)) {
                this.isCheckboxList_ = true;
            }
            else if (this.adapter_.hasRadioAtIndex(0)) {
                this.isRadioList_ = true;
            }
        };
        /**
         * Sets the private wrapFocus_ variable.
         */
        MDCListFoundation.prototype.setWrapFocus = function (value) {
            this.wrapFocus_ = value;
        };
        /**
         * Sets the isVertical_ private variable.
         */
        MDCListFoundation.prototype.setVerticalOrientation = function (value) {
            this.isVertical_ = value;
        };
        /**
         * Sets the isSingleSelectionList_ private variable.
         */
        MDCListFoundation.prototype.setSingleSelection = function (value) {
            this.isSingleSelectionList_ = value;
        };
        /**
         * Sets the useActivatedClass_ private variable.
         */
        MDCListFoundation.prototype.setUseActivatedClass = function (useActivated) {
            this.useActivatedClass_ = useActivated;
        };
        MDCListFoundation.prototype.getSelectedIndex = function () {
            return this.selectedIndex_;
        };
        MDCListFoundation.prototype.setSelectedIndex = function (index) {
            if (!this.isIndexValid_(index)) {
                return;
            }
            if (this.isCheckboxList_) {
                this.setCheckboxAtIndex_(index);
            }
            else if (this.isRadioList_) {
                this.setRadioAtIndex_(index);
            }
            else {
                this.setSingleSelectionAtIndex_(index);
            }
        };
        /**
         * Focus in handler for the list items.
         */
        MDCListFoundation.prototype.handleFocusIn = function (_, listItemIndex) {
            if (listItemIndex >= 0) {
                this.adapter_.setTabIndexForListItemChildren(listItemIndex, '0');
            }
        };
        /**
         * Focus out handler for the list items.
         */
        MDCListFoundation.prototype.handleFocusOut = function (_, listItemIndex) {
            var _this = this;
            if (listItemIndex >= 0) {
                this.adapter_.setTabIndexForListItemChildren(listItemIndex, '-1');
            }
            /**
             * Between Focusout & Focusin some browsers do not have focus on any element. Setting a delay to wait till the focus
             * is moved to next element.
             */
            setTimeout(function () {
                if (!_this.adapter_.isFocusInsideList()) {
                    _this.setTabindexToFirstSelectedItem_();
                }
            }, 0);
        };
        /**
         * Key handler for the list.
         */
        MDCListFoundation.prototype.handleKeydown = function (evt, isRootListItem, listItemIndex) {
            var isArrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
            var isArrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
            var isArrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
            var isArrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
            var isHome = evt.key === 'Home' || evt.keyCode === 36;
            var isEnd = evt.key === 'End' || evt.keyCode === 35;
            var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
            var isSpace = evt.key === 'Space' || evt.keyCode === 32;
            if (this.adapter_.isRootFocused()) {
                if (isArrowUp || isEnd) {
                    evt.preventDefault();
                    this.focusLastElement();
                }
                else if (isArrowDown || isHome) {
                    evt.preventDefault();
                    this.focusFirstElement();
                }
                return;
            }
            var currentIndex = this.adapter_.getFocusedElementIndex();
            if (currentIndex === -1) {
                currentIndex = listItemIndex;
                if (currentIndex < 0) {
                    // If this event doesn't have a mdc-list-item ancestor from the
                    // current list (not from a sublist), return early.
                    return;
                }
            }
            var nextIndex;
            if ((this.isVertical_ && isArrowDown) || (!this.isVertical_ && isArrowRight)) {
                this.preventDefaultEvent_(evt);
                nextIndex = this.focusNextElement(currentIndex);
            }
            else if ((this.isVertical_ && isArrowUp) || (!this.isVertical_ && isArrowLeft)) {
                this.preventDefaultEvent_(evt);
                nextIndex = this.focusPrevElement(currentIndex);
            }
            else if (isHome) {
                this.preventDefaultEvent_(evt);
                nextIndex = this.focusFirstElement();
            }
            else if (isEnd) {
                this.preventDefaultEvent_(evt);
                nextIndex = this.focusLastElement();
            }
            else if (isEnter || isSpace) {
                if (isRootListItem) {
                    // Return early if enter key is pressed on anchor element which triggers synthetic MouseEvent event.
                    var target = evt.target;
                    if (target && target.tagName === 'A' && isEnter) {
                        return;
                    }
                    this.preventDefaultEvent_(evt);
                    if (this.isSelectableList_()) {
                        this.setSelectedIndexOnAction_(currentIndex);
                    }
                    this.adapter_.notifyAction(currentIndex);
                }
            }
            this.focusedItemIndex_ = currentIndex;
            if (nextIndex !== undefined) {
                this.setTabindexAtIndex_(nextIndex);
                this.focusedItemIndex_ = nextIndex;
            }
        };
        /**
         * Click handler for the list.
         */
        MDCListFoundation.prototype.handleClick = function (index, toggleCheckbox) {
            if (index === numbers$3.UNSET_INDEX) {
                return;
            }
            if (this.isSelectableList_()) {
                this.setSelectedIndexOnAction_(index, toggleCheckbox);
            }
            this.adapter_.notifyAction(index);
            this.setTabindexAtIndex_(index);
            this.focusedItemIndex_ = index;
        };
        /**
         * Focuses the next element on the list.
         */
        MDCListFoundation.prototype.focusNextElement = function (index) {
            var count = this.adapter_.getListItemCount();
            var nextIndex = index + 1;
            if (nextIndex >= count) {
                if (this.wrapFocus_) {
                    nextIndex = 0;
                }
                else {
                    // Return early because last item is already focused.
                    return index;
                }
            }
            this.adapter_.focusItemAtIndex(nextIndex);
            return nextIndex;
        };
        /**
         * Focuses the previous element on the list.
         */
        MDCListFoundation.prototype.focusPrevElement = function (index) {
            var prevIndex = index - 1;
            if (prevIndex < 0) {
                if (this.wrapFocus_) {
                    prevIndex = this.adapter_.getListItemCount() - 1;
                }
                else {
                    // Return early because first item is already focused.
                    return index;
                }
            }
            this.adapter_.focusItemAtIndex(prevIndex);
            return prevIndex;
        };
        MDCListFoundation.prototype.focusFirstElement = function () {
            this.adapter_.focusItemAtIndex(0);
            return 0;
        };
        MDCListFoundation.prototype.focusLastElement = function () {
            var lastIndex = this.adapter_.getListItemCount() - 1;
            this.adapter_.focusItemAtIndex(lastIndex);
            return lastIndex;
        };
        /**
         * @param itemIndex Index of the list item
         * @param isEnabled Sets the list item to enabled or disabled.
         */
        MDCListFoundation.prototype.setEnabled = function (itemIndex, isEnabled) {
            if (!this.isIndexValid_(itemIndex)) {
                return;
            }
            if (isEnabled) {
                this.adapter_.removeClassForElementIndex(itemIndex, cssClasses$3.LIST_ITEM_DISABLED_CLASS);
                this.adapter_.setAttributeForElementIndex(itemIndex, strings$4.ARIA_DISABLED, 'false');
            }
            else {
                this.adapter_.addClassForElementIndex(itemIndex, cssClasses$3.LIST_ITEM_DISABLED_CLASS);
                this.adapter_.setAttributeForElementIndex(itemIndex, strings$4.ARIA_DISABLED, 'true');
            }
        };
        /**
         * Ensures that preventDefault is only called if the containing element doesn't
         * consume the event, and it will cause an unintended scroll.
         */
        MDCListFoundation.prototype.preventDefaultEvent_ = function (evt) {
            var target = evt.target;
            var tagName = ("" + target.tagName).toLowerCase();
            if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
                evt.preventDefault();
            }
        };
        MDCListFoundation.prototype.setSingleSelectionAtIndex_ = function (index) {
            if (this.selectedIndex_ === index) {
                return;
            }
            var selectedClassName = cssClasses$3.LIST_ITEM_SELECTED_CLASS;
            if (this.useActivatedClass_) {
                selectedClassName = cssClasses$3.LIST_ITEM_ACTIVATED_CLASS;
            }
            if (this.selectedIndex_ !== numbers$3.UNSET_INDEX) {
                this.adapter_.removeClassForElementIndex(this.selectedIndex_, selectedClassName);
            }
            this.adapter_.addClassForElementIndex(index, selectedClassName);
            this.setAriaForSingleSelectionAtIndex_(index);
            this.selectedIndex_ = index;
        };
        /**
         * Sets aria attribute for single selection at given index.
         */
        MDCListFoundation.prototype.setAriaForSingleSelectionAtIndex_ = function (index) {
            // Detect the presence of aria-current and get the value only during list initialization when it is in unset state.
            if (this.selectedIndex_ === numbers$3.UNSET_INDEX) {
                this.ariaCurrentAttrValue_ =
                    this.adapter_.getAttributeForElementIndex(index, strings$4.ARIA_CURRENT);
            }
            var isAriaCurrent = this.ariaCurrentAttrValue_ !== null;
            var ariaAttribute = isAriaCurrent ? strings$4.ARIA_CURRENT : strings$4.ARIA_SELECTED;
            if (this.selectedIndex_ !== numbers$3.UNSET_INDEX) {
                this.adapter_.setAttributeForElementIndex(this.selectedIndex_, ariaAttribute, 'false');
            }
            var ariaAttributeValue = isAriaCurrent ? this.ariaCurrentAttrValue_ : 'true';
            this.adapter_.setAttributeForElementIndex(index, ariaAttribute, ariaAttributeValue);
        };
        /**
         * Toggles radio at give index. Radio doesn't change the checked state if it is already checked.
         */
        MDCListFoundation.prototype.setRadioAtIndex_ = function (index) {
            this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, true);
            if (this.selectedIndex_ !== numbers$3.UNSET_INDEX) {
                this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$4.ARIA_CHECKED, 'false');
            }
            this.adapter_.setAttributeForElementIndex(index, strings$4.ARIA_CHECKED, 'true');
            this.selectedIndex_ = index;
        };
        MDCListFoundation.prototype.setCheckboxAtIndex_ = function (index) {
            for (var i = 0; i < this.adapter_.getListItemCount(); i++) {
                var isChecked = false;
                if (index.indexOf(i) >= 0) {
                    isChecked = true;
                }
                this.adapter_.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
                this.adapter_.setAttributeForElementIndex(i, strings$4.ARIA_CHECKED, isChecked ? 'true' : 'false');
            }
            this.selectedIndex_ = index;
        };
        MDCListFoundation.prototype.setTabindexAtIndex_ = function (index) {
            if (this.focusedItemIndex_ === numbers$3.UNSET_INDEX && index !== 0) {
                // If no list item was selected set first list item's tabindex to -1.
                // Generally, tabindex is set to 0 on first list item of list that has no preselected items.
                this.adapter_.setAttributeForElementIndex(0, 'tabindex', '-1');
            }
            else if (this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {
                this.adapter_.setAttributeForElementIndex(this.focusedItemIndex_, 'tabindex', '-1');
            }
            this.adapter_.setAttributeForElementIndex(index, 'tabindex', '0');
        };
        /**
         * @return Return true if it is single selectin list, checkbox list or radio list.
         */
        MDCListFoundation.prototype.isSelectableList_ = function () {
            return this.isSingleSelectionList_ || this.isCheckboxList_ || this.isRadioList_;
        };
        MDCListFoundation.prototype.setTabindexToFirstSelectedItem_ = function () {
            var targetIndex = 0;
            if (this.isSelectableList_()) {
                if (typeof this.selectedIndex_ === 'number' && this.selectedIndex_ !== numbers$3.UNSET_INDEX) {
                    targetIndex = this.selectedIndex_;
                }
                else if (isNumberArray(this.selectedIndex_) && this.selectedIndex_.length > 0) {
                    targetIndex = this.selectedIndex_.reduce(function (currentIndex, minIndex) { return Math.min(currentIndex, minIndex); });
                }
            }
            this.setTabindexAtIndex_(targetIndex);
        };
        MDCListFoundation.prototype.isIndexValid_ = function (index) {
            var _this = this;
            if (index instanceof Array) {
                if (!this.isCheckboxList_) {
                    throw new Error('MDCListFoundation: Array of index is only supported for checkbox based list');
                }
                if (index.length === 0) {
                    return true;
                }
                else {
                    return index.some(function (i) { return _this.isIndexInRange_(i); });
                }
            }
            else if (typeof index === 'number') {
                if (this.isCheckboxList_) {
                    throw new Error('MDCListFoundation: Expected array of index for checkbox based list but got number: ' + index);
                }
                return this.isIndexInRange_(index);
            }
            else {
                return false;
            }
        };
        MDCListFoundation.prototype.isIndexInRange_ = function (index) {
            var listSize = this.adapter_.getListItemCount();
            return index >= 0 && index < listSize;
        };
        MDCListFoundation.prototype.setSelectedIndexOnAction_ = function (index, toggleCheckbox) {
            if (toggleCheckbox === void 0) { toggleCheckbox = true; }
            if (this.isCheckboxList_) {
                this.toggleCheckboxAtIndex_(index, toggleCheckbox);
            }
            else {
                this.setSelectedIndex(index);
            }
        };
        MDCListFoundation.prototype.toggleCheckboxAtIndex_ = function (index, toggleCheckbox) {
            var isChecked = this.adapter_.isCheckboxCheckedAtIndex(index);
            if (toggleCheckbox) {
                isChecked = !isChecked;
                this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
            }
            this.adapter_.setAttributeForElementIndex(index, strings$4.ARIA_CHECKED, isChecked ? 'true' : 'false');
            // If none of the checkbox items are selected and selectedIndex is not initialized then provide a default value.
            var selectedIndexes = this.selectedIndex_ === numbers$3.UNSET_INDEX ? [] : this.selectedIndex_.slice();
            if (isChecked) {
                selectedIndexes.push(index);
            }
            else {
                selectedIndexes = selectedIndexes.filter(function (i) { return i !== index; });
            }
            this.selectedIndex_ = selectedIndexes;
        };
        return MDCListFoundation;
    }(MDCFoundation));
    //# sourceMappingURL=foundation.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCList = /** @class */ (function (_super) {
        __extends(MDCList, _super);
        function MDCList() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(MDCList.prototype, "vertical", {
            set: function (value) {
                this.foundation_.setVerticalOrientation(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCList.prototype, "listElements", {
            get: function () {
                return [].slice.call(this.root_.querySelectorAll("." + cssClasses$3.LIST_ITEM_CLASS));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCList.prototype, "wrapFocus", {
            set: function (value) {
                this.foundation_.setWrapFocus(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCList.prototype, "singleSelection", {
            set: function (isSingleSelectionList) {
                this.foundation_.setSingleSelection(isSingleSelectionList);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCList.prototype, "selectedIndex", {
            get: function () {
                return this.foundation_.getSelectedIndex();
            },
            set: function (index) {
                this.foundation_.setSelectedIndex(index);
            },
            enumerable: true,
            configurable: true
        });
        MDCList.attachTo = function (root) {
            return new MDCList(root);
        };
        MDCList.prototype.initialSyncWithDOM = function () {
            this.handleClick_ = this.handleClickEvent_.bind(this);
            this.handleKeydown_ = this.handleKeydownEvent_.bind(this);
            this.focusInEventListener_ = this.handleFocusInEvent_.bind(this);
            this.focusOutEventListener_ = this.handleFocusOutEvent_.bind(this);
            this.listen('keydown', this.handleKeydown_);
            this.listen('click', this.handleClick_);
            this.listen('focusin', this.focusInEventListener_);
            this.listen('focusout', this.focusOutEventListener_);
            this.layout();
            this.initializeListType();
        };
        MDCList.prototype.destroy = function () {
            this.unlisten('keydown', this.handleKeydown_);
            this.unlisten('click', this.handleClick_);
            this.unlisten('focusin', this.focusInEventListener_);
            this.unlisten('focusout', this.focusOutEventListener_);
        };
        MDCList.prototype.layout = function () {
            var direction = this.root_.getAttribute(strings$4.ARIA_ORIENTATION);
            this.vertical = direction !== strings$4.ARIA_ORIENTATION_HORIZONTAL;
            // List items need to have at least tabindex=-1 to be focusable.
            [].slice.call(this.root_.querySelectorAll('.mdc-list-item:not([tabindex])'))
                .forEach(function (el) {
                el.setAttribute('tabindex', '-1');
            });
            // Child button/a elements are not tabbable until the list item is focused.
            [].slice.call(this.root_.querySelectorAll(strings$4.FOCUSABLE_CHILD_ELEMENTS))
                .forEach(function (el) { return el.setAttribute('tabindex', '-1'); });
            this.foundation_.layout();
        };
        /**
         * Initialize selectedIndex value based on pre-selected checkbox list items, single selection or radio.
         */
        MDCList.prototype.initializeListType = function () {
            var _this = this;
            var checkboxListItems = this.root_.querySelectorAll(strings$4.ARIA_ROLE_CHECKBOX_SELECTOR);
            var singleSelectedListItem = this.root_.querySelector("\n      ." + cssClasses$3.LIST_ITEM_ACTIVATED_CLASS + ",\n      ." + cssClasses$3.LIST_ITEM_SELECTED_CLASS + "\n    ");
            var radioSelectedListItem = this.root_.querySelector(strings$4.ARIA_CHECKED_RADIO_SELECTOR);
            if (checkboxListItems.length) {
                var preselectedItems = this.root_.querySelectorAll(strings$4.ARIA_CHECKED_CHECKBOX_SELECTOR);
                this.selectedIndex =
                    [].map.call(preselectedItems, function (listItem) { return _this.listElements.indexOf(listItem); });
            }
            else if (singleSelectedListItem) {
                if (singleSelectedListItem.classList.contains(cssClasses$3.LIST_ITEM_ACTIVATED_CLASS)) {
                    this.foundation_.setUseActivatedClass(true);
                }
                this.singleSelection = true;
                this.selectedIndex = this.listElements.indexOf(singleSelectedListItem);
            }
            else if (radioSelectedListItem) {
                this.selectedIndex = this.listElements.indexOf(radioSelectedListItem);
            }
        };
        /**
         * Updates the list item at itemIndex to the desired isEnabled state.
         * @param itemIndex Index of the list item
         * @param isEnabled Sets the list item to enabled or disabled.
         */
        MDCList.prototype.setEnabled = function (itemIndex, isEnabled) {
            this.foundation_.setEnabled(itemIndex, isEnabled);
        };
        MDCList.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            var adapter = {
                addClassForElementIndex: function (index, className) {
                    var element = _this.listElements[index];
                    if (element) {
                        element.classList.add(className);
                    }
                },
                focusItemAtIndex: function (index) {
                    var element = _this.listElements[index];
                    if (element) {
                        element.focus();
                    }
                },
                getAttributeForElementIndex: function (index, attr) { return _this.listElements[index].getAttribute(attr); },
                getFocusedElementIndex: function () { return _this.listElements.indexOf(document.activeElement); },
                getListItemCount: function () { return _this.listElements.length; },
                hasCheckboxAtIndex: function (index) {
                    var listItem = _this.listElements[index];
                    return !!listItem.querySelector(strings$4.CHECKBOX_SELECTOR);
                },
                hasRadioAtIndex: function (index) {
                    var listItem = _this.listElements[index];
                    return !!listItem.querySelector(strings$4.RADIO_SELECTOR);
                },
                isCheckboxCheckedAtIndex: function (index) {
                    var listItem = _this.listElements[index];
                    var toggleEl = listItem.querySelector(strings$4.CHECKBOX_SELECTOR);
                    return toggleEl.checked;
                },
                isFocusInsideList: function () {
                    return _this.root_.contains(document.activeElement);
                },
                isRootFocused: function () { return document.activeElement === _this.root_; },
                notifyAction: function (index) {
                    _this.emit(strings$4.ACTION_EVENT, { index: index }, /** shouldBubble */ true);
                },
                removeClassForElementIndex: function (index, className) {
                    var element = _this.listElements[index];
                    if (element) {
                        element.classList.remove(className);
                    }
                },
                setAttributeForElementIndex: function (index, attr, value) {
                    var element = _this.listElements[index];
                    if (element) {
                        element.setAttribute(attr, value);
                    }
                },
                setCheckedCheckboxOrRadioAtIndex: function (index, isChecked) {
                    var listItem = _this.listElements[index];
                    var toggleEl = listItem.querySelector(strings$4.CHECKBOX_RADIO_SELECTOR);
                    toggleEl.checked = isChecked;
                    var event = document.createEvent('Event');
                    event.initEvent('change', true, true);
                    toggleEl.dispatchEvent(event);
                },
                setTabIndexForListItemChildren: function (listItemIndex, tabIndexValue) {
                    var element = _this.listElements[listItemIndex];
                    var listItemChildren = [].slice.call(element.querySelectorAll(strings$4.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));
                    listItemChildren.forEach(function (el) { return el.setAttribute('tabindex', tabIndexValue); });
                },
            };
            return new MDCListFoundation(adapter);
        };
        /**
         * Used to figure out which list item this event is targetting. Or returns -1 if
         * there is no list item
         */
        MDCList.prototype.getListItemIndex_ = function (evt) {
            var eventTarget = evt.target;
            var nearestParent = closest(eventTarget, "." + cssClasses$3.LIST_ITEM_CLASS + ", ." + cssClasses$3.ROOT);
            // Get the index of the element if it is a list item.
            if (nearestParent && matches$1(nearestParent, "." + cssClasses$3.LIST_ITEM_CLASS)) {
                return this.listElements.indexOf(nearestParent);
            }
            return -1;
        };
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         */
        MDCList.prototype.handleFocusInEvent_ = function (evt) {
            var index = this.getListItemIndex_(evt);
            this.foundation_.handleFocusIn(evt, index);
        };
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         */
        MDCList.prototype.handleFocusOutEvent_ = function (evt) {
            var index = this.getListItemIndex_(evt);
            this.foundation_.handleFocusOut(evt, index);
        };
        /**
         * Used to figure out which element was focused when keydown event occurred before sending the event to the
         * foundation.
         */
        MDCList.prototype.handleKeydownEvent_ = function (evt) {
            var index = this.getListItemIndex_(evt);
            var target = evt.target;
            this.foundation_.handleKeydown(evt, target.classList.contains(cssClasses$3.LIST_ITEM_CLASS), index);
        };
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         */
        MDCList.prototype.handleClickEvent_ = function (evt) {
            var index = this.getListItemIndex_(evt);
            var target = evt.target;
            // Toggle the checkbox only if it's not the target of the event, or the checkbox will have 2 change events.
            var toggleCheckbox = !matches$1(target, strings$4.CHECKBOX_RADIO_SELECTOR);
            this.foundation_.handleClick(index, toggleCheckbox);
        };
        return MDCList;
    }(MDCComponent));
    //# sourceMappingURL=component.js.map

    /* node_modules\@smui\list\List.svelte generated by Svelte v3.18.1 */
    const file$a = "node_modules\\@smui\\list\\List.svelte";

    // (18:0) {:else}
    function create_else_block(ctx) {
    	let ul;
    	let useActions_action;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[29].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);

    	let ul_levels = [
    		{
    			class: "\n      mdc-list\n      " + /*className*/ ctx[1] + "\n      " + (/*nonInteractive*/ ctx[2]
    			? "mdc-list--non-interactive"
    			: "") + "\n      " + (/*dense*/ ctx[3] ? "mdc-list--dense" : "") + "\n      " + (/*avatarList*/ ctx[4] ? "mdc-list--avatar-list" : "") + "\n      " + (/*twoLine*/ ctx[5] ? "mdc-list--two-line" : "") + "\n      " + (/*threeLine*/ ctx[6] && !/*twoLine*/ ctx[5]
    			? "smui-list--three-line"
    			: "") + "\n    "
    		},
    		{ role: /*role*/ ctx[8] },
    		/*props*/ ctx[9]
    	];

    	let ul_data = {};

    	for (let i = 0; i < ul_levels.length; i += 1) {
    		ul_data = assign(ul_data, ul_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			set_attributes(ul, ul_data);
    			add_location(ul, file$a, 18, 2, 478);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			/*ul_binding*/ ctx[31](ul);
    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, ul, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[10].call(null, ul)),
    				listen_dev(ul, "MDCList:action", /*handleAction*/ ctx[12], false, false, false)
    			];
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot && default_slot.p && dirty[0] & /*$$scope*/ 268435456) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[28], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[28], dirty, null));
    			}

    			set_attributes(ul, get_spread_update(ul_levels, [
    				dirty[0] & /*className, nonInteractive, dense, avatarList, twoLine, threeLine*/ 126 && {
    					class: "\n      mdc-list\n      " + /*className*/ ctx[1] + "\n      " + (/*nonInteractive*/ ctx[2]
    					? "mdc-list--non-interactive"
    					: "") + "\n      " + (/*dense*/ ctx[3] ? "mdc-list--dense" : "") + "\n      " + (/*avatarList*/ ctx[4] ? "mdc-list--avatar-list" : "") + "\n      " + (/*twoLine*/ ctx[5] ? "mdc-list--two-line" : "") + "\n      " + (/*threeLine*/ ctx[6] && !/*twoLine*/ ctx[5]
    					? "smui-list--three-line"
    					: "") + "\n    "
    				},
    				dirty[0] & /*role*/ 256 && { role: /*role*/ ctx[8] },
    				dirty[0] & /*props*/ 512 && /*props*/ ctx[9]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (default_slot) default_slot.d(detaching);
    			/*ul_binding*/ ctx[31](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(18:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (1:0) {#if nav}
    function create_if_block(ctx) {
    	let nav_1;
    	let useActions_action;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[29].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);

    	let nav_1_levels = [
    		{
    			class: "\n      mdc-list\n      " + /*className*/ ctx[1] + "\n      " + (/*nonInteractive*/ ctx[2]
    			? "mdc-list--non-interactive"
    			: "") + "\n      " + (/*dense*/ ctx[3] ? "mdc-list--dense" : "") + "\n      " + (/*avatarList*/ ctx[4] ? "mdc-list--avatar-list" : "") + "\n      " + (/*twoLine*/ ctx[5] ? "mdc-list--two-line" : "") + "\n      " + (/*threeLine*/ ctx[6] && !/*twoLine*/ ctx[5]
    			? "smui-list--three-line"
    			: "") + "\n    "
    		},
    		/*props*/ ctx[9]
    	];

    	let nav_1_data = {};

    	for (let i = 0; i < nav_1_levels.length; i += 1) {
    		nav_1_data = assign(nav_1_data, nav_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			nav_1 = element("nav");
    			if (default_slot) default_slot.c();
    			set_attributes(nav_1, nav_1_data);
    			add_location(nav_1, file$a, 1, 2, 12);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav_1, anchor);

    			if (default_slot) {
    				default_slot.m(nav_1, null);
    			}

    			/*nav_1_binding*/ ctx[30](nav_1);
    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, nav_1, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[10].call(null, nav_1)),
    				listen_dev(nav_1, "MDCList:action", /*handleAction*/ ctx[12], false, false, false)
    			];
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot && default_slot.p && dirty[0] & /*$$scope*/ 268435456) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[28], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[28], dirty, null));
    			}

    			set_attributes(nav_1, get_spread_update(nav_1_levels, [
    				dirty[0] & /*className, nonInteractive, dense, avatarList, twoLine, threeLine*/ 126 && {
    					class: "\n      mdc-list\n      " + /*className*/ ctx[1] + "\n      " + (/*nonInteractive*/ ctx[2]
    					? "mdc-list--non-interactive"
    					: "") + "\n      " + (/*dense*/ ctx[3] ? "mdc-list--dense" : "") + "\n      " + (/*avatarList*/ ctx[4] ? "mdc-list--avatar-list" : "") + "\n      " + (/*twoLine*/ ctx[5] ? "mdc-list--two-line" : "") + "\n      " + (/*threeLine*/ ctx[6] && !/*twoLine*/ ctx[5]
    					? "smui-list--three-line"
    					: "") + "\n    "
    				},
    				dirty[0] & /*props*/ 512 && /*props*/ ctx[9]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav_1);
    			if (default_slot) default_slot.d(detaching);
    			/*nav_1_binding*/ ctx[30](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(1:0) {#if nav}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*nav*/ ctx[11]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component, ["MDCList:action"]);
    	let { use = [] } = $$props;
    	let { class: className = "" } = $$props;
    	let { nonInteractive = false } = $$props;
    	let { dense = false } = $$props;
    	let { avatarList = false } = $$props;
    	let { twoLine = false } = $$props;
    	let { threeLine = false } = $$props;
    	let { vertical = true } = $$props;
    	let { wrapFocus = false } = $$props;
    	let { singleSelection = false } = $$props;
    	let { selectedIndex = null } = $$props;
    	let { radiolist = false } = $$props;
    	let { checklist = false } = $$props;
    	let element;
    	let list;
    	let role = getContext("SMUI:list:role");
    	let nav = getContext("SMUI:list:nav");
    	let instantiate = getContext("SMUI:list:instantiate");
    	let getInstance = getContext("SMUI:list:getInstance");
    	let addLayoutListener = getContext("SMUI:addLayoutListener");
    	let removeLayoutListener;
    	setContext("SMUI:list:nonInteractive", nonInteractive);

    	if (!role) {
    		if (singleSelection) {
    			role = "listbox";
    			setContext("SMUI:list:item:role", "option");
    		} else if (radiolist) {
    			role = "radiogroup";
    			setContext("SMUI:list:item:role", "radio");
    		} else if (checklist) {
    			role = "group";
    			setContext("SMUI:list:item:role", "checkbox");
    		} else {
    			role = "list";
    			setContext("SMUI:list:item:role", undefined);
    		}
    	}

    	if (addLayoutListener) {
    		removeLayoutListener = addLayoutListener(layout);
    	}

    	onMount(async () => {
    		if (instantiate !== false) {
    			$$invalidate(22, list = new MDCList(element));
    		} else {
    			$$invalidate(22, list = await getInstance());
    		}

    		if (singleSelection) {
    			list.initializeListType();
    			$$invalidate(13, selectedIndex = list.selectedIndex);
    		}
    	});

    	onDestroy(() => {
    		if (instantiate !== false) {
    			list && list.destroy();
    		}

    		if (removeLayoutListener) {
    			removeLayoutListener();
    		}
    	});

    	function handleAction(e) {
    		if (list && list.listElements[e.detail.index].classList.contains("mdc-list-item--disabled")) {
    			e.preventDefault();
    			$$invalidate(22, list.selectedIndex = selectedIndex, list);
    		} else if (list && list.selectedIndex === e.detail.index) {
    			$$invalidate(13, selectedIndex = e.detail.index);
    		}
    	}

    	function layout(...args) {
    		return list.layout(...args);
    	}

    	function setEnabled(...args) {
    		return list.setEnabled(...args);
    	}

    	function getDefaultFoundation(...args) {
    		return list.getDefaultFoundation(...args);
    	}

    	let { $$slots = {}, $$scope } = $$props;

    	function nav_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(7, element = $$value);
    		});
    	}

    	function ul_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(7, element = $$value);
    		});
    	}

    	$$self.$set = $$new_props => {
    		$$invalidate(27, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ("nonInteractive" in $$new_props) $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
    		if ("dense" in $$new_props) $$invalidate(3, dense = $$new_props.dense);
    		if ("avatarList" in $$new_props) $$invalidate(4, avatarList = $$new_props.avatarList);
    		if ("twoLine" in $$new_props) $$invalidate(5, twoLine = $$new_props.twoLine);
    		if ("threeLine" in $$new_props) $$invalidate(6, threeLine = $$new_props.threeLine);
    		if ("vertical" in $$new_props) $$invalidate(14, vertical = $$new_props.vertical);
    		if ("wrapFocus" in $$new_props) $$invalidate(15, wrapFocus = $$new_props.wrapFocus);
    		if ("singleSelection" in $$new_props) $$invalidate(16, singleSelection = $$new_props.singleSelection);
    		if ("selectedIndex" in $$new_props) $$invalidate(13, selectedIndex = $$new_props.selectedIndex);
    		if ("radiolist" in $$new_props) $$invalidate(17, radiolist = $$new_props.radiolist);
    		if ("checklist" in $$new_props) $$invalidate(18, checklist = $$new_props.checklist);
    		if ("$$scope" in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			use,
    			className,
    			nonInteractive,
    			dense,
    			avatarList,
    			twoLine,
    			threeLine,
    			vertical,
    			wrapFocus,
    			singleSelection,
    			selectedIndex,
    			radiolist,
    			checklist,
    			element,
    			list,
    			role,
    			nav,
    			instantiate,
    			getInstance,
    			addLayoutListener,
    			removeLayoutListener,
    			props
    		};
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(27, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
    		if ("nonInteractive" in $$props) $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
    		if ("dense" in $$props) $$invalidate(3, dense = $$new_props.dense);
    		if ("avatarList" in $$props) $$invalidate(4, avatarList = $$new_props.avatarList);
    		if ("twoLine" in $$props) $$invalidate(5, twoLine = $$new_props.twoLine);
    		if ("threeLine" in $$props) $$invalidate(6, threeLine = $$new_props.threeLine);
    		if ("vertical" in $$props) $$invalidate(14, vertical = $$new_props.vertical);
    		if ("wrapFocus" in $$props) $$invalidate(15, wrapFocus = $$new_props.wrapFocus);
    		if ("singleSelection" in $$props) $$invalidate(16, singleSelection = $$new_props.singleSelection);
    		if ("selectedIndex" in $$props) $$invalidate(13, selectedIndex = $$new_props.selectedIndex);
    		if ("radiolist" in $$props) $$invalidate(17, radiolist = $$new_props.radiolist);
    		if ("checklist" in $$props) $$invalidate(18, checklist = $$new_props.checklist);
    		if ("element" in $$props) $$invalidate(7, element = $$new_props.element);
    		if ("list" in $$props) $$invalidate(22, list = $$new_props.list);
    		if ("role" in $$props) $$invalidate(8, role = $$new_props.role);
    		if ("nav" in $$props) $$invalidate(11, nav = $$new_props.nav);
    		if ("instantiate" in $$props) instantiate = $$new_props.instantiate;
    		if ("getInstance" in $$props) getInstance = $$new_props.getInstance;
    		if ("addLayoutListener" in $$props) addLayoutListener = $$new_props.addLayoutListener;
    		if ("removeLayoutListener" in $$props) removeLayoutListener = $$new_props.removeLayoutListener;
    		if ("props" in $$props) $$invalidate(9, props = $$new_props.props);
    	};

    	let props;

    	$$self.$$.update = () => {
    		 $$invalidate(9, props = exclude($$props, [
    			"use",
    			"class",
    			"nonInteractive",
    			"dense",
    			"avatarList",
    			"twoLine",
    			"threeLine",
    			"vertical",
    			"wrapFocus",
    			"singleSelection",
    			"selectedIndex",
    			"radiolist",
    			"checklist"
    		]));

    		if ($$self.$$.dirty[0] & /*list, vertical*/ 4210688) {
    			 if (list && list.vertical !== vertical) {
    				$$invalidate(22, list.vertical = vertical, list);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*list, wrapFocus*/ 4227072) {
    			 if (list && list.wrapFocus !== wrapFocus) {
    				$$invalidate(22, list.wrapFocus = wrapFocus, list);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*list, singleSelection*/ 4259840) {
    			 if (list && list.singleSelection !== singleSelection) {
    				$$invalidate(22, list.singleSelection = singleSelection, list);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*list, singleSelection, selectedIndex*/ 4268032) {
    			 if (list && singleSelection && list.selectedIndex !== selectedIndex) {
    				$$invalidate(22, list.selectedIndex = selectedIndex, list);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		nonInteractive,
    		dense,
    		avatarList,
    		twoLine,
    		threeLine,
    		element,
    		role,
    		props,
    		forwardEvents,
    		nav,
    		handleAction,
    		selectedIndex,
    		vertical,
    		wrapFocus,
    		singleSelection,
    		radiolist,
    		checklist,
    		layout,
    		setEnabled,
    		getDefaultFoundation,
    		list,
    		removeLayoutListener,
    		instantiate,
    		getInstance,
    		addLayoutListener,
    		$$props,
    		$$scope,
    		$$slots,
    		nav_1_binding,
    		ul_binding
    	];
    }

    class List extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$c,
    			create_fragment$c,
    			safe_not_equal,
    			{
    				use: 0,
    				class: 1,
    				nonInteractive: 2,
    				dense: 3,
    				avatarList: 4,
    				twoLine: 5,
    				threeLine: 6,
    				vertical: 14,
    				wrapFocus: 15,
    				singleSelection: 16,
    				selectedIndex: 13,
    				radiolist: 17,
    				checklist: 18,
    				layout: 19,
    				setEnabled: 20,
    				getDefaultFoundation: 21
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get use() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nonInteractive() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nonInteractive(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dense() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dense(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get avatarList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set avatarList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get twoLine() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set twoLine(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get threeLine() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set threeLine(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vertical() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vertical(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrapFocus() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrapFocus(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get singleSelection() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set singleSelection(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedIndex() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedIndex(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radiolist() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radiolist(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checklist() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checklist(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layout() {
    		return this.$$.ctx[19];
    	}

    	set layout(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setEnabled() {
    		return this.$$.ctx[20];
    	}

    	set setEnabled(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getDefaultFoundation() {
    		return this.$$.ctx[21];
    	}

    	set getDefaultFoundation(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\list\Item.svelte generated by Svelte v3.18.1 */
    const file$b = "node_modules\\@smui\\list\\Item.svelte";

    // (40:0) {:else}
    function create_else_block$1(ctx) {
    	let li;
    	let useActions_action;
    	let forwardEvents_action;
    	let Ripple_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[25].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[24], null);

    	let li_levels = [
    		{
    			class: "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? "mdc-list-item--activated" : "") + "\n      " + (/*selected*/ ctx[7] ? "mdc-list-item--selected" : "") + "\n      " + (/*disabled*/ ctx[8] ? "mdc-list-item--disabled" : "") + "\n      " + (/*role*/ ctx[6] === "menuitem" && /*selected*/ ctx[7]
    			? "mdc-menu-item--selected"
    			: "") + "\n    "
    		},
    		{ role: /*role*/ ctx[6] },
    		/*role*/ ctx[6] === "option"
    		? {
    				"aria-selected": /*selected*/ ctx[7] ? "true" : "false"
    			}
    		: {},
    		/*role*/ ctx[6] === "radio" || /*role*/ ctx[6] === "checkbox"
    		? {
    				"aria-checked": /*checked*/ ctx[10] ? "true" : "false"
    			}
    		: {},
    		{ tabindex: /*tabindex*/ ctx[0] },
    		/*props*/ ctx[12]
    	];

    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (default_slot) default_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$b, 40, 2, 1053);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			/*li_binding*/ ctx[28](li);
    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, li, /*use*/ ctx[1])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[13].call(null, li)),
    				action_destroyer(Ripple_action = Ripple.call(null, li, {
    					ripple: /*ripple*/ ctx[3],
    					unbounded: false,
    					color: /*color*/ ctx[4]
    				})),
    				listen_dev(li, "click", /*action*/ ctx[15], false, false, false),
    				listen_dev(li, "keydown", /*handleKeydown*/ ctx[16], false, false, false)
    			];
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 16777216) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[24], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[24], dirty, null));
    			}

    			set_attributes(li, get_spread_update(li_levels, [
    				dirty & /*className, activated, selected, disabled, role*/ 484 && {
    					class: "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? "mdc-list-item--activated" : "") + "\n      " + (/*selected*/ ctx[7] ? "mdc-list-item--selected" : "") + "\n      " + (/*disabled*/ ctx[8] ? "mdc-list-item--disabled" : "") + "\n      " + (/*role*/ ctx[6] === "menuitem" && /*selected*/ ctx[7]
    					? "mdc-menu-item--selected"
    					: "") + "\n    "
    				},
    				dirty & /*role*/ 64 && { role: /*role*/ ctx[6] },
    				dirty & /*role, selected*/ 192 && (/*role*/ ctx[6] === "option"
    				? {
    						"aria-selected": /*selected*/ ctx[7] ? "true" : "false"
    					}
    				: {}),
    				dirty & /*role, checked*/ 1088 && (/*role*/ ctx[6] === "radio" || /*role*/ ctx[6] === "checkbox"
    				? {
    						"aria-checked": /*checked*/ ctx[10] ? "true" : "false"
    					}
    				: {}),
    				dirty & /*tabindex*/ 1 && { tabindex: /*tabindex*/ ctx[0] },
    				dirty & /*props*/ 4096 && /*props*/ ctx[12]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

    			if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple, color*/ 24) Ripple_action.update.call(null, {
    				ripple: /*ripple*/ ctx[3],
    				unbounded: false,
    				color: /*color*/ ctx[4]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    			/*li_binding*/ ctx[28](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(40:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (21:23) 
    function create_if_block_1(ctx) {
    	let span;
    	let useActions_action;
    	let forwardEvents_action;
    	let Ripple_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[25].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[24], null);

    	let span_levels = [
    		{
    			class: "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? "mdc-list-item--activated" : "") + "\n      " + (/*selected*/ ctx[7] ? "mdc-list-item--selected" : "") + "\n      " + (/*disabled*/ ctx[8] ? "mdc-list-item--disabled" : "") + "\n    "
    		},
    		/*activated*/ ctx[5] ? { "aria-current": "page" } : {},
    		{ tabindex: /*tabindex*/ ctx[0] },
    		/*props*/ ctx[12]
    	];

    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			set_attributes(span, span_data);
    			add_location(span, file$b, 21, 2, 547);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			/*span_binding*/ ctx[27](span);
    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[1])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[13].call(null, span)),
    				action_destroyer(Ripple_action = Ripple.call(null, span, {
    					ripple: /*ripple*/ ctx[3],
    					unbounded: false,
    					color: /*color*/ ctx[4]
    				})),
    				listen_dev(span, "click", /*action*/ ctx[15], false, false, false),
    				listen_dev(span, "keydown", /*handleKeydown*/ ctx[16], false, false, false)
    			];
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 16777216) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[24], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[24], dirty, null));
    			}

    			set_attributes(span, get_spread_update(span_levels, [
    				dirty & /*className, activated, selected, disabled*/ 420 && {
    					class: "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? "mdc-list-item--activated" : "") + "\n      " + (/*selected*/ ctx[7] ? "mdc-list-item--selected" : "") + "\n      " + (/*disabled*/ ctx[8] ? "mdc-list-item--disabled" : "") + "\n    "
    				},
    				dirty & /*activated*/ 32 && (/*activated*/ ctx[5] ? { "aria-current": "page" } : {}),
    				dirty & /*tabindex*/ 1 && { tabindex: /*tabindex*/ ctx[0] },
    				dirty & /*props*/ 4096 && /*props*/ ctx[12]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

    			if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple, color*/ 24) Ripple_action.update.call(null, {
    				ripple: /*ripple*/ ctx[3],
    				unbounded: false,
    				color: /*color*/ ctx[4]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			/*span_binding*/ ctx[27](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(21:23) ",
    		ctx
    	});

    	return block;
    }

    // (1:0) {#if nav && href}
    function create_if_block$1(ctx) {
    	let a;
    	let useActions_action;
    	let forwardEvents_action;
    	let Ripple_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[25].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[24], null);

    	let a_levels = [
    		{
    			class: "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? "mdc-list-item--activated" : "") + "\n      " + (/*selected*/ ctx[7] ? "mdc-list-item--selected" : "") + "\n      " + (/*disabled*/ ctx[8] ? "mdc-list-item--disabled" : "") + "\n    "
    		},
    		{ href: /*href*/ ctx[9] },
    		/*activated*/ ctx[5] ? { "aria-current": "page" } : {},
    		{ tabindex: /*tabindex*/ ctx[0] },
    		/*props*/ ctx[12]
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$b, 1, 2, 20);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			/*a_binding*/ ctx[26](a);
    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, a, /*use*/ ctx[1])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[13].call(null, a)),
    				action_destroyer(Ripple_action = Ripple.call(null, a, {
    					ripple: /*ripple*/ ctx[3],
    					unbounded: false,
    					color: /*color*/ ctx[4]
    				})),
    				listen_dev(a, "click", /*action*/ ctx[15], false, false, false),
    				listen_dev(a, "keydown", /*handleKeydown*/ ctx[16], false, false, false)
    			];
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 16777216) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[24], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[24], dirty, null));
    			}

    			set_attributes(a, get_spread_update(a_levels, [
    				dirty & /*className, activated, selected, disabled*/ 420 && {
    					class: "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? "mdc-list-item--activated" : "") + "\n      " + (/*selected*/ ctx[7] ? "mdc-list-item--selected" : "") + "\n      " + (/*disabled*/ ctx[8] ? "mdc-list-item--disabled" : "") + "\n    "
    				},
    				dirty & /*href*/ 512 && { href: /*href*/ ctx[9] },
    				dirty & /*activated*/ 32 && (/*activated*/ ctx[5] ? { "aria-current": "page" } : {}),
    				dirty & /*tabindex*/ 1 && { tabindex: /*tabindex*/ ctx[0] },
    				dirty & /*props*/ 4096 && /*props*/ ctx[12]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

    			if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple, color*/ 24) Ripple_action.update.call(null, {
    				ripple: /*ripple*/ ctx[3],
    				unbounded: false,
    				color: /*color*/ ctx[4]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			/*a_binding*/ ctx[26](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(1:0) {#if nav && href}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$1, create_if_block_1, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*nav*/ ctx[14] && /*href*/ ctx[9]) return 0;
    		if (/*nav*/ ctx[14] && !/*href*/ ctx[9]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let counter = 0;

    function instance$d($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let checked = false;
    	let { use = [] } = $$props;
    	let { class: className = "" } = $$props;
    	let { ripple = true } = $$props;
    	let { color = null } = $$props;
    	let { nonInteractive = getContext("SMUI:list:nonInteractive") } = $$props;
    	let { activated = false } = $$props;
    	let { role = getContext("SMUI:list:item:role") } = $$props;
    	let { selected = false } = $$props;
    	let { disabled = false } = $$props;
    	let { tabindex = !nonInteractive && !disabled && (selected || checked) && "0" || "-1" } = $$props;
    	let { href = false } = $$props;
    	let { inputId = "SMUI-form-field-list-" + counter++ } = $$props;
    	let element;
    	let addTabindexIfNoItemsSelectedRaf;
    	let nav = getContext("SMUI:list:item:nav");
    	setContext("SMUI:generic:input:props", { id: inputId });
    	setContext("SMUI:generic:input:setChecked", setChecked);

    	onMount(() => {
    		// Tabindex needs to be '0' if this is the first non-disabled list item, and
    		// no other item is selected.
    		if (!selected && !nonInteractive) {
    			let first = true;
    			let el = element;

    			while (el.previousSibling) {
    				el = el.previousSibling;

    				if (el.nodeType === 1 && el.classList.contains("mdc-list-item") && !el.classList.contains("mdc-list-item--disabled")) {
    					first = false;
    					break;
    				}
    			}

    			if (first) {
    				// This is first, so now set up a check that no other items are
    				// selected.
    				addTabindexIfNoItemsSelectedRaf = window.requestAnimationFrame(addTabindexIfNoItemsSelected);
    			}
    		}
    	});

    	onDestroy(() => {
    		if (addTabindexIfNoItemsSelectedRaf) {
    			window.cancelAnimationFrame(addTabindexIfNoItemsSelectedRaf);
    		}
    	});

    	function addTabindexIfNoItemsSelected() {
    		// Look through next siblings to see if none of them are selected.
    		let noneSelected = true;

    		let el = element;

    		while (el.nextSibling) {
    			el = el.nextSibling;

    			if (el.nodeType === 1 && el.classList.contains("mdc-list-item") && el.attributes["tabindex"] && el.attributes["tabindex"].value === "0") {
    				noneSelected = false;
    				break;
    			}
    		}

    		if (noneSelected) {
    			// This is the first element, and no other element is selected, so the
    			// tabindex should be '0'.
    			$$invalidate(0, tabindex = "0");
    		}
    	}

    	function action(e) {
    		if (disabled) {
    			e.preventDefault();
    		} else {
    			dispatch("SMUI:action", e);
    		}
    	}

    	function handleKeydown(e) {
    		const isEnter = e.key === "Enter" || e.keyCode === 13;
    		const isSpace = e.key === "Space" || e.keyCode === 32;

    		if (isEnter || isSpace) {
    			action(e);
    		}
    	}

    	function setChecked(isChecked) {
    		$$invalidate(10, checked = isChecked);
    		$$invalidate(0, tabindex = !nonInteractive && !disabled && (selected || checked) && "0" || "-1");
    	}

    	let { $$slots = {}, $$scope } = $$props;

    	function a_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(11, element = $$value);
    		});
    	}

    	function span_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(11, element = $$value);
    		});
    	}

    	function li_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(11, element = $$value);
    		});
    	}

    	$$self.$set = $$new_props => {
    		$$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("ripple" in $$new_props) $$invalidate(3, ripple = $$new_props.ripple);
    		if ("color" in $$new_props) $$invalidate(4, color = $$new_props.color);
    		if ("nonInteractive" in $$new_props) $$invalidate(17, nonInteractive = $$new_props.nonInteractive);
    		if ("activated" in $$new_props) $$invalidate(5, activated = $$new_props.activated);
    		if ("role" in $$new_props) $$invalidate(6, role = $$new_props.role);
    		if ("selected" in $$new_props) $$invalidate(7, selected = $$new_props.selected);
    		if ("disabled" in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
    		if ("tabindex" in $$new_props) $$invalidate(0, tabindex = $$new_props.tabindex);
    		if ("href" in $$new_props) $$invalidate(9, href = $$new_props.href);
    		if ("inputId" in $$new_props) $$invalidate(18, inputId = $$new_props.inputId);
    		if ("$$scope" in $$new_props) $$invalidate(24, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			counter,
    			checked,
    			use,
    			className,
    			ripple,
    			color,
    			nonInteractive,
    			activated,
    			role,
    			selected,
    			disabled,
    			tabindex,
    			href,
    			inputId,
    			element,
    			addTabindexIfNoItemsSelectedRaf,
    			nav,
    			props
    		};
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    		if ("checked" in $$props) $$invalidate(10, checked = $$new_props.checked);
    		if ("use" in $$props) $$invalidate(1, use = $$new_props.use);
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("ripple" in $$props) $$invalidate(3, ripple = $$new_props.ripple);
    		if ("color" in $$props) $$invalidate(4, color = $$new_props.color);
    		if ("nonInteractive" in $$props) $$invalidate(17, nonInteractive = $$new_props.nonInteractive);
    		if ("activated" in $$props) $$invalidate(5, activated = $$new_props.activated);
    		if ("role" in $$props) $$invalidate(6, role = $$new_props.role);
    		if ("selected" in $$props) $$invalidate(7, selected = $$new_props.selected);
    		if ("disabled" in $$props) $$invalidate(8, disabled = $$new_props.disabled);
    		if ("tabindex" in $$props) $$invalidate(0, tabindex = $$new_props.tabindex);
    		if ("href" in $$props) $$invalidate(9, href = $$new_props.href);
    		if ("inputId" in $$props) $$invalidate(18, inputId = $$new_props.inputId);
    		if ("element" in $$props) $$invalidate(11, element = $$new_props.element);
    		if ("addTabindexIfNoItemsSelectedRaf" in $$props) addTabindexIfNoItemsSelectedRaf = $$new_props.addTabindexIfNoItemsSelectedRaf;
    		if ("nav" in $$props) $$invalidate(14, nav = $$new_props.nav);
    		if ("props" in $$props) $$invalidate(12, props = $$new_props.props);
    	};

    	let props;

    	$$self.$$.update = () => {
    		 $$invalidate(12, props = exclude($$props, [
    			"use",
    			"class",
    			"ripple",
    			"color",
    			"nonInteractive",
    			"activated",
    			"selected",
    			"disabled",
    			"tabindex",
    			"href",
    			"inputId"
    		]));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		tabindex,
    		use,
    		className,
    		ripple,
    		color,
    		activated,
    		role,
    		selected,
    		disabled,
    		href,
    		checked,
    		element,
    		props,
    		forwardEvents,
    		nav,
    		action,
    		handleKeydown,
    		nonInteractive,
    		inputId,
    		addTabindexIfNoItemsSelectedRaf,
    		dispatch,
    		addTabindexIfNoItemsSelected,
    		setChecked,
    		$$props,
    		$$scope,
    		$$slots,
    		a_binding,
    		span_binding,
    		li_binding
    	];
    }

    class Item extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
    			use: 1,
    			class: 2,
    			ripple: 3,
    			color: 4,
    			nonInteractive: 17,
    			activated: 5,
    			role: 6,
    			selected: 7,
    			disabled: 8,
    			tabindex: 0,
    			href: 9,
    			inputId: 18
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Item",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get use() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ripple() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ripple(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nonInteractive() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nonInteractive(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activated() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activated(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get role() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set role(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputId() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputId(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\common\Span.svelte generated by Svelte v3.18.1 */
    const file$c = "node_modules\\@smui\\common\\Span.svelte";

    function create_fragment$e(ctx) {
    	let span;
    	let useActions_action;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let span_levels = [exclude(/*$$props*/ ctx[2], ["use"])];
    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			set_attributes(span, span_data);
    			add_location(span, file$c, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[1].call(null, span))
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 8) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[3], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null));
    			}

    			set_attributes(span, get_spread_update(span_levels, [dirty & /*exclude, $$props*/ 4 && exclude(/*$$props*/ ctx[2], ["use"])]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { use = [] } = $$props;
    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return { use };
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    	};

    	$$props = exclude_internal_props($$props);
    	return [use, forwardEvents, $$props, $$scope, $$slots];
    }

    class Span extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { use: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Span",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get use() {
    		throw new Error("<Span>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Text = classAdderBuilder({
      class: 'mdc-list-item__text',
      component: Span,
      contexts: {}
    });

    classAdderBuilder({
      class: 'mdc-list-item__primary-text',
      component: Span,
      contexts: {}
    });

    classAdderBuilder({
      class: 'mdc-list-item__secondary-text',
      component: Span,
      contexts: {}
    });

    var Graphic = classAdderBuilder({
      class: 'mdc-list-item__graphic',
      component: Span,
      contexts: {}
    });

    classAdderBuilder({
      class: 'mdc-list-item__meta',
      component: Span,
      contexts: {}
    });

    classAdderBuilder({
      class: 'mdc-list-group',
      component: Div,
      contexts: {}
    });

    /* node_modules\@smui\common\H3.svelte generated by Svelte v3.18.1 */
    const file$d = "node_modules\\@smui\\common\\H3.svelte";

    function create_fragment$f(ctx) {
    	let h3;
    	let useActions_action;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let h3_levels = [exclude(/*$$props*/ ctx[2], ["use"])];
    	let h3_data = {};

    	for (let i = 0; i < h3_levels.length; i += 1) {
    		h3_data = assign(h3_data, h3_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			if (default_slot) default_slot.c();
    			set_attributes(h3, h3_data);
    			add_location(h3, file$d, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);

    			if (default_slot) {
    				default_slot.m(h3, null);
    			}

    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, h3, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[1].call(null, h3))
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 8) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[3], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null));
    			}

    			set_attributes(h3, get_spread_update(h3_levels, [dirty & /*exclude, $$props*/ 4 && exclude(/*$$props*/ ctx[2], ["use"])]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (default_slot) default_slot.d(detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { use = [] } = $$props;
    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return { use };
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    	};

    	$$props = exclude_internal_props($$props);
    	return [use, forwardEvents, $$props, $$scope, $$slots];
    }

    class H3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { use: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "H3",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get use() {
    		throw new Error("<H3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<H3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    classAdderBuilder({
      class: 'mdc-list-group__subheader',
      component: H3,
      contexts: {}
    });

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings$5 = {
        NATIVE_CONTROL_SELECTOR: '.mdc-radio__native-control',
    };
    var cssClasses$4 = {
        DISABLED: 'mdc-radio--disabled',
        ROOT: 'mdc-radio',
    };
    //# sourceMappingURL=constants.js.map

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCRadioFoundation = /** @class */ (function (_super) {
        __extends(MDCRadioFoundation, _super);
        function MDCRadioFoundation(adapter) {
            return _super.call(this, __assign({}, MDCRadioFoundation.defaultAdapter, adapter)) || this;
        }
        Object.defineProperty(MDCRadioFoundation, "cssClasses", {
            get: function () {
                return cssClasses$4;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRadioFoundation, "strings", {
            get: function () {
                return strings$5;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRadioFoundation, "defaultAdapter", {
            get: function () {
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    setNativeControlDisabled: function () { return undefined; },
                };
            },
            enumerable: true,
            configurable: true
        });
        MDCRadioFoundation.prototype.setDisabled = function (disabled) {
            var DISABLED = MDCRadioFoundation.cssClasses.DISABLED;
            this.adapter_.setNativeControlDisabled(disabled);
            if (disabled) {
                this.adapter_.addClass(DISABLED);
            }
            else {
                this.adapter_.removeClass(DISABLED);
            }
        };
        return MDCRadioFoundation;
    }(MDCFoundation));
    //# sourceMappingURL=foundation.js.map

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCRadio = /** @class */ (function (_super) {
        __extends(MDCRadio, _super);
        function MDCRadio() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.ripple_ = _this.createRipple_();
            return _this;
        }
        MDCRadio.attachTo = function (root) {
            return new MDCRadio(root);
        };
        Object.defineProperty(MDCRadio.prototype, "checked", {
            get: function () {
                return this.nativeControl_.checked;
            },
            set: function (checked) {
                this.nativeControl_.checked = checked;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRadio.prototype, "disabled", {
            get: function () {
                return this.nativeControl_.disabled;
            },
            set: function (disabled) {
                this.foundation_.setDisabled(disabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRadio.prototype, "value", {
            get: function () {
                return this.nativeControl_.value;
            },
            set: function (value) {
                this.nativeControl_.value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRadio.prototype, "ripple", {
            get: function () {
                return this.ripple_;
            },
            enumerable: true,
            configurable: true
        });
        MDCRadio.prototype.destroy = function () {
            this.ripple_.destroy();
            _super.prototype.destroy.call(this);
        };
        MDCRadio.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            var adapter = {
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                setNativeControlDisabled: function (disabled) { return _this.nativeControl_.disabled = disabled; },
            };
            return new MDCRadioFoundation(adapter);
        };
        MDCRadio.prototype.createRipple_ = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = __assign({}, MDCRipple.createAdapter(this), { registerInteractionHandler: function (evtType, handler) { return _this.nativeControl_.addEventListener(evtType, handler, applyPassive()); }, deregisterInteractionHandler: function (evtType, handler) { return _this.nativeControl_.removeEventListener(evtType, handler, applyPassive()); }, 
                // Radio buttons technically go "active" whenever there is *any* keyboard interaction.
                // This is not the UI we desire.
                isSurfaceActive: function () { return false; }, isUnbounded: function () { return true; } });
            // tslint:enable:object-literal-sort-keys
            return new MDCRipple(this.root_, new MDCRippleFoundation(adapter));
        };
        Object.defineProperty(MDCRadio.prototype, "nativeControl_", {
            get: function () {
                var NATIVE_CONTROL_SELECTOR = MDCRadioFoundation.strings.NATIVE_CONTROL_SELECTOR;
                var el = this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
                if (!el) {
                    throw new Error("Radio component requires a " + NATIVE_CONTROL_SELECTOR + " element");
                }
                return el;
            },
            enumerable: true,
            configurable: true
        });
        return MDCRadio;
    }(MDCComponent));
    //# sourceMappingURL=component.js.map

    function prefixFilter(obj, prefix) {
      let names = Object.getOwnPropertyNames(obj);
      const newObj = {};

      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        if (name.substring(0, prefix.length) === prefix) {
          newObj[name.substring(prefix.length)] = obj[name];
        }
      }

      return newObj;
    }

    /* node_modules\@smui\radio\Radio.svelte generated by Svelte v3.18.1 */
    const file$e = "node_modules\\@smui\\radio\\Radio.svelte";

    function create_fragment$g(ctx) {
    	let div3;
    	let input;
    	let useActions_action;
    	let t0;
    	let div2;
    	let div0;
    	let t1;
    	let div1;
    	let useActions_action_1;
    	let forwardEvents_action;
    	let dispose;

    	let input_levels = [
    		{
    			class: "mdc-radio__native-control " + /*input$class*/ ctx[6]
    		},
    		{ type: "radio" },
    		/*inputProps*/ ctx[11],
    		{ disabled: /*disabled*/ ctx[2] },
    		{
    			value: /*valueKey*/ ctx[4] === /*uninitializedValue*/ ctx[10]
    			? /*value*/ ctx[3]
    			: /*valueKey*/ ctx[4]
    		},
    		{ checked: /*checked*/ ctx[8] },
    		exclude(prefixFilter(/*$$props*/ ctx[13], "input$"), ["use", "class"])
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	let div3_levels = [
    		{
    			class: "\n    mdc-radio\n    " + /*className*/ ctx[1] + "\n    " + (/*disabled*/ ctx[2] ? "mdc-radio--disabled" : "") + "\n  "
    		},
    		exclude(/*$$props*/ ctx[13], ["use", "class", "disabled", "group", "value", "valueKey", "input$"])
    	];

    	let div3_data = {};

    	for (let i = 0; i < div3_levels.length; i += 1) {
    		div3_data = assign(div3_data, div3_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			input = element("input");
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			t1 = space();
    			div1 = element("div");
    			set_attributes(input, input_data);
    			add_location(input, file$e, 11, 2, 256);
    			attr_dev(div0, "class", "mdc-radio__outer-circle");
    			add_location(div0, file$e, 24, 4, 642);
    			attr_dev(div1, "class", "mdc-radio__inner-circle");
    			add_location(div1, file$e, 25, 4, 690);
    			attr_dev(div2, "class", "mdc-radio__background");
    			add_location(div2, file$e, 23, 2, 602);
    			set_attributes(div3, div3_data);
    			add_location(div3, file$e, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, input);
    			append_dev(div3, t0);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			/*div3_binding*/ ctx[21](div3);

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, input, /*input$use*/ ctx[5])),
    				listen_dev(input, "change", /*handleChange*/ ctx[12], false, false, false),
    				listen_dev(input, "change", /*change_handler*/ ctx[19], false, false, false),
    				listen_dev(input, "input", /*input_handler*/ ctx[20], false, false, false),
    				action_destroyer(useActions_action_1 = useActions.call(null, div3, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[9].call(null, div3))
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			set_attributes(input, get_spread_update(input_levels, [
    				dirty & /*input$class*/ 64 && {
    					class: "mdc-radio__native-control " + /*input$class*/ ctx[6]
    				},
    				{ type: "radio" },
    				dirty & /*inputProps*/ 2048 && /*inputProps*/ ctx[11],
    				dirty & /*disabled*/ 4 && { disabled: /*disabled*/ ctx[2] },
    				dirty & /*valueKey, uninitializedValue, value*/ 1048 && {
    					value: /*valueKey*/ ctx[4] === /*uninitializedValue*/ ctx[10]
    					? /*value*/ ctx[3]
    					: /*valueKey*/ ctx[4]
    				},
    				dirty & /*checked*/ 256 && { checked: /*checked*/ ctx[8] },
    				dirty & /*exclude, prefixFilter, $$props*/ 8192 && exclude(prefixFilter(/*$$props*/ ctx[13], "input$"), ["use", "class"])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*input$use*/ 32) useActions_action.update.call(null, /*input$use*/ ctx[5]);

    			set_attributes(div3, get_spread_update(div3_levels, [
    				dirty & /*className, disabled*/ 6 && {
    					class: "\n    mdc-radio\n    " + /*className*/ ctx[1] + "\n    " + (/*disabled*/ ctx[2] ? "mdc-radio--disabled" : "") + "\n  "
    				},
    				dirty & /*exclude, $$props*/ 8192 && exclude(/*$$props*/ ctx[13], ["use", "class", "disabled", "group", "value", "valueKey", "input$"])
    			]));

    			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			/*div3_binding*/ ctx[21](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component);

    	let uninitializedValue = () => {
    		
    	};

    	let { use = [] } = $$props;
    	let { class: className = "" } = $$props;
    	let { disabled = false } = $$props;
    	let { group = null } = $$props;
    	let { value = null } = $$props;
    	let { valueKey = uninitializedValue } = $$props;
    	let { input$use = [] } = $$props;
    	let { input$class = "" } = $$props;
    	let element;
    	let radio;
    	let formField = getContext("SMUI:form-field");
    	let inputProps = getContext("SMUI:generic:input:props") || {};
    	let setChecked = getContext("SMUI:generic:input:setChecked");

    	onMount(() => {
    		$$invalidate(16, radio = new MDCRadio(element));

    		if (formField && formField()) {
    			formField().input = radio;
    		}
    	});

    	onDestroy(() => {
    		radio && radio.destroy();
    	});

    	function handleChange(e) {
    		if (radio.checked) {
    			$$invalidate(14, group = value);
    		}
    	}

    	function getId() {
    		return inputProps && inputProps.id;
    	}

    	function change_handler(event) {
    		bubble($$self, event);
    	}

    	function input_handler(event) {
    		bubble($$self, event);
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(7, element = $$value);
    		});
    	}

    	$$self.$set = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ("group" in $$new_props) $$invalidate(14, group = $$new_props.group);
    		if ("value" in $$new_props) $$invalidate(3, value = $$new_props.value);
    		if ("valueKey" in $$new_props) $$invalidate(4, valueKey = $$new_props.valueKey);
    		if ("input$use" in $$new_props) $$invalidate(5, input$use = $$new_props.input$use);
    		if ("input$class" in $$new_props) $$invalidate(6, input$class = $$new_props.input$class);
    	};

    	$$self.$capture_state = () => {
    		return {
    			uninitializedValue,
    			use,
    			className,
    			disabled,
    			group,
    			value,
    			valueKey,
    			input$use,
    			input$class,
    			element,
    			radio,
    			formField,
    			inputProps,
    			setChecked,
    			checked
    		};
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    		if ("uninitializedValue" in $$props) $$invalidate(10, uninitializedValue = $$new_props.uninitializedValue);
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
    		if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ("group" in $$props) $$invalidate(14, group = $$new_props.group);
    		if ("value" in $$props) $$invalidate(3, value = $$new_props.value);
    		if ("valueKey" in $$props) $$invalidate(4, valueKey = $$new_props.valueKey);
    		if ("input$use" in $$props) $$invalidate(5, input$use = $$new_props.input$use);
    		if ("input$class" in $$props) $$invalidate(6, input$class = $$new_props.input$class);
    		if ("element" in $$props) $$invalidate(7, element = $$new_props.element);
    		if ("radio" in $$props) $$invalidate(16, radio = $$new_props.radio);
    		if ("formField" in $$props) formField = $$new_props.formField;
    		if ("inputProps" in $$props) $$invalidate(11, inputProps = $$new_props.inputProps);
    		if ("setChecked" in $$props) $$invalidate(18, setChecked = $$new_props.setChecked);
    		if ("checked" in $$props) $$invalidate(8, checked = $$new_props.checked);
    	};

    	let checked;

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*group, value*/ 16392) {
    			 $$invalidate(8, checked = group === value);
    		}

    		if ($$self.$$.dirty & /*checked*/ 256) {
    			 if (setChecked) {
    				setChecked(checked);
    			}
    		}

    		if ($$self.$$.dirty & /*radio, checked*/ 65792) {
    			 if (radio && radio.checked !== checked) {
    				$$invalidate(16, radio.checked = checked, radio);
    			}
    		}

    		if ($$self.$$.dirty & /*radio, disabled*/ 65540) {
    			 if (radio && radio.disabled !== disabled) {
    				$$invalidate(16, radio.disabled = disabled, radio);
    			}
    		}

    		if ($$self.$$.dirty & /*radio, valueKey, value*/ 65560) {
    			 if (radio && valueKey === uninitializedValue && radio.value !== value) {
    				$$invalidate(16, radio.value = value, radio);
    			}
    		}

    		if ($$self.$$.dirty & /*radio, valueKey*/ 65552) {
    			 if (radio && valueKey !== uninitializedValue && radio.value !== valueKey) {
    				$$invalidate(16, radio.value = valueKey, radio);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		disabled,
    		value,
    		valueKey,
    		input$use,
    		input$class,
    		element,
    		checked,
    		forwardEvents,
    		uninitializedValue,
    		inputProps,
    		handleChange,
    		$$props,
    		group,
    		getId,
    		radio,
    		formField,
    		setChecked,
    		change_handler,
    		input_handler,
    		div3_binding
    	];
    }

    class Radio extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
    			use: 0,
    			class: 1,
    			disabled: 2,
    			group: 14,
    			value: 3,
    			valueKey: 4,
    			input$use: 5,
    			input$class: 6,
    			getId: 15
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Radio",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get use() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valueKey() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valueKey(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input$use() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input$use(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input$class() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input$class(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getId() {
    		return this.$$.ctx[15];
    	}

    	set getId(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Theme.svelte generated by Svelte v3.18.1 */
    const file$f = "src\\components\\Theme.svelte";

    // (73:6) <Title id="list-selection-title">
    function create_default_slot_18(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Theme");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18.name,
    		type: "slot",
    		source: "(73:6) <Title id=\\\"list-selection-title\\\">",
    		ctx
    	});

    	return block;
    }

    // (77:12) <Graphic>
    function create_default_slot_17(ctx) {
    	let updating_group;
    	let current;

    	function radio_group_binding(value) {
    		/*radio_group_binding*/ ctx[4].call(null, value);
    	}

    	let radio_props = { value: "dark" };

    	if (/*selection*/ ctx[1] !== void 0) {
    		radio_props.group = /*selection*/ ctx[1];
    	}

    	const radio = new Radio({ props: radio_props, $$inline: true });
    	binding_callbacks.push(() => bind(radio, "group", radio_group_binding));

    	const block = {
    		c: function create() {
    			create_component(radio.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(radio, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const radio_changes = {};

    			if (!updating_group && dirty & /*selection*/ 2) {
    				updating_group = true;
    				radio_changes.group = /*selection*/ ctx[1];
    				add_flush_callback(() => updating_group = false);
    			}

    			radio.$set(radio_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(radio.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(radio.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(radio, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17.name,
    		type: "slot",
    		source: "(77:12) <Graphic>",
    		ctx
    	});

    	return block;
    }

    // (80:12) <Text>
    function create_default_slot_16(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Dark");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16.name,
    		type: "slot",
    		source: "(80:12) <Text>",
    		ctx
    	});

    	return block;
    }

    // (76:10) <Item >
    function create_default_slot_15(ctx) {
    	let t;
    	let current;

    	const graphic = new Graphic({
    			props: {
    				$$slots: { default: [create_default_slot_17] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const text_1 = new Text({
    			props: {
    				$$slots: { default: [create_default_slot_16] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    			t = space();
    			create_component(text_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(text_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const graphic_changes = {};

    			if (dirty & /*$$scope, selection*/ 514) {
    				graphic_changes.$$scope = { dirty, ctx };
    			}

    			graphic.$set(graphic_changes);
    			const text_1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				text_1_changes.$$scope = { dirty, ctx };
    			}

    			text_1.$set(text_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(text_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15.name,
    		type: "slot",
    		source: "(76:10) <Item >",
    		ctx
    	});

    	return block;
    }

    // (83:12) <Graphic>
    function create_default_slot_14(ctx) {
    	let updating_group;
    	let current;

    	function radio_group_binding_1(value) {
    		/*radio_group_binding_1*/ ctx[5].call(null, value);
    	}

    	let radio_props = { value: "light" };

    	if (/*selection*/ ctx[1] !== void 0) {
    		radio_props.group = /*selection*/ ctx[1];
    	}

    	const radio = new Radio({ props: radio_props, $$inline: true });
    	binding_callbacks.push(() => bind(radio, "group", radio_group_binding_1));

    	const block = {
    		c: function create() {
    			create_component(radio.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(radio, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const radio_changes = {};

    			if (!updating_group && dirty & /*selection*/ 2) {
    				updating_group = true;
    				radio_changes.group = /*selection*/ ctx[1];
    				add_flush_callback(() => updating_group = false);
    			}

    			radio.$set(radio_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(radio.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(radio.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(radio, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14.name,
    		type: "slot",
    		source: "(83:12) <Graphic>",
    		ctx
    	});

    	return block;
    }

    // (86:12) <Text>
    function create_default_slot_13(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Light");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13.name,
    		type: "slot",
    		source: "(86:12) <Text>",
    		ctx
    	});

    	return block;
    }

    // (82:10) <Item>
    function create_default_slot_12(ctx) {
    	let t;
    	let current;

    	const graphic = new Graphic({
    			props: {
    				$$slots: { default: [create_default_slot_14] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const text_1 = new Text({
    			props: {
    				$$slots: { default: [create_default_slot_13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    			t = space();
    			create_component(text_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(text_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const graphic_changes = {};

    			if (dirty & /*$$scope, selection*/ 514) {
    				graphic_changes.$$scope = { dirty, ctx };
    			}

    			graphic.$set(graphic_changes);
    			const text_1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				text_1_changes.$$scope = { dirty, ctx };
    			}

    			text_1.$set(text_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(text_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(82:10) <Item>",
    		ctx
    	});

    	return block;
    }

    // (89:12) <Graphic>
    function create_default_slot_11(ctx) {
    	let updating_group;
    	let current;

    	function radio_group_binding_2(value) {
    		/*radio_group_binding_2*/ ctx[6].call(null, value);
    	}

    	let radio_props = { value: "pink" };

    	if (/*selection*/ ctx[1] !== void 0) {
    		radio_props.group = /*selection*/ ctx[1];
    	}

    	const radio = new Radio({ props: radio_props, $$inline: true });
    	binding_callbacks.push(() => bind(radio, "group", radio_group_binding_2));

    	const block = {
    		c: function create() {
    			create_component(radio.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(radio, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const radio_changes = {};

    			if (!updating_group && dirty & /*selection*/ 2) {
    				updating_group = true;
    				radio_changes.group = /*selection*/ ctx[1];
    				add_flush_callback(() => updating_group = false);
    			}

    			radio.$set(radio_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(radio.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(radio.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(radio, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(89:12) <Graphic>",
    		ctx
    	});

    	return block;
    }

    // (92:12) <Text>
    function create_default_slot_10(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Pink");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(92:12) <Text>",
    		ctx
    	});

    	return block;
    }

    // (88:10) <Item>
    function create_default_slot_9(ctx) {
    	let t;
    	let current;

    	const graphic = new Graphic({
    			props: {
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const text_1 = new Text({
    			props: {
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphic.$$.fragment);
    			t = space();
    			create_component(text_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphic, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(text_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const graphic_changes = {};

    			if (dirty & /*$$scope, selection*/ 514) {
    				graphic_changes.$$scope = { dirty, ctx };
    			}

    			graphic.$set(graphic_changes);
    			const text_1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				text_1_changes.$$scope = { dirty, ctx };
    			}

    			text_1.$set(text_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphic.$$.fragment, local);
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphic.$$.fragment, local);
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphic, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(text_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(88:10) <Item>",
    		ctx
    	});

    	return block;
    }

    // (75:8) <List radioList>
    function create_default_slot_8(ctx) {
    	let t0;
    	let t1;
    	let current;

    	const item0 = new Item({
    			props: {
    				$$slots: { default: [create_default_slot_15] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const item1 = new Item({
    			props: {
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const item2 = new Item({
    			props: {
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(item0.$$.fragment);
    			t0 = space();
    			create_component(item1.$$.fragment);
    			t1 = space();
    			create_component(item2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(item0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(item1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(item2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const item0_changes = {};

    			if (dirty & /*$$scope, selection*/ 514) {
    				item0_changes.$$scope = { dirty, ctx };
    			}

    			item0.$set(item0_changes);
    			const item1_changes = {};

    			if (dirty & /*$$scope, selection*/ 514) {
    				item1_changes.$$scope = { dirty, ctx };
    			}

    			item1.$set(item1_changes);
    			const item2_changes = {};

    			if (dirty & /*$$scope, selection*/ 514) {
    				item2_changes.$$scope = { dirty, ctx };
    			}

    			item2.$set(item2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(item0.$$.fragment, local);
    			transition_in(item1.$$.fragment, local);
    			transition_in(item2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(item0.$$.fragment, local);
    			transition_out(item1.$$.fragment, local);
    			transition_out(item2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(item0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(item1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(item2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(75:8) <List radioList>",
    		ctx
    	});

    	return block;
    }

    // (74:6) <Content id="list-selection-content">
    function create_default_slot_7(ctx) {
    	let current;

    	const list = new List({
    			props: {
    				radioList: true,
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(list.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(list, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const list_changes = {};

    			if (dirty & /*$$scope, selection*/ 514) {
    				list_changes.$$scope = { dirty, ctx };
    			}

    			list.$set(list_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(list.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(list.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(list, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(74:6) <Content id=\\\"list-selection-content\\\">",
    		ctx
    	});

    	return block;
    }

    // (98:10) <Label>
    function create_default_slot_6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancel");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(98:10) <Label>",
    		ctx
    	});

    	return block;
    }

    // (97:8) <Button>
    function create_default_slot_5(ctx) {
    	let current;

    	const label = new Label({
    			props: {
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const label_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				label_changes.$$scope = { dirty, ctx };
    			}

    			label.$set(label_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(97:8) <Button>",
    		ctx
    	});

    	return block;
    }

    // (101:10) <Label>
    function create_default_slot_4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Accept");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(101:10) <Label>",
    		ctx
    	});

    	return block;
    }

    // (100:8) <Button action="accept">
    function create_default_slot_3(ctx) {
    	let current;

    	const label = new Label({
    			props: {
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const label_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				label_changes.$$scope = { dirty, ctx };
    			}

    			label.$set(label_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(100:8) <Button action=\\\"accept\\\">",
    		ctx
    	});

    	return block;
    }

    // (96:6) <Actions>
    function create_default_slot_2(ctx) {
    	let t;
    	let current;

    	const button0 = new Button_1({
    			props: {
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const button1 = new Button_1({
    			props: {
    				action: "accept",
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t = space();
    			create_component(button1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(button1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(button1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(96:6) <Actions>",
    		ctx
    	});

    	return block;
    }

    // (67:4) <Dialog       bind:this={listSelectionDialog}      aria-labelledby="list-selection-title"       aria-describedby="list-selection-content"       on:MDCDialog:closed={selectionCloseHandler}>
    function create_default_slot_1(ctx) {
    	let t0;
    	let t1;
    	let current;

    	const title = new Title({
    			props: {
    				id: "list-selection-title",
    				$$slots: { default: [create_default_slot_18] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const content = new Content({
    			props: {
    				id: "list-selection-content",
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const actions = new Actions({
    			props: {
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(title.$$.fragment);
    			t0 = space();
    			create_component(content.$$.fragment);
    			t1 = space();
    			create_component(actions.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(title, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(content, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(actions, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const title_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				title_changes.$$scope = { dirty, ctx };
    			}

    			title.$set(title_changes);
    			const content_changes = {};

    			if (dirty & /*$$scope, selection*/ 514) {
    				content_changes.$$scope = { dirty, ctx };
    			}

    			content.$set(content_changes);
    			const actions_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				actions_changes.$$scope = { dirty, ctx };
    			}

    			actions.$set(actions_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title.$$.fragment, local);
    			transition_in(content.$$.fragment, local);
    			transition_in(actions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title.$$.fragment, local);
    			transition_out(content.$$.fragment, local);
    			transition_out(actions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(title, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(content, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(actions, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(67:4) <Dialog       bind:this={listSelectionDialog}      aria-labelledby=\\\"list-selection-title\\\"       aria-describedby=\\\"list-selection-content\\\"       on:MDCDialog:closed={selectionCloseHandler}>",
    		ctx
    	});

    	return block;
    }

    // (106:4) <Button on:click={() => listSelectionDialog.open()}>
    function create_default_slot$2(ctx) {
    	let h4;

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "Theme";
    			attr_dev(h4, "class", "svelte-11h90ix");
    			add_location(h4, file$f, 105, 56, 3150);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(106:4) <Button on:click={() => listSelectionDialog.open()}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let div;
    	let t;
    	let current;

    	let dialog_props = {
    		"aria-labelledby": "list-selection-title",
    		"aria-describedby": "list-selection-content",
    		$$slots: { default: [create_default_slot_1] },
    		$$scope: { ctx }
    	};

    	const dialog = new Dialog({ props: dialog_props, $$inline: true });
    	/*dialog_binding*/ ctx[7](dialog);
    	dialog.$on("MDCDialog:closed", /*selectionCloseHandler*/ ctx[2]);

    	const button = new Button_1({
    			props: {
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[8]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(dialog.$$.fragment);
    			t = space();
    			create_component(button.$$.fragment);
    			add_location(div, file$f, 63, 1, 1984);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(dialog, div, null);
    			append_dev(div, t);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const dialog_changes = {};

    			if (dirty & /*$$scope, selection*/ 514) {
    				dialog_changes.$$scope = { dirty, ctx };
    			}

    			dialog.$set(dialog_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialog.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialog.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*dialog_binding*/ ctx[7](null);
    			destroy_component(dialog);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function userprefer() {
    	if (document.cookie) {
    		var cookieTheme = document.cookie.replace(/(?:(?:^|.*;\s*)theme\s*\=\s*([^;]*).*$)|^.*$/, "$1");
    		console.log(cookieTheme);
    		chgtheme(cookieTheme);
    		return cookieTheme;
    	} else {
    		return "";
    	}
    }

    function addUserprefer(item) {
    	document.cookie = "theme=" + item;
    }

    function chgtheme(color) {
    	let root = document.documentElement;

    	function theme(property, val) {
    		root.style.setProperty(property, val);
    	}

    	if (color === "light") {
    		theme("--default-bg-color", "white");
    		theme("--default-text-color", " #5D6D7E");
    		theme("--default-user-color", " #5D6D7E");
    		theme("--default-span-color", "#0074D9");
    	} else if (color === "dark") {
    		theme("--default-bg-color", "#5D6D7E");
    		theme("--default-text-color", "#c2c2c2");
    		theme("--default-span-color", "#283747");
    	} else if (color === "pink") {
    		theme("--default-bg-color", "\t#FFB6C1");
    		theme("--default-span-color", "#e65f5f");
    		theme("--default-text-color", " white");
    		theme("--default-othertext-color", "#5D6D7E");
    		theme("--default-user-color", " white");
    		theme("--default-otherspan-color", "#eee");
    	}
    }

    function instance$h($$self, $$props, $$invalidate) {
    	
    	

    	function selectionCloseHandler(e) {
    		if (e.detail.action === "accept") {
    			selected = selection;
    			chgtheme(selected);
    		}
    	}

    	
    	let listSelectionDialog;
    	let selection;
    	let selected;

    	function radio_group_binding(value) {
    		selection = value;
    		$$invalidate(1, selection);
    	}

    	function radio_group_binding_1(value) {
    		selection = value;
    		$$invalidate(1, selection);
    	}

    	function radio_group_binding_2(value) {
    		selection = value;
    		$$invalidate(1, selection);
    	}

    	function dialog_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(0, listSelectionDialog = $$value);
    		});
    	}

    	const click_handler = () => listSelectionDialog.open();

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("listSelectionDialog" in $$props) $$invalidate(0, listSelectionDialog = $$props.listSelectionDialog);
    		if ("selection" in $$props) $$invalidate(1, selection = $$props.selection);
    		if ("selected" in $$props) selected = $$props.selected;
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*selection*/ 2) {
    			 addUserprefer(selection);
    		}
    	};

    	 $$invalidate(1, selection = userprefer());

    	return [
    		listSelectionDialog,
    		selection,
    		selectionCloseHandler,
    		selected,
    		radio_group_binding,
    		radio_group_binding_1,
    		radio_group_binding_2,
    		dialog_binding,
    		click_handler
    	];
    }

    class Theme extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Theme",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src\components\Headdiv.svelte generated by Svelte v3.18.1 */
    const file$g = "src\\components\\Headdiv.svelte";

    function create_fragment$i(ctx) {
    	let div0;
    	let h1;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let div2;
    	let div1;
    	let p0;
    	let t5;
    	let p1;
    	let t7;
    	let p2;
    	let t9;
    	let div4;
    	let center;
    	let label;
    	let h4;
    	let t11;
    	let input;
    	let t12;
    	let div3;
    	let current;
    	let dispose;
    	const theme = new Theme({ $$inline: true });

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			h1 = element("h1");
    			t0 = text("Hello ");
    			t1 = text(/*name*/ ctx[0]);
    			t2 = text(" !");
    			t3 = space();
    			div2 = element("div");
    			div1 = element("div");
    			p0 = element("p");
    			p0.textContent = "* Please insert your name as your username";
    			t5 = space();
    			p1 = element("p");
    			p1.textContent = "* This is an open chat";
    			t7 = space();
    			p2 = element("p");
    			p2.textContent = "* AI bot in trainning. Currently offline.";
    			t9 = space();
    			div4 = element("div");
    			center = element("center");
    			label = element("label");
    			h4 = element("h4");
    			h4.textContent = "Name:";
    			t11 = space();
    			input = element("input");
    			t12 = space();
    			div3 = element("div");
    			create_component(theme.$$.fragment);
    			attr_dev(h1, "class", "svelte-1hjznpi");
    			add_location(h1, file$g, 99, 20, 2835);
    			attr_dev(div0, "class", "title svelte-1hjznpi");
    			add_location(div0, file$g, 99, 0, 2815);
    			attr_dev(p0, "class", "svelte-1hjznpi");
    			add_location(p0, file$g, 102, 1, 2916);
    			attr_dev(p1, "class", "svelte-1hjznpi");
    			add_location(p1, file$g, 103, 1, 2968);
    			attr_dev(p2, "class", "svelte-1hjznpi");
    			add_location(p2, file$g, 104, 1, 3000);
    			attr_dev(div1, "class", "side_note svelte-1hjznpi");
    			add_location(div1, file$g, 101, 0, 2890);
    			attr_dev(div2, "id", "typewriter");
    			attr_dev(div2, "class", "svelte-1hjznpi");
    			add_location(div2, file$g, 100, 0, 2866);
    			attr_dev(h4, "class", "svelte-1hjznpi");
    			add_location(h4, file$g, 108, 16, 3105);
    			attr_dev(label, "class", "svelte-1hjznpi");
    			add_location(label, file$g, 108, 9, 3098);
    			add_location(center, file$g, 108, 1, 3090);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "user_input svelte-1hjznpi");
    			add_location(input, file$g, 109, 1, 3140);
    			attr_dev(div3, "class", "theme");
    			add_location(div3, file$g, 110, 1, 3200);
    			attr_dev(div4, "class", "headdiv svelte-1hjznpi");
    			add_location(div4, file$g, 107, 0, 3066);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h1);
    			append_dev(h1, t0);
    			append_dev(h1, t1);
    			append_dev(h1, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, p0);
    			append_dev(div1, t5);
    			append_dev(div1, p1);
    			append_dev(div1, t7);
    			append_dev(div1, p2);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, center);
    			append_dev(center, label);
    			append_dev(label, h4);
    			append_dev(div4, t11);
    			append_dev(div4, input);
    			set_input_value(input, /*name*/ ctx[0]);
    			append_dev(div4, t12);
    			append_dev(div4, div3);
    			mount_component(theme, div3, null);
    			current = true;
    			dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[1]);
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*name*/ 1) set_data_dev(t1, /*name*/ ctx[0]);

    			if (dirty & /*name*/ 1 && input.value !== /*name*/ ctx[0]) {
    				set_input_value(input, /*name*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(theme.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(theme.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div4);
    			destroy_component(theme);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function setupTypewriter(t) {
    	var HTML = t.innerHTML;
    	t.innerHTML = "";

    	var cursorPosition = 0,
    		tag = "",
    		writingTag = true,
    		tagOpen = true,
    		typeSpeed = 10,
    		tempTypeSpeed = 0;

    	var type = function () {
    		if (writingTag === true) {
    			tag += HTML[cursorPosition];
    		}

    		if (HTML[cursorPosition] === "<") {
    			tempTypeSpeed = 0;

    			if (tagOpen) {
    				tagOpen = false;
    				writingTag = true;
    			} else {
    				tag = "";
    				tagOpen = true;
    				writingTag = true;
    				tag += HTML[cursorPosition];
    			}
    		}

    		if (!writingTag && tagOpen) {
    			tag.innerHTML += HTML[cursorPosition];
    		}

    		if (!writingTag && !tagOpen) {
    			if (HTML[cursorPosition] === " ") {
    				tempTypeSpeed = 0;
    			} else {
    				tempTypeSpeed = Math.random() * typeSpeed + 50;
    			}

    			t.innerHTML += HTML[cursorPosition];
    		}

    		if (writingTag === true && HTML[cursorPosition] === ">") {
    			tempTypeSpeed = Math.random() * typeSpeed + 50;
    			writingTag = false;

    			if (tagOpen) {
    				var newSpan = document.createElement("span");
    				t.appendChild(newSpan);
    				newSpan.innerHTML = tag;
    				tag = newSpan.firstChild;
    				tag.style.margin = 0;
    				tag.style.color = "var(--default-text-color)";
    				tag.style.letterSpacing = "1px";
    				tag.style.alignItems = "center";
    			}
    		}

    		cursorPosition += 1;

    		if (cursorPosition < HTML.length - 1) {
    			setTimeout(type, tempTypeSpeed);
    		}
    	};

    	return { type };
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { name } = $$props;
    	

    	window.onload = () => {
    		var tyy = document.getElementById("typewriter");
    		var typewriter = setupTypewriter(tyy);
    		let div = document.getElementsByClassName("scrollable")[0];
    		typewriter.type();

    		window.addEventListener("resize", function () {
    			if (window.innerHeight < 680) {
    				tyy.style.height = "0";
    				div.scrollTo(0, div.scrollHeight);
    			} else {
    				tyy.style.height = "70px";
    				document.getElementById("chat").style.height = "70vh";
    			}
    		});
    	};

    	const writable_props = ["name"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Headdiv> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		name = this.value;
    		$$invalidate(0, name);
    	}

    	$$self.$set = $$props => {
    		if ("name" in $$props) $$invalidate(0, name = $$props.name);
    	};

    	$$self.$capture_state = () => {
    		return { name };
    	};

    	$$self.$inject_state = $$props => {
    		if ("name" in $$props) $$invalidate(0, name = $$props.name);
    	};

    	return [name, input_input_handler];
    }

    class Headdiv extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, { name: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Headdiv",
    			options,
    			id: create_fragment$i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*name*/ ctx[0] === undefined && !("name" in props)) {
    			console.warn("<Headdiv> was created without expected prop 'name'");
    		}
    	}

    	get name() {
    		throw new Error("<Headdiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Headdiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var temoji = [{"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude00\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f600.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude03\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f603.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude04\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f604.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude01\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f601.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude06\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f606.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude05\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f605.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd23\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f923.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude02\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f602.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude42\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f642.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude43\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f643.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude09\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f609.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude0a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f60a.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude07\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f607.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd70\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f970.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude0d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f60d.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd29\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f929.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude18\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f618.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude17\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f617.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u263a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/263a.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude1a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f61a.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude19\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f619.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude0b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f60b.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude1b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f61b.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude1c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f61c.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd2a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f92a.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude1d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f61d.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd11\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f911.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd17\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f917.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd2d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f92d.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd2b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f92b.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd14\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f914.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd10\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f910.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd28\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f928.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude10\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f610.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude11\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f611.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude36\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f636.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude0f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f60f.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude12\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f612.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude44\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f644.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude2c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f62c.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd25\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f925.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude0c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f60c.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude14\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f614.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude2a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f62a.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd24\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f924.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude34\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f634.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude37\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f637.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd12\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f912.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd15\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f915.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd22\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f922.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd2e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f92e.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd27\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f927.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd75\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f975.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd76\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f976.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd74\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f974.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude35\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f635.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd2f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f92f.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd20\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f920.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd73\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f973.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude0e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f60e.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd13\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f913.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddd0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9d0.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude15\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f615.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude1f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f61f.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude41\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f641.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2639\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2639.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude2e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f62e.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude2f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f62f.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude32\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f632.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude33\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f633.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd7a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f97a.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude26\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f626.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude27\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f627.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude28\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f628.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude30\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f630.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude25\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f625.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude22\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f622.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude2d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f62d.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude31\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f631.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude16\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f616.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude23\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f623.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude1e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f61e.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude13\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f613.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude29\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f629.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude2b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f62b.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd71\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f971.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude24\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f624.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude21\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f621.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude20\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f620.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd2c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f92c.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude08\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f608.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc7f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f47f.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc80\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f480.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2620\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2620.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udca9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4a9.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd21\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f921.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc79\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f479.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc7a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f47a.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc7b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f47b.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc7d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f47d.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc7e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f47e.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd16\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f916.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude3a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f63a.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude38\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f638.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude39\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f639.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude3b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f63b.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude3c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f63c.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude3d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f63d.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude40\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f640.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude3f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f63f.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude3e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f63e.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude48\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f648.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude49\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f649.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude4a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f64a.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc8b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f48b.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc8c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f48c.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc98\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f498.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc9d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f49d.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc96\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f496.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc97\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f497.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc93\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f493.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc9e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f49e.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc95\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f495.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc9f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f49f.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2763\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2763.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc94\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f494.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2764\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2764.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udde1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9e1.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc9b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f49b.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc9a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f49a.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc99\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f499.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc9c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f49c.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd0e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f90e.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udda4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5a4.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd0d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f90d.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcaf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4af.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udca2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4a2.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udca5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4a5.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcab\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4ab.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udca6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4a6.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udca8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4a8.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd73\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f573.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udca3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4a3.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcac\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4ac.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc41\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f441.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udde8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5e8.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddef\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5ef.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcad\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4ad.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udca4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4a4.png\"/>", "group": "Smileys & Emotion"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc4b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f44b.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd1a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f91a.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd90\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f590.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u270b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/270b.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd96\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f596.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc4c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f44c.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd0f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f90f.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u270c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/270c.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd1e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f91e.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd1f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f91f.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd18\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f918.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd19\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f919.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc48\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f448.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc49\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f449.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc46\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f446.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd95\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f595.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc47\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f447.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u261d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/261d.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc4d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f44d.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc4e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f44e.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u270a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/270a.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc4a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f44a.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd1b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f91b.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd1c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f91c.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc4f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f44f.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude4c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f64c.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc50\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f450.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd32\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f932.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd1d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f91d.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude4f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f64f.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u270d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/270d.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc85\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f485.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd33\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f933.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcaa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4aa.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddbe\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9be.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddbf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9bf.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddb5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9b5.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddb6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9b6.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc42\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f442.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddbb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9bb.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc43\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f443.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udde0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9e0.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddb7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9b7.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddb4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9b4.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc40\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f440.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc45\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f445.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc44\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f444.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc76\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f476.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddd2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9d2.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc66\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f466.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc67\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f467.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddd1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9d1.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc71\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f471.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc68\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f468.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddd4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9d4.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc69\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f469.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddd3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9d3.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc74\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f474.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc75\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f475.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude4d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f64d.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude4e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f64e.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude45\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f645.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude46\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f646.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc81\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f481.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude4b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f64b.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddcf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9cf.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude47\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f647.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd26\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f926.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd37\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f937.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc6e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f46e.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd75\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f575.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc82\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f482.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc77\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f477.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd34\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f934.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc78\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f478.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc73\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f473.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc72\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f472.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddd5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9d5.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd35\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f935.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc70\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f470.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd30\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f930.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd31\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f931.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc7c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f47c.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf85\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f385.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd36\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f936.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddb8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9b8.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddb9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9b9.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddd9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9d9.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddda\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9da.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udddb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9db.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udddc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9dc.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udddd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9dd.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddde\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9de.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udddf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9df.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc86\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f486.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc87\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f487.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeb6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6b6.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddcd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9cd.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddce\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9ce.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfc3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3c3.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc83\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f483.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd7a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f57a.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd74\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f574.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc6f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f46f.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddd6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9d6.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddd7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9d7.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd3a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f93a.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfc7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3c7.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26f7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26f7.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfc2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3c2.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfcc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3cc.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfc4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3c4.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udea3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6a3.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfca\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3ca.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26f9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26f9.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfcb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3cb.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeb4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6b4.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeb5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6b5.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd38\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f938.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd3c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f93c.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd3d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f93d.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd3e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f93e.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd39\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f939.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddd8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9d8.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udec0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6c0.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udecc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6cc.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc6d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f46d.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc6b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f46b.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc6c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f46c.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc8f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f48f.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc91\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f491.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc6a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f46a.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udde3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5e3.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc64\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f464.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc65\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f465.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc63\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f463.png\"/>", "group": "People & Body"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udffb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3fb.png\"/>", "group": "Component"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udffc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3fc.png\"/>", "group": "Component"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udffd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3fd.png\"/>", "group": "Component"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udffe\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3fe.png\"/>", "group": "Component"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfff\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3ff.png\"/>", "group": "Component"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddb0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9b0.png\"/>", "group": "Component"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddb1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9b1.png\"/>", "group": "Component"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddb3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9b3.png\"/>", "group": "Component"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddb2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9b2.png\"/>", "group": "Component"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc35\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f435.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc12\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f412.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd8d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f98d.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udda7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9a7.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc36\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f436.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc15\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f415.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddae\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9ae.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc29\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f429.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc3a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f43a.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd8a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f98a.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd9d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f99d.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc31\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f431.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc08\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f408.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd81\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f981.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc2f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f42f.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc05\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f405.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc06\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f406.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc34\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f434.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc0e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f40e.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd84\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f984.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd93\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f993.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd8c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f98c.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc2e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f42e.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc02\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f402.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc03\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f403.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc04\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f404.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc37\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f437.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc16\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f416.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc17\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f417.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc3d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f43d.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc0f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f40f.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc11\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f411.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc10\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f410.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc2a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f42a.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc2b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f42b.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd99\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f999.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd92\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f992.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc18\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f418.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd8f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f98f.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd9b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f99b.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc2d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f42d.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc01\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f401.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc00\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f400.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc39\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f439.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc30\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f430.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc07\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f407.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc3f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f43f.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd94\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f994.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd87\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f987.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc3b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f43b.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc28\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f428.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc3c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f43c.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udda5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9a5.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udda6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9a6.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udda8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9a8.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd98\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f998.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udda1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9a1.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc3e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f43e.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd83\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f983.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc14\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f414.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc13\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f413.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc23\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f423.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc24\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f424.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc25\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f425.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc26\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f426.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc27\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f427.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd4a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f54a.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd85\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f985.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd86\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f986.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udda2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9a2.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd89\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f989.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udda9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9a9.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd9a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f99a.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd9c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f99c.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc38\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f438.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc0a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f40a.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc22\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f422.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd8e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f98e.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc0d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f40d.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc32\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f432.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc09\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f409.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd95\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f995.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd96\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f996.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc33\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f433.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc0b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f40b.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc2c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f42c.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc1f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f41f.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc20\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f420.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc21\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f421.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd88\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f988.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc19\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f419.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc1a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f41a.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc0c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f40c.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd8b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f98b.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc1b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f41b.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc1c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f41c.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc1d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f41d.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc1e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f41e.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd97\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f997.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd77\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f577.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd78\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f578.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd82\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f982.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd9f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f99f.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udda0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9a0.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc90\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f490.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf38\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f338.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcae\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4ae.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udff5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3f5.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf39\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f339.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd40\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f940.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf3a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f33a.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf3b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f33b.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf3c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f33c.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf37\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f337.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf31\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f331.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf32\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f332.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf33\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f333.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf34\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f334.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf35\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f335.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf3e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f33e.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf3f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f33f.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2618\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2618.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf40\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f340.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf41\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f341.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf42\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f342.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf43\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f343.png\"/>", "group": "Animals & Nature"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf47\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f347.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf48\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f348.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf49\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f349.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf4a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f34a.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf4b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f34b.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf4c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f34c.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf4d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f34d.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd6d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f96d.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf4e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f34e.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf4f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f34f.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf50\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f350.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf51\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f351.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf52\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f352.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf53\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f353.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd5d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f95d.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf45\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f345.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd65\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f965.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd51\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f951.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf46\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f346.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd54\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f954.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd55\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f955.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf3d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f33d.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf36\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f336.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd52\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f952.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd6c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f96c.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd66\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f966.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddc4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9c4.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddc5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9c5.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf44\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f344.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd5c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f95c.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf30\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f330.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf5e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f35e.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd50\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f950.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd56\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f956.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd68\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f968.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd6f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f96f.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd5e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f95e.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddc7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9c7.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddc0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9c0.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf56\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f356.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf57\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f357.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd69\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f969.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd53\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f953.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf54\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f354.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf5f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f35f.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf55\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f355.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf2d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f32d.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd6a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f96a.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf2e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f32e.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf2f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f32f.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd59\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f959.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddc6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9c6.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd5a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f95a.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf73\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f373.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd58\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f958.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf72\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f372.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd63\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f963.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd57\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f957.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf7f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f37f.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddc8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9c8.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddc2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9c2.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd6b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f96b.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf71\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f371.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf58\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f358.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf59\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f359.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf5a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f35a.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf5b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f35b.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf5c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f35c.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf5d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f35d.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf60\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f360.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf62\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f362.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf63\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f363.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf64\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f364.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf65\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f365.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd6e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f96e.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf61\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f361.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd5f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f95f.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd60\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f960.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd61\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f961.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd80\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f980.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd9e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f99e.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd90\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f990.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd91\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f991.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddaa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9aa.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf66\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f366.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf67\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f367.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf68\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f368.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf69\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f369.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf6a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f36a.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf82\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f382.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf70\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f370.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddc1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9c1.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd67\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f967.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf6b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f36b.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf6c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f36c.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf6d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f36d.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf6e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f36e.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf6f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f36f.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf7c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f37c.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd5b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f95b.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2615\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2615.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf75\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f375.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf76\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f376.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf7e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f37e.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf77\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f377.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf78\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f378.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf79\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f379.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf7a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f37a.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf7b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f37b.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd42\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f942.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd43\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f943.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd64\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f964.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddc3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9c3.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddc9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9c9.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddca\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9ca.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd62\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f962.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf7d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f37d.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf74\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f374.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd44\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f944.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd2a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f52a.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udffa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3fa.png\"/>", "group": "Food & Drink"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf0d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f30d.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf0e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f30e.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf0f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f30f.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf10\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f310.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddfa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5fa.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddfe\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5fe.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udded\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9ed.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfd4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3d4.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26f0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26f0.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf0b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f30b.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddfb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5fb.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfd5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3d5.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfd6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3d6.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfdc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3dc.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfdd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3dd.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfde\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3de.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfdf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3df.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfdb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3db.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfd7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3d7.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddf1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9f1.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfd8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3d8.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfda\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3da.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfe0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3e0.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfe1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3e1.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfe2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3e2.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfe3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3e3.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfe4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3e4.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfe5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3e5.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfe6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3e6.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfe8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3e8.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfe9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3e9.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfea\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3ea.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfeb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3eb.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfec\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3ec.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfed\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3ed.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfef\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3ef.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udff0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3f0.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc92\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f492.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddfc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5fc.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddfd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5fd.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26ea\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26ea.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd4c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f54c.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uded5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6d5.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd4d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f54d.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26e9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26e9.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd4b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f54b.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26f2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26f2.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26fa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26fa.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf01\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f301.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf03\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f303.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfd9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3d9.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf04\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f304.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf05\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f305.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf06\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f306.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf07\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f307.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf09\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f309.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2668\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2668.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfa0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3a0.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfa1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3a1.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfa2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3a2.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc88\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f488.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfaa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3aa.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude82\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f682.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude83\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f683.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude84\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f684.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude85\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f685.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude86\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f686.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude87\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f687.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude88\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f688.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude89\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f689.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude8a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f68a.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude9d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f69d.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude9e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f69e.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude8b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f68b.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude8c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f68c.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude8d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f68d.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude8e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f68e.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude90\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f690.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude91\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f691.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude92\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f692.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude93\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f693.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude94\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f694.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude95\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f695.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude96\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f696.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude97\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f697.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude98\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f698.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude99\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f699.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude9a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f69a.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude9b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f69b.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude9c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f69c.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfce\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3ce.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfcd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3cd.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udef5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6f5.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddbd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9bd.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddbc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9bc.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udefa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6fa.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeb2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6b2.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udef4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6f4.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udef9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6f9.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude8f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f68f.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udee3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6e3.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udee4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6e4.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udee2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6e2.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26fd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26fd.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udea8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6a8.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udea5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6a5.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udea6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6a6.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uded1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6d1.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udea7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6a7.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2693\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2693.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26f5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26f5.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udef6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6f6.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udea4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6a4.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udef3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6f3.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26f4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26f4.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udee5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6e5.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udea2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6a2.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2708\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2708.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udee9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6e9.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeeb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6eb.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeec\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6ec.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude82\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa82.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcba\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4ba.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude81\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f681.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude9f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f69f.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udea0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6a0.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udea1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6a1.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udef0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6f0.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\ude80\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f680.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udef8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6f8.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udece\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6ce.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddf3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9f3.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u231b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/231b.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23f3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23f3.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u231a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/231a.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23f0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23f0.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23f1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23f1.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23f2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23f2.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd70\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f570.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd5b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f55b.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd67\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f567.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd50\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f550.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd5c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f55c.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd51\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f551.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd5d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f55d.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd52\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f552.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd5e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f55e.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd53\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f553.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd5f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f55f.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd54\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f554.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd60\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f560.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd55\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f555.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd61\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f561.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd56\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f556.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd62\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f562.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd57\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f557.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd63\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f563.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd58\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f558.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd64\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f564.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd59\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f559.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd65\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f565.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd5a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f55a.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd66\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f566.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf11\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f311.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf12\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f312.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf13\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f313.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf14\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f314.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf15\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f315.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf16\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f316.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf17\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f317.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf18\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f318.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf19\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f319.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf1a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f31a.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf1b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f31b.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf1c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f31c.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf21\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f321.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2600\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2600.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf1d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f31d.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf1e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f31e.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude90\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa90.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2b50\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2b50.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf1f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f31f.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf20\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f320.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf0c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f30c.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2601\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2601.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26c5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26c5.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26c8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26c8.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf24\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f324.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf25\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f325.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf26\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f326.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf27\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f327.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf28\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f328.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf29\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f329.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf2a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f32a.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf2b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f32b.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf2c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f32c.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf00\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f300.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf08\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f308.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf02\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f302.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2602\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2602.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2614\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2614.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26f1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26f1.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26a1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26a1.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2744\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2744.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2603\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2603.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26c4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26c4.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2604\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2604.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd25\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f525.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udca7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4a7.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf0a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f30a.png\"/>", "group": "Travel & Places"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf83\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f383.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf84\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f384.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf86\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f386.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf87\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f387.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udde8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9e8.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2728\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2728.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf88\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f388.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf89\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f389.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf8a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f38a.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf8b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f38b.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf8d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f38d.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf8e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f38e.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf8f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f38f.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf90\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f390.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf91\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f391.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udde7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9e7.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf80\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f380.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf81\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f381.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf97\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f397.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf9f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f39f.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfab\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3ab.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf96\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f396.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfc6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3c6.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfc5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3c5.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd47\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f947.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd48\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f948.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd49\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f949.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26bd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26bd.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26be\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26be.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd4e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f94e.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfc0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3c0.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfd0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3d0.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfc8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3c8.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfc9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3c9.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfbe\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3be.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd4f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f94f.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfb3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3b3.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfcf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3cf.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfd1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3d1.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfd2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3d2.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd4d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f94d.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfd3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3d3.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udff8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3f8.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd4a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f94a.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd4b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f94b.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd45\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f945.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26f3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26f3.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26f8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26f8.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfa3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3a3.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd3f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f93f.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfbd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3bd.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfbf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3bf.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udef7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6f7.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd4c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f94c.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfaf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3af.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude80\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa80.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude81\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa81.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfb1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3b1.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd2e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f52e.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddff\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9ff.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfae\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3ae.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd79\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f579.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfb0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3b0.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfb2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3b2.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udde9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9e9.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddf8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9f8.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2660\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2660.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2665\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2665.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2666\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2666.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2663\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2663.png\"/>", "group": "Activities"}, {"code": "\u265f", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udccf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f0cf.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udc04\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f004.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfb4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3b4.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfad\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3ad.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddbc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5bc.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfa8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3a8.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddf5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9f5.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddf6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9f6.png\"/>", "group": "Activities"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc53\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f453.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd76\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f576.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd7d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f97d.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd7c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f97c.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddba\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9ba.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc54\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f454.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc55\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f455.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc56\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f456.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udde3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9e3.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udde4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9e4.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udde5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9e5.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udde6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9e6.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc57\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f457.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc58\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f458.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd7b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f97b.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude71\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa71.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude72\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa72.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude73\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa73.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc59\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f459.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc5a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f45a.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc5b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f45b.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc5c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f45c.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc5d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f45d.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udecd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6cd.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf92\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f392.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc5e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f45e.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc5f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f45f.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd7e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f97e.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd7f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f97f.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc60\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f460.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc61\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f461.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude70\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa70.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc62\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f462.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc51\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f451.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc52\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f452.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfa9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3a9.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf93\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f393.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udde2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9e2.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26d1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26d1.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcff\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4ff.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc84\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f484.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc8d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f48d.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc8e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f48e.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd07\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f507.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd08\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f508.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd09\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f509.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd0a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f50a.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udce2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4e2.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udce3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4e3.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcef\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4ef.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd14\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f514.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd15\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f515.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfbc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3bc.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfb5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3b5.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfb6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3b6.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf99\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f399.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf9a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f39a.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf9b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f39b.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfa4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3a4.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfa7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3a7.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcfb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4fb.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfb7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3b7.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfb8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3b8.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfb9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3b9.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfba\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3ba.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfbb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3bb.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude95\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa95.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\udd41\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f941.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcf1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4f1.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcf2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4f2.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u260e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/260e.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcde\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4de.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcdf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4df.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udce0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4e0.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd0b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f50b.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd0c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f50c.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcbb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4bb.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udda5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5a5.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udda8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5a8.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2328\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2328.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddb1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5b1.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddb2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5b2.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcbd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4bd.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcbe\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4be.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcbf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4bf.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcc0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4c0.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddee\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9ee.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfa5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3a5.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf9e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f39e.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcfd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4fd.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfac\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3ac.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcfa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4fa.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcf7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4f7.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcf8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4f8.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcf9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4f9.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcfc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4fc.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd0d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f50d.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd0e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f50e.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd6f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f56f.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udca1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4a1.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd26\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f526.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfee\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3ee.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude94\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa94.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcd4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4d4.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcd5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4d5.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcd6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4d6.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcd7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4d7.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcd8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4d8.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcd9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4d9.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcda\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4da.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcd3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4d3.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcd2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4d2.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcc3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4c3.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcdc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4dc.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcc4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4c4.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcf0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4f0.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddde\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5de.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcd1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4d1.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd16\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f516.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udff7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3f7.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcb0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4b0.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcb4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4b4.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcb5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4b5.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcb6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4b6.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcb7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4b7.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcb8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4b8.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcb3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4b3.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddfe\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9fe.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcb9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4b9.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcb1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4b1.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcb2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4b2.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2709\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2709.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udce7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4e7.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udce8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4e8.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udce9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4e9.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udce4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4e4.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udce5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4e5.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udce6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4e6.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udceb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4eb.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcea\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4ea.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcec\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4ec.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udced\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4ed.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcee\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4ee.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddf3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5f3.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u270f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/270f.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2712\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2712.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd8b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f58b.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd8a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f58a.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd8c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f58c.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd8d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f58d.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcdd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4dd.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcbc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4bc.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcc1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4c1.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcc2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4c2.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddc2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5c2.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcc5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4c5.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcc6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4c6.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddd2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5d2.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddd3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5d3.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcc7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4c7.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcc8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4c8.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcc9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4c9.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcca\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4ca.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udccb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4cb.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udccc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4cc.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udccd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4cd.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcce\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4ce.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd87\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f587.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udccf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4cf.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcd0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4d0.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2702\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2702.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddc3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5c3.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddc4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5c4.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddd1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5d1.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd12\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f512.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd13\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f513.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd0f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f50f.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd10\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f510.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd11\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f511.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udddd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5dd.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd28\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f528.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude93\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa93.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26cf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26cf.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2692\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2692.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udee0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6e0.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udde1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5e1.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2694\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2694.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd2b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f52b.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udff9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3f9.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udee1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6e1.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd27\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f527.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd29\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f529.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2699\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2699.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udddc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5dc.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2696\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2696.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddaf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9af.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd17\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f517.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26d3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26d3.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddf0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9f0.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddf2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9f2.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2697\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2697.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddea\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9ea.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddeb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9eb.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddec\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9ec.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd2c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f52c.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd2d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f52d.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udce1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4e1.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc89\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f489.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude78\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa78.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udc8a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f48a.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude79\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa79.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude7a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa7a.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeaa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6aa.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udecf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6cf.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udecb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6cb.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude91\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa91.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udebd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6bd.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udebf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6bf.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udec1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6c1.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\ude92\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1fa92.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddf4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9f4.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddf7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9f7.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddf9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9f9.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddfa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9fa.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddfb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9fb.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddfc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9fc.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddfd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9fd.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83e\uddef\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f9ef.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uded2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6d2.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeac\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6ac.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26b0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26b0.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26b1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26b1.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uddff\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f5ff.png\"/>", "group": "Objects"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfe7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3e7.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeae\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6ae.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeb0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6b0.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u267f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/267f.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeb9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6b9.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeba\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6ba.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udebb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6bb.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udebc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6bc.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udebe\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6be.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udec2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6c2.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udec3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6c3.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udec4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6c4.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udec5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6c5.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26a0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26a0.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeb8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6b8.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26d4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26d4.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeab\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6ab.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeb3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6b3.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udead\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6ad.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeaf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6af.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeb1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6b1.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udeb7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6b7.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcf5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4f5.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd1e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f51e.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2622\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2622.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2623\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2623.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2b06\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2b06.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2197\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2197.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u27a1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/27a1.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2198\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2198.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2b07\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2b07.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2199\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2199.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2b05\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2b05.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2196\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2196.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2195\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2195.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2194\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2194.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u21a9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/21a9.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u21aa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/21aa.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2934\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2934.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2935\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2935.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd03\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f503.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd04\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f504.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd19\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f519.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd1a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f51a.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd1b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f51b.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd1c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f51c.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd1d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f51d.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\uded0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6d0.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u269b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/269b.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd49\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f549.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2721\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2721.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2638\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2638.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u262f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/262f.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u271d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/271d.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2626\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2626.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u262a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/262a.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u262e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/262e.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd4e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f54e.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd2f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f52f.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2648\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2648.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2649\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2649.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u264a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/264a.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u264b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/264b.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u264c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/264c.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u264d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/264d.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u264e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/264e.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u264f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/264f.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2650\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2650.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2651\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2651.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2652\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2652.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2653\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2653.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26ce\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26ce.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd00\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f500.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd01\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f501.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd02\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f502.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u25b6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/25b6.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23e9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23e9.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23ed\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23ed.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23ef\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23ef.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u25c0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/25c0.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23ea\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23ea.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23ee\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23ee.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd3c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f53c.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23eb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23eb.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd3d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f53d.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23ec\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23ec.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23f8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23f8.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23f9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23f9.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23fa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23fa.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u23cf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/23cf.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfa6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3a6.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd05\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f505.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd06\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f506.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcf6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4f6.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcf3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4f3.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcf4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4f4.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2640\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2640.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2642\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2642.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2695\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2695.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u267e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/267e.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u267b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/267b.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u269c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/269c.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd31\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f531.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udcdb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4db.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd30\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f530.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2b55\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2b55.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2705\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2705.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2611\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2611.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2714\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2714.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2716\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2716.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u274c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/274c.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u274e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/274e.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2795\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2795.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2796\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2796.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2797\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2797.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u27b0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/27b0.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u27bf\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/27bf.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u303d\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/303d.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2733\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2733.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2734\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2734.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2747\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2747.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u203c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/203c.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2049\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2049.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2753\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2753.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2754\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2754.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2755\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2755.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2757\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2757.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u3030\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/3030.png\"/>", "group": "Symbols"}, {"code": "\u00a9", "group": "Symbols"}, {"code": "\u00ae", "group": "Symbols"}, {"code": "\u2122", "group": "Symbols"}, {"code": "#", "group": "Symbols"}, {"code": "*", "group": "Symbols"}, {"code": "0", "group": "Symbols"}, {"code": "1", "group": "Symbols"}, {"code": "2", "group": "Symbols"}, {"code": "3", "group": "Symbols"}, {"code": "4", "group": "Symbols"}, {"code": "5", "group": "Symbols"}, {"code": "6", "group": "Symbols"}, {"code": "7", "group": "Symbols"}, {"code": "8", "group": "Symbols"}, {"code": "9", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd1f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f51f.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd20\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f520.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd21\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f521.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd22\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f522.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd23\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f523.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd24\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f524.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd70\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f170.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd8e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f18e.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd71\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f171.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd91\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f191.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd92\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f192.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd93\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f193.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2139\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2139.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd94\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f194.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u24c2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/24c2.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd95\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f195.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd96\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f196.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd7e\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f17e.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd97\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f197.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd7f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f17f.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd98\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f198.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd99\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f199.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udd9a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f19a.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude01\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f201.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude02\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f202.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude37\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f237.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude36\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f236.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude2f\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f22f.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude50\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f250.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude39\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f239.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude1a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f21a.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude32\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f232.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude51\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f251.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude38\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f238.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude34\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f234.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude33\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f233.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u3297\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/3297.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u3299\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/3299.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude3a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f23a.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\ude35\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f235.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd34\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f534.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udfe0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f7e0.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udfe1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f7e1.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udfe2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f7e2.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd35\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f535.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udfe3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f7e3.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udfe4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f7e4.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26ab\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26ab.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u26aa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/26aa.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udfe5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f7e5.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udfe7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f7e7.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udfe8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f7e8.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udfe9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f7e9.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udfe6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f7e6.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udfea\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f7ea.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udfeb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f7eb.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2b1b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2b1b.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u2b1c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/2b1c.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u25fc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/25fc.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u25fb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/25fb.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u25fe\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/25fe.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u25fd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/25fd.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u25aa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/25aa.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\u25ab\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/25ab.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd36\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f536.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd37\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f537.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd38\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f538.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd39\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f539.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd3a\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f53a.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd3b\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f53b.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udca0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f4a0.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd18\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f518.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd33\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f533.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udd32\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f532.png\"/>", "group": "Symbols"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udfc1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3c1.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83d\udea9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f6a9.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udf8c\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f38c.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udff4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3f4.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udff3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f3f3.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udde6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1e6.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udde7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1e7.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udde8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1e8.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udde9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1e9.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddea\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1ea.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddeb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1eb.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddec\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1ec.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\udded\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1ed.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddee\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1ee.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddef\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1ef.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddf0\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1f0.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddf1\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1f1.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddf2\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1f2.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddf3\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1f3.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddf4\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1f4.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddf5\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1f5.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddf6\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1f6.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddf7\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1f7.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddf8\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1f8.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddf9\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1f9.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddfa\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1fa.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddfb\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1fb.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddfc\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1fc.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddfd\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1fd.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddfe\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1fe.png\"/>", "group": "Flags"}, {"code": "<img class=\"emoji\" draggable=\"false\" alt=\"\ud83c\uddff\" src=\"https://twemoji.maxcdn.com/v/12.1.5/72x72/1f1ff.png\"/>", "group": "Flags"}];

    /* src\components\emojitab.svelte generated by Svelte v3.18.1 */
    const file$h = "src\\components\\emojitab.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (12:8) {#each emoji as emo}
    function create_each_block(ctx) {
    	let span;
    	let raw_value = /*emo*/ ctx[3].code + "";
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[2](/*emo*/ ctx[3], ...args);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "svelte-3l6t7j");
    			add_location(span, file$h, 12, 12, 307);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			span.innerHTML = raw_value;
    			dispose = listen_dev(span, "click", click_handler, false, false, false);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*emoji*/ 1 && raw_value !== (raw_value = /*emo*/ ctx[3].code + "")) span.innerHTML = raw_value;		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(12:8) {#each emoji as emo}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let div;
    	let each_value = /*emoji*/ ctx[0];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "id", "emojii");
    			attr_dev(div, "class", "svelte-3l6t7j");
    			add_location(div, file$h, 10, 4, 244);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*dispatch, emoji*/ 3) {
    				each_value = /*emoji*/ ctx[0];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { emoji } = $$props;
    	const dispatch = createEventDispatcher();
    	const writable_props = ["emoji"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Emojitab> was created with unknown prop '${key}'`);
    	});

    	const click_handler = emo => dispatch("emojiClicked", { detail: emo.code });

    	$$self.$set = $$props => {
    		if ("emoji" in $$props) $$invalidate(0, emoji = $$props.emoji);
    	};

    	$$self.$capture_state = () => {
    		return { emoji };
    	};

    	$$self.$inject_state = $$props => {
    		if ("emoji" in $$props) $$invalidate(0, emoji = $$props.emoji);
    	};

    	return [emoji, dispatch, click_handler];
    }

    class Emojitab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, { emoji: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Emojitab",
    			options,
    			id: create_fragment$j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*emoji*/ ctx[0] === undefined && !("emoji" in props)) {
    			console.warn("<Emojitab> was created without expected prop 'emoji'");
    		}
    	}

    	get emoji() {
    		throw new Error("<Emojitab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set emoji(value) {
    		throw new Error("<Emojitab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var css$4 = ".mdc-button{padding:0;min-width:24px}.mdc-button:after,.mdc-button:before{background:none}.mdc-menu{max-width:450px}.mdc-menu-surface{top:50px!important}.mdc-tab-bar{position:static}.mdc-list{height:300px;overflow:hidden;overflow-y:scroll;scroll-behavior:smooth;scrollbar-width:5px}::-webkit-scrollbar{width:5px}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px rgba(0,0,0,.3);-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);-webkit-border-radius:5px;border-radius:5px}::-webkit-scrollbar-thumb{-webkit-border-radius:5px;border-radius:5px;background:rgba(196,183,183,.8);-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.5);box-shadow:inset 0 0 6px rgba(0,0,0,.5)}::-webkit-scrollbar-thumb:window-inactive{background:rgba(138,129,129,.4)}.mdc-tab{font-family:Roboto,sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:.875rem;line-height:2.25rem;font-weight:500;letter-spacing:.08929em;text-decoration:none;text-transform:uppercase;position:relative;display:flex;flex:1 0 auto;justify-content:center;box-sizing:border-box;height:48px;margin:0;padding:0 24px;border:none;outline:none;background:none;text-align:center;white-space:nowrap;cursor:pointer;-webkit-appearance:none;z-index:1}.mdc-tab .mdc-tab__text-label{color:rgba(0,0,0,.6)}.mdc-tab .mdc-tab__icon{color:rgba(0,0,0,.54);fill:currentColor}.mdc-tab::-moz-focus-inner{padding:0;border:0}.mdc-tab--min-width{flex:0 1 auto}.mdc-tab__content{position:relative;display:flex;align-items:center;justify-content:center;height:inherit;pointer-events:none}.mdc-tab__icon,.mdc-tab__text-label{transition:color .15s linear;display:inline-block;line-height:1;z-index:2}.mdc-tab--stacked{height:72px}.mdc-tab--stacked .mdc-tab__content{flex-direction:column;align-items:center;justify-content:space-between}.mdc-tab--stacked .mdc-tab__icon{padding-top:12px}.mdc-tab--stacked .mdc-tab__text-label{padding-bottom:16px}.mdc-tab--active .mdc-tab__icon,.mdc-tab--active .mdc-tab__text-label{color:#6200ee;color:var(--mdc-theme-primary,#6200ee)}.mdc-tab--active .mdc-tab__icon{fill:currentColor}.mdc-tab--active .mdc-tab__icon,.mdc-tab--active .mdc-tab__text-label{transition-delay:.1s}.mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label{padding-left:8px;padding-right:0}.mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label[dir=rtl],[dir=rtl] .mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label{padding-left:0;padding-right:8px}@keyframes mdc-ripple-fg-radius-in{0%{animation-timing-function:cubic-bezier(.4,0,.2,1);transform:translate(var(--mdc-ripple-fg-translate-start,0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}}@keyframes mdc-ripple-fg-opacity-in{0%{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity,0)}}@keyframes mdc-ripple-fg-opacity-out{0%{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity,0)}to{opacity:0}}.mdc-ripple-surface--test-edge-var-bug{--mdc-ripple-surface-test-edge-var:1px solid #000;visibility:hidden}.mdc-ripple-surface--test-edge-var-bug:before{border:var(--mdc-ripple-surface-test-edge-var)}.mdc-tab__ripple{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);position:absolute;top:0;left:0;width:100%;height:100%;overflow:hidden}.mdc-tab__ripple:after,.mdc-tab__ripple:before{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:\"\"}.mdc-tab__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1}.mdc-tab__ripple.mdc-ripple-upgraded:before{transform:scale(var(--mdc-ripple-fg-scale,1))}.mdc-tab__ripple.mdc-ripple-upgraded:after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-tab__ripple.mdc-ripple-upgraded--unbounded:after{top:var(--mdc-ripple-top,0);left:var(--mdc-ripple-left,0)}.mdc-tab__ripple.mdc-ripple-upgraded--foreground-activation:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-tab__ripple.mdc-ripple-upgraded--foreground-deactivation:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}.mdc-tab__ripple:after,.mdc-tab__ripple:before{top:-50%;left:-50%;width:200%;height:200%}.mdc-tab__ripple.mdc-ripple-upgraded:after{width:var(--mdc-ripple-fg-size,100%);height:var(--mdc-ripple-fg-size,100%)}.mdc-tab__ripple:after,.mdc-tab__ripple:before{background-color:#6200ee}@supports not (-ms-ime-align:auto){.mdc-tab__ripple:after,.mdc-tab__ripple:before{background-color:var(--mdc-theme-primary,#6200ee)}}.mdc-tab__ripple:hover:before{opacity:.04}.mdc-tab__ripple.mdc-ripple-upgraded--background-focused:before,.mdc-tab__ripple:not(.mdc-ripple-upgraded):focus:before{transition-duration:75ms;opacity:.12}.mdc-tab__ripple:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.mdc-tab__ripple:not(.mdc-ripple-upgraded):active:after{transition-duration:75ms;opacity:.12}.mdc-tab__ripple.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:0.12}.mdc-tab-indicator{display:flex;position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1}.mdc-tab-indicator .mdc-tab-indicator__content--underline{border-color:#6200ee;border-color:var(--mdc-theme-primary,#6200ee)}.mdc-tab-indicator .mdc-tab-indicator__content--icon{color:#018786;color:var(--mdc-theme-secondary,#018786)}.mdc-tab-indicator .mdc-tab-indicator__content--underline{border-top-width:2px}.mdc-tab-indicator .mdc-tab-indicator__content--icon{height:34px;font-size:34px}.mdc-tab-indicator__content{transform-origin:left;opacity:0}.mdc-tab-indicator__content--underline{align-self:flex-end;box-sizing:border-box;width:100%;border-top-style:solid}.mdc-tab-indicator__content--icon{align-self:center;margin:0 auto}.mdc-tab-indicator--active .mdc-tab-indicator__content{opacity:1}.mdc-tab-indicator .mdc-tab-indicator__content{transition:transform .25s cubic-bezier(.4,0,.2,1)}.mdc-tab-indicator--no-transition .mdc-tab-indicator__content{transition:none}.mdc-tab-indicator--fade .mdc-tab-indicator__content{transition:opacity .15s linear}.mdc-tab-indicator--active.mdc-tab-indicator--fade .mdc-tab-indicator__content{transition-delay:.1s}";
    styleInject(css$4);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$5 = {
        ACTIVE: 'mdc-tab-indicator--active',
        FADE: 'mdc-tab-indicator--fade',
        NO_TRANSITION: 'mdc-tab-indicator--no-transition',
    };
    var strings$6 = {
        CONTENT_SELECTOR: '.mdc-tab-indicator__content',
    };
    //# sourceMappingURL=constants.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabIndicatorFoundation = /** @class */ (function (_super) {
        __extends(MDCTabIndicatorFoundation, _super);
        function MDCTabIndicatorFoundation(adapter) {
            return _super.call(this, __assign({}, MDCTabIndicatorFoundation.defaultAdapter, adapter)) || this;
        }
        Object.defineProperty(MDCTabIndicatorFoundation, "cssClasses", {
            get: function () {
                return cssClasses$5;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabIndicatorFoundation, "strings", {
            get: function () {
                return strings$6;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabIndicatorFoundation, "defaultAdapter", {
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    computeContentClientRect: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                    setContentStyleProperty: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCTabIndicatorFoundation.prototype.computeContentClientRect = function () {
            return this.adapter_.computeContentClientRect();
        };
        return MDCTabIndicatorFoundation;
    }(MDCFoundation));
    //# sourceMappingURL=foundation.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /* istanbul ignore next: subclass is not a branch statement */
    var MDCFadingTabIndicatorFoundation = /** @class */ (function (_super) {
        __extends(MDCFadingTabIndicatorFoundation, _super);
        function MDCFadingTabIndicatorFoundation() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCFadingTabIndicatorFoundation.prototype.activate = function () {
            this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
        };
        MDCFadingTabIndicatorFoundation.prototype.deactivate = function () {
            this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
        };
        return MDCFadingTabIndicatorFoundation;
    }(MDCTabIndicatorFoundation));
    //# sourceMappingURL=fading-foundation.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /* istanbul ignore next: subclass is not a branch statement */
    var MDCSlidingTabIndicatorFoundation = /** @class */ (function (_super) {
        __extends(MDCSlidingTabIndicatorFoundation, _super);
        function MDCSlidingTabIndicatorFoundation() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCSlidingTabIndicatorFoundation.prototype.activate = function (previousIndicatorClientRect) {
            // Early exit if no indicator is present to handle cases where an indicator
            // may be activated without a prior indicator state
            if (!previousIndicatorClientRect) {
                this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
                return;
            }
            // This animation uses the FLIP approach. You can read more about it at the link below:
            // https://aerotwist.com/blog/flip-your-animations/
            // Calculate the dimensions based on the dimensions of the previous indicator
            var currentClientRect = this.computeContentClientRect();
            var widthDelta = previousIndicatorClientRect.width / currentClientRect.width;
            var xPosition = previousIndicatorClientRect.left - currentClientRect.left;
            this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
            this.adapter_.setContentStyleProperty('transform', "translateX(" + xPosition + "px) scaleX(" + widthDelta + ")");
            // Force repaint before updating classes and transform to ensure the transform properly takes effect
            this.computeContentClientRect();
            this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
            this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
            this.adapter_.setContentStyleProperty('transform', '');
        };
        MDCSlidingTabIndicatorFoundation.prototype.deactivate = function () {
            this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
        };
        return MDCSlidingTabIndicatorFoundation;
    }(MDCTabIndicatorFoundation));
    //# sourceMappingURL=sliding-foundation.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabIndicator = /** @class */ (function (_super) {
        __extends(MDCTabIndicator, _super);
        function MDCTabIndicator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTabIndicator.attachTo = function (root) {
            return new MDCTabIndicator(root);
        };
        MDCTabIndicator.prototype.initialize = function () {
            this.content_ = this.root_.querySelector(MDCTabIndicatorFoundation.strings.CONTENT_SELECTOR);
        };
        MDCTabIndicator.prototype.computeContentClientRect = function () {
            return this.foundation_.computeContentClientRect();
        };
        MDCTabIndicator.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                computeContentClientRect: function () { return _this.content_.getBoundingClientRect(); },
                setContentStyleProperty: function (prop, value) { return _this.content_.style.setProperty(prop, value); },
            };
            // tslint:enable:object-literal-sort-keys
            if (this.root_.classList.contains(MDCTabIndicatorFoundation.cssClasses.FADE)) {
                return new MDCFadingTabIndicatorFoundation(adapter);
            }
            // Default to the sliding indicator
            return new MDCSlidingTabIndicatorFoundation(adapter);
        };
        MDCTabIndicator.prototype.activate = function (previousIndicatorClientRect) {
            this.foundation_.activate(previousIndicatorClientRect);
        };
        MDCTabIndicator.prototype.deactivate = function () {
            this.foundation_.deactivate();
        };
        return MDCTabIndicator;
    }(MDCComponent));
    //# sourceMappingURL=component.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$6 = {
        ACTIVE: 'mdc-tab--active',
    };
    var strings$7 = {
        ARIA_SELECTED: 'aria-selected',
        CONTENT_SELECTOR: '.mdc-tab__content',
        INTERACTED_EVENT: 'MDCTab:interacted',
        RIPPLE_SELECTOR: '.mdc-tab__ripple',
        TABINDEX: 'tabIndex',
        TAB_INDICATOR_SELECTOR: '.mdc-tab-indicator',
    };
    //# sourceMappingURL=constants.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabFoundation = /** @class */ (function (_super) {
        __extends(MDCTabFoundation, _super);
        function MDCTabFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCTabFoundation.defaultAdapter, adapter)) || this;
            _this.focusOnActivate_ = true;
            return _this;
        }
        Object.defineProperty(MDCTabFoundation, "cssClasses", {
            get: function () {
                return cssClasses$6;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabFoundation, "strings", {
            get: function () {
                return strings$7;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabFoundation, "defaultAdapter", {
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    hasClass: function () { return false; },
                    setAttr: function () { return undefined; },
                    activateIndicator: function () { return undefined; },
                    deactivateIndicator: function () { return undefined; },
                    notifyInteracted: function () { return undefined; },
                    getOffsetLeft: function () { return 0; },
                    getOffsetWidth: function () { return 0; },
                    getContentOffsetLeft: function () { return 0; },
                    getContentOffsetWidth: function () { return 0; },
                    focus: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCTabFoundation.prototype.handleClick = function () {
            // It's up to the parent component to keep track of the active Tab and
            // ensure we don't activate a Tab that's already active.
            this.adapter_.notifyInteracted();
        };
        MDCTabFoundation.prototype.isActive = function () {
            return this.adapter_.hasClass(cssClasses$6.ACTIVE);
        };
        /**
         * Sets whether the tab should focus itself when activated
         */
        MDCTabFoundation.prototype.setFocusOnActivate = function (focusOnActivate) {
            this.focusOnActivate_ = focusOnActivate;
        };
        /**
         * Activates the Tab
         */
        MDCTabFoundation.prototype.activate = function (previousIndicatorClientRect) {
            this.adapter_.addClass(cssClasses$6.ACTIVE);
            this.adapter_.setAttr(strings$7.ARIA_SELECTED, 'true');
            this.adapter_.setAttr(strings$7.TABINDEX, '0');
            this.adapter_.activateIndicator(previousIndicatorClientRect);
            if (this.focusOnActivate_) {
                this.adapter_.focus();
            }
        };
        /**
         * Deactivates the Tab
         */
        MDCTabFoundation.prototype.deactivate = function () {
            // Early exit
            if (!this.isActive()) {
                return;
            }
            this.adapter_.removeClass(cssClasses$6.ACTIVE);
            this.adapter_.setAttr(strings$7.ARIA_SELECTED, 'false');
            this.adapter_.setAttr(strings$7.TABINDEX, '-1');
            this.adapter_.deactivateIndicator();
        };
        /**
         * Returns the dimensions of the Tab
         */
        MDCTabFoundation.prototype.computeDimensions = function () {
            var rootWidth = this.adapter_.getOffsetWidth();
            var rootLeft = this.adapter_.getOffsetLeft();
            var contentWidth = this.adapter_.getContentOffsetWidth();
            var contentLeft = this.adapter_.getContentOffsetLeft();
            return {
                contentLeft: rootLeft + contentLeft,
                contentRight: rootLeft + contentLeft + contentWidth,
                rootLeft: rootLeft,
                rootRight: rootLeft + rootWidth,
            };
        };
        return MDCTabFoundation;
    }(MDCFoundation));
    //# sourceMappingURL=foundation.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTab = /** @class */ (function (_super) {
        __extends(MDCTab, _super);
        function MDCTab() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTab.attachTo = function (root) {
            return new MDCTab(root);
        };
        MDCTab.prototype.initialize = function (rippleFactory, tabIndicatorFactory) {
            if (rippleFactory === void 0) { rippleFactory = function (el, foundation) { return new MDCRipple(el, foundation); }; }
            if (tabIndicatorFactory === void 0) { tabIndicatorFactory = function (el) { return new MDCTabIndicator(el); }; }
            this.id = this.root_.id;
            var rippleSurface = this.root_.querySelector(MDCTabFoundation.strings.RIPPLE_SELECTOR);
            var rippleAdapter = __assign({}, MDCRipple.createAdapter(this), { addClass: function (className) { return rippleSurface.classList.add(className); }, removeClass: function (className) { return rippleSurface.classList.remove(className); }, updateCssVariable: function (varName, value) { return rippleSurface.style.setProperty(varName, value); } });
            var rippleFoundation = new MDCRippleFoundation(rippleAdapter);
            this.ripple_ = rippleFactory(this.root_, rippleFoundation);
            var tabIndicatorElement = this.root_.querySelector(MDCTabFoundation.strings.TAB_INDICATOR_SELECTOR);
            this.tabIndicator_ = tabIndicatorFactory(tabIndicatorElement);
            this.content_ = this.root_.querySelector(MDCTabFoundation.strings.CONTENT_SELECTOR);
        };
        MDCTab.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.handleClick_ = function () { return _this.foundation_.handleClick(); };
            this.listen('click', this.handleClick_);
        };
        MDCTab.prototype.destroy = function () {
            this.unlisten('click', this.handleClick_);
            this.ripple_.destroy();
            _super.prototype.destroy.call(this);
        };
        MDCTab.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                setAttr: function (attr, value) { return _this.root_.setAttribute(attr, value); },
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                hasClass: function (className) { return _this.root_.classList.contains(className); },
                activateIndicator: function (previousIndicatorClientRect) { return _this.tabIndicator_.activate(previousIndicatorClientRect); },
                deactivateIndicator: function () { return _this.tabIndicator_.deactivate(); },
                notifyInteracted: function () { return _this.emit(MDCTabFoundation.strings.INTERACTED_EVENT, { tabId: _this.id }, true /* bubble */); },
                getOffsetLeft: function () { return _this.root_.offsetLeft; },
                getOffsetWidth: function () { return _this.root_.offsetWidth; },
                getContentOffsetLeft: function () { return _this.content_.offsetLeft; },
                getContentOffsetWidth: function () { return _this.content_.offsetWidth; },
                focus: function () { return _this.root_.focus(); },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCTabFoundation(adapter);
        };
        Object.defineProperty(MDCTab.prototype, "active", {
            /**
             * Getter for the active state of the tab
             */
            get: function () {
                return this.foundation_.isActive();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTab.prototype, "focusOnActivate", {
            set: function (focusOnActivate) {
                this.foundation_.setFocusOnActivate(focusOnActivate);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Activates the tab
         */
        MDCTab.prototype.activate = function (computeIndicatorClientRect) {
            this.foundation_.activate(computeIndicatorClientRect);
        };
        /**
         * Deactivates the tab
         */
        MDCTab.prototype.deactivate = function () {
            this.foundation_.deactivate();
        };
        /**
         * Returns the indicator's client rect
         */
        MDCTab.prototype.computeIndicatorClientRect = function () {
            return this.tabIndicator_.computeContentClientRect();
        };
        MDCTab.prototype.computeDimensions = function () {
            return this.foundation_.computeDimensions();
        };
        /**
         * Focuses the tab
         */
        MDCTab.prototype.focus = function () {
            this.root_.focus();
        };
        return MDCTab;
    }(MDCComponent));
    //# sourceMappingURL=component.js.map

    /* node_modules\@smui\tab-indicator\TabIndicator.svelte generated by Svelte v3.18.1 */
    const file$i = "node_modules\\@smui\\tab-indicator\\TabIndicator.svelte";

    function create_fragment$k(ctx) {
    	let span1;
    	let span0;
    	let useActions_action;
    	let useActions_action_1;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

    	let span0_levels = [
    		{
    			class: "\n      mdc-tab-indicator__content\n      " + /*content$class*/ ctx[6] + "\n      " + (/*type*/ ctx[3] === "underline"
    			? "mdc-tab-indicator__content--underline"
    			: "") + "\n      " + (/*type*/ ctx[3] === "icon"
    			? "mdc-tab-indicator__content--icon"
    			: "") + "\n    "
    		},
    		{
    			"aria-hidden": /*type*/ ctx[3] === "icon" ? "true" : "false"
    		},
    		exclude(prefixFilter(/*$$props*/ ctx[9], "content$"), ["use", "class"])
    	];

    	let span0_data = {};

    	for (let i = 0; i < span0_levels.length; i += 1) {
    		span0_data = assign(span0_data, span0_levels[i]);
    	}

    	let span1_levels = [
    		{
    			class: "\n    mdc-tab-indicator\n    " + /*className*/ ctx[1] + "\n    " + (/*active*/ ctx[2] ? "mdc-tab-indicator--active" : "") + "\n    " + (/*transition*/ ctx[4] === "fade"
    			? "mdc-tab-indicator--fade"
    			: "") + "\n  "
    		},
    		exclude(/*$$props*/ ctx[9], ["use", "class", "active", "type", "transition", "content$"])
    	];

    	let span1_data = {};

    	for (let i = 0; i < span1_levels.length; i += 1) {
    		span1_data = assign(span1_data, span1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span1 = element("span");
    			span0 = element("span");
    			if (default_slot) default_slot.c();
    			set_attributes(span0, span0_data);
    			add_location(span0, file$i, 12, 2, 322);
    			set_attributes(span1, span1_data);
    			add_location(span1, file$i, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span1, anchor);
    			append_dev(span1, span0);

    			if (default_slot) {
    				default_slot.m(span0, null);
    			}

    			/*span1_binding*/ ctx[18](span1);
    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, span0, /*content$use*/ ctx[5])),
    				action_destroyer(useActions_action_1 = useActions.call(null, span1, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[8].call(null, span1))
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 65536) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[16], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null));
    			}

    			set_attributes(span0, get_spread_update(span0_levels, [
    				dirty & /*content$class, type*/ 72 && {
    					class: "\n      mdc-tab-indicator__content\n      " + /*content$class*/ ctx[6] + "\n      " + (/*type*/ ctx[3] === "underline"
    					? "mdc-tab-indicator__content--underline"
    					: "") + "\n      " + (/*type*/ ctx[3] === "icon"
    					? "mdc-tab-indicator__content--icon"
    					: "") + "\n    "
    				},
    				dirty & /*type*/ 8 && {
    					"aria-hidden": /*type*/ ctx[3] === "icon" ? "true" : "false"
    				},
    				dirty & /*exclude, prefixFilter, $$props*/ 512 && exclude(prefixFilter(/*$$props*/ ctx[9], "content$"), ["use", "class"])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*content$use*/ 32) useActions_action.update.call(null, /*content$use*/ ctx[5]);

    			set_attributes(span1, get_spread_update(span1_levels, [
    				dirty & /*className, active, transition*/ 22 && {
    					class: "\n    mdc-tab-indicator\n    " + /*className*/ ctx[1] + "\n    " + (/*active*/ ctx[2] ? "mdc-tab-indicator--active" : "") + "\n    " + (/*transition*/ ctx[4] === "fade"
    					? "mdc-tab-indicator--fade"
    					: "") + "\n  "
    				},
    				dirty & /*exclude, $$props*/ 512 && exclude(/*$$props*/ ctx[9], ["use", "class", "active", "type", "transition", "content$"])
    			]));

    			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span1);
    			if (default_slot) default_slot.d(detaching);
    			/*span1_binding*/ ctx[18](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { use = [] } = $$props;
    	let { class: className = "" } = $$props;
    	let { active = false } = $$props;
    	let { type = "underline" } = $$props;
    	let { transition = "slide" } = $$props;
    	let { content$use = [] } = $$props;
    	let { content$class = "" } = $$props;
    	let element;
    	let tabIndicator;
    	let instantiate = getContext("SMUI:tab-indicator:instantiate");
    	let getInstance = getContext("SMUI:tab-indicator:getInstance");

    	onMount(async () => {
    		if (instantiate !== false) {
    			tabIndicator = new MDCTabIndicator(element);
    		} else {
    			tabIndicator = await getInstance();
    		}
    	});

    	onDestroy(() => {
    		tabIndicator && tabIndicator.destroy();
    	});

    	function activate(...args) {
    		return tabIndicator.activate(...args);
    	}

    	function deactivate(...args) {
    		return tabIndicator.deactivate(...args);
    	}

    	function computeContentClientRect(...args) {
    		return tabIndicator.computeContentClientRect(...args);
    	}

    	let { $$slots = {}, $$scope } = $$props;

    	function span1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(7, element = $$value);
    		});
    	}

    	$$self.$set = $$new_props => {
    		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ("active" in $$new_props) $$invalidate(2, active = $$new_props.active);
    		if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
    		if ("transition" in $$new_props) $$invalidate(4, transition = $$new_props.transition);
    		if ("content$use" in $$new_props) $$invalidate(5, content$use = $$new_props.content$use);
    		if ("content$class" in $$new_props) $$invalidate(6, content$class = $$new_props.content$class);
    		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			use,
    			className,
    			active,
    			type,
    			transition,
    			content$use,
    			content$class,
    			element,
    			tabIndicator,
    			instantiate,
    			getInstance
    		};
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
    		if ("active" in $$props) $$invalidate(2, active = $$new_props.active);
    		if ("type" in $$props) $$invalidate(3, type = $$new_props.type);
    		if ("transition" in $$props) $$invalidate(4, transition = $$new_props.transition);
    		if ("content$use" in $$props) $$invalidate(5, content$use = $$new_props.content$use);
    		if ("content$class" in $$props) $$invalidate(6, content$class = $$new_props.content$class);
    		if ("element" in $$props) $$invalidate(7, element = $$new_props.element);
    		if ("tabIndicator" in $$props) tabIndicator = $$new_props.tabIndicator;
    		if ("instantiate" in $$props) instantiate = $$new_props.instantiate;
    		if ("getInstance" in $$props) getInstance = $$new_props.getInstance;
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		active,
    		type,
    		transition,
    		content$use,
    		content$class,
    		element,
    		forwardEvents,
    		$$props,
    		activate,
    		deactivate,
    		computeContentClientRect,
    		tabIndicator,
    		instantiate,
    		getInstance,
    		$$scope,
    		$$slots,
    		span1_binding
    	];
    }

    class TabIndicator extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
    			use: 0,
    			class: 1,
    			active: 2,
    			type: 3,
    			transition: 4,
    			content$use: 5,
    			content$class: 6,
    			activate: 10,
    			deactivate: 11,
    			computeContentClientRect: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabIndicator",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get use() {
    		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content$use() {
    		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content$use(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content$class() {
    		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content$class(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activate() {
    		return this.$$.ctx[10];
    	}

    	set activate(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get deactivate() {
    		return this.$$.ctx[11];
    	}

    	set deactivate(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get computeContentClientRect() {
    		return this.$$.ctx[12];
    	}

    	set computeContentClientRect(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\tab\Tab.svelte generated by Svelte v3.18.1 */

    const { Error: Error_1 } = globals;
    const file$j = "node_modules\\@smui\\tab\\Tab.svelte";
    const get_tab_indicator_slot_changes_1 = dirty => ({});
    const get_tab_indicator_slot_context_1 = ctx => ({});
    const get_tab_indicator_slot_changes = dirty => ({});
    const get_tab_indicator_slot_context = ctx => ({});

    // (24:4) {#if indicatorSpanOnlyContent}
    function create_if_block_2(ctx) {
    	let current;

    	const tabindicator_spread_levels = [
    		{ active: /*active*/ ctx[0] },
    		prefixFilter(/*$$props*/ ctx[12], "tabIndicator$")
    	];

    	let tabindicator_props = {
    		$$slots: { default: [create_default_slot_1$1] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < tabindicator_spread_levels.length; i += 1) {
    		tabindicator_props = assign(tabindicator_props, tabindicator_spread_levels[i]);
    	}

    	const tabindicator = new TabIndicator({
    			props: tabindicator_props,
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tabindicator.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tabindicator, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tabindicator_changes = (dirty & /*active, prefixFilter, $$props*/ 4097)
    			? get_spread_update(tabindicator_spread_levels, [
    					dirty & /*active*/ 1 && { active: /*active*/ ctx[0] },
    					dirty & /*prefixFilter, $$props*/ 4096 && get_spread_object(prefixFilter(/*$$props*/ ctx[12], "tabIndicator$"))
    				])
    			: {};

    			if (dirty & /*$$scope*/ 536870912) {
    				tabindicator_changes.$$scope = { dirty, ctx };
    			}

    			tabindicator.$set(tabindicator_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabindicator.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabindicator.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tabindicator, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(24:4) {#if indicatorSpanOnlyContent}",
    		ctx
    	});

    	return block;
    }

    // (25:6) <TabIndicator         {active}         {...prefixFilter($$props, 'tabIndicator$')}       >
    function create_default_slot_1$1(ctx) {
    	let current;
    	const tab_indicator_slot_template = /*$$slots*/ ctx[27]["tab-indicator"];
    	const tab_indicator_slot = create_slot(tab_indicator_slot_template, ctx, /*$$scope*/ ctx[29], get_tab_indicator_slot_context);

    	const block = {
    		c: function create() {
    			if (tab_indicator_slot) tab_indicator_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (tab_indicator_slot) {
    				tab_indicator_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (tab_indicator_slot && tab_indicator_slot.p && dirty & /*$$scope*/ 536870912) {
    				tab_indicator_slot.p(get_slot_context(tab_indicator_slot_template, ctx, /*$$scope*/ ctx[29], get_tab_indicator_slot_context), get_slot_changes(tab_indicator_slot_template, /*$$scope*/ ctx[29], dirty, get_tab_indicator_slot_changes));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab_indicator_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab_indicator_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (tab_indicator_slot) tab_indicator_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(25:6) <TabIndicator         {active}         {...prefixFilter($$props, 'tabIndicator$')}       >",
    		ctx
    	});

    	return block;
    }

    // (31:2) {#if !indicatorSpanOnlyContent}
    function create_if_block_1$1(ctx) {
    	let current;

    	const tabindicator_spread_levels = [
    		{ active: /*active*/ ctx[0] },
    		prefixFilter(/*$$props*/ ctx[12], "tabIndicator$")
    	];

    	let tabindicator_props = {
    		$$slots: { default: [create_default_slot$3] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < tabindicator_spread_levels.length; i += 1) {
    		tabindicator_props = assign(tabindicator_props, tabindicator_spread_levels[i]);
    	}

    	const tabindicator = new TabIndicator({
    			props: tabindicator_props,
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tabindicator.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tabindicator, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tabindicator_changes = (dirty & /*active, prefixFilter, $$props*/ 4097)
    			? get_spread_update(tabindicator_spread_levels, [
    					dirty & /*active*/ 1 && { active: /*active*/ ctx[0] },
    					dirty & /*prefixFilter, $$props*/ 4096 && get_spread_object(prefixFilter(/*$$props*/ ctx[12], "tabIndicator$"))
    				])
    			: {};

    			if (dirty & /*$$scope*/ 536870912) {
    				tabindicator_changes.$$scope = { dirty, ctx };
    			}

    			tabindicator.$set(tabindicator_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabindicator.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabindicator.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tabindicator, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(31:2) {#if !indicatorSpanOnlyContent}",
    		ctx
    	});

    	return block;
    }

    // (32:4) <TabIndicator       {active}       {...prefixFilter($$props, 'tabIndicator$')}     >
    function create_default_slot$3(ctx) {
    	let current;
    	const tab_indicator_slot_template = /*$$slots*/ ctx[27]["tab-indicator"];
    	const tab_indicator_slot = create_slot(tab_indicator_slot_template, ctx, /*$$scope*/ ctx[29], get_tab_indicator_slot_context_1);

    	const block = {
    		c: function create() {
    			if (tab_indicator_slot) tab_indicator_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (tab_indicator_slot) {
    				tab_indicator_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (tab_indicator_slot && tab_indicator_slot.p && dirty & /*$$scope*/ 536870912) {
    				tab_indicator_slot.p(get_slot_context(tab_indicator_slot_template, ctx, /*$$scope*/ ctx[29], get_tab_indicator_slot_context_1), get_slot_changes(tab_indicator_slot_template, /*$$scope*/ ctx[29], dirty, get_tab_indicator_slot_changes_1));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab_indicator_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab_indicator_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (tab_indicator_slot) tab_indicator_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(32:4) <TabIndicator       {active}       {...prefixFilter($$props, 'tabIndicator$')}     >",
    		ctx
    	});

    	return block;
    }

    // (37:2) {#if ripple}
    function create_if_block$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "mdc-tab__ripple");
    			add_location(span, file$j, 37, 4, 1093);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(37:2) {#if ripple}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let button;
    	let span;
    	let t0;
    	let useActions_action;
    	let t1;
    	let t2;
    	let useActions_action_1;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[27].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[29], null);
    	let if_block0 = /*indicatorSpanOnlyContent*/ ctx[6] && create_if_block_2(ctx);

    	let span_levels = [
    		{
    			class: "mdc-tab__content " + /*content$class*/ ctx[8]
    		},
    		exclude(prefixFilter(/*$$props*/ ctx[12], "content$"), ["use", "class"])
    	];

    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	let if_block1 = !/*indicatorSpanOnlyContent*/ ctx[6] && create_if_block_1$1(ctx);
    	let if_block2 = /*ripple*/ ctx[3] && create_if_block$2(ctx);

    	let button_levels = [
    		{
    			class: "\n    mdc-tab\n    " + /*className*/ ctx[2] + "\n    " + (/*active*/ ctx[0] ? "mdc-tab--active" : "") + "\n    " + (/*stacked*/ ctx[4] ? "mdc-tab--stacked" : "") + "\n    " + (/*minWidth*/ ctx[5] ? "mdc-tab--min-width" : "") + "\n  "
    		},
    		{ role: "tab" },
    		{ "aria-selected": /*active*/ ctx[0] },
    		{ tabindex: /*active*/ ctx[0] ? "0" : "-1" },
    		exclude(/*$$props*/ ctx[12], [
    			"use",
    			"class",
    			"ripple",
    			"active",
    			"stacked",
    			"minWidth",
    			"indicatorSpanOnlyContent",
    			"focusOnActivate",
    			"content$",
    			"tabIndicator$"
    		])
    	];

    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			span = element("span");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			set_attributes(span, span_data);
    			add_location(span, file$j, 17, 2, 517);
    			set_attributes(button, button_data);
    			add_location(button, file$j, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, span);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			append_dev(span, t0);
    			if (if_block0) if_block0.m(span, null);
    			append_dev(button, t1);
    			if (if_block1) if_block1.m(button, null);
    			append_dev(button, t2);
    			if (if_block2) if_block2.m(button, null);
    			/*button_binding*/ ctx[28](button);
    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, span, /*content$use*/ ctx[7])),
    				action_destroyer(useActions_action_1 = useActions.call(null, button, /*use*/ ctx[1])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[10].call(null, button)),
    				listen_dev(button, "MDCTab:interacted", /*interactedHandler*/ ctx[11], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 536870912) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[29], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[29], dirty, null));
    			}

    			if (/*indicatorSpanOnlyContent*/ ctx[6]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(span, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			set_attributes(span, get_spread_update(span_levels, [
    				dirty & /*content$class*/ 256 && {
    					class: "mdc-tab__content " + /*content$class*/ ctx[8]
    				},
    				dirty & /*exclude, prefixFilter, $$props*/ 4096 && exclude(prefixFilter(/*$$props*/ ctx[12], "content$"), ["use", "class"])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*content$use*/ 128) useActions_action.update.call(null, /*content$use*/ ctx[7]);

    			if (!/*indicatorSpanOnlyContent*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    					transition_in(if_block1, 1);
    				} else {
    					if_block1 = create_if_block_1$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(button, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*ripple*/ ctx[3]) {
    				if (!if_block2) {
    					if_block2 = create_if_block$2(ctx);
    					if_block2.c();
    					if_block2.m(button, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			set_attributes(button, get_spread_update(button_levels, [
    				dirty & /*className, active, stacked, minWidth*/ 53 && {
    					class: "\n    mdc-tab\n    " + /*className*/ ctx[2] + "\n    " + (/*active*/ ctx[0] ? "mdc-tab--active" : "") + "\n    " + (/*stacked*/ ctx[4] ? "mdc-tab--stacked" : "") + "\n    " + (/*minWidth*/ ctx[5] ? "mdc-tab--min-width" : "") + "\n  "
    				},
    				{ role: "tab" },
    				dirty & /*active*/ 1 && { "aria-selected": /*active*/ ctx[0] },
    				dirty & /*active*/ 1 && { tabindex: /*active*/ ctx[0] ? "0" : "-1" },
    				dirty & /*exclude, $$props*/ 4096 && exclude(/*$$props*/ ctx[12], [
    					"use",
    					"class",
    					"ripple",
    					"active",
    					"stacked",
    					"minWidth",
    					"indicatorSpanOnlyContent",
    					"focusOnActivate",
    					"content$",
    					"tabIndicator$"
    				])
    			]));

    			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 2) useActions_action_1.update.call(null, /*use*/ ctx[1]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			/*button_binding*/ ctx[28](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component, ["MDCTab:interacted"]);
    	let activeEntry = getContext("SMUI:tab:active");
    	let { use = [] } = $$props;
    	let { class: className = "" } = $$props;
    	let { tab: tabEntry } = $$props;
    	let { ripple = true } = $$props;
    	let { active = tabEntry === activeEntry } = $$props;
    	let { stacked = false } = $$props;
    	let { minWidth = false } = $$props;
    	let { indicatorSpanOnlyContent = false } = $$props;
    	let { focusOnActivate = true } = $$props;
    	let { content$use = [] } = $$props;
    	let { content$class = "" } = $$props;
    	let element;
    	let tab;
    	let instantiate = getContext("SMUI:tab:instantiate");
    	let getInstance = getContext("SMUI:tab:getInstance");
    	let tabIndicatorPromiseResolve;
    	let tabIndicatorPromise = new Promise(resolve => tabIndicatorPromiseResolve = resolve);
    	setContext("SMUI:tab-indicator:instantiate", false);
    	setContext("SMUI:tab-indicator:getInstance", getTabIndicatorInstancePromise);
    	setContext("SMUI:label:context", "tab");
    	setContext("SMUI:icon:context", "tab");

    	if (!tabEntry) {
    		throw new Error("The tab property is required! It should be passed down from the TabBar to the Tab.");
    	}

    	onMount(async () => {
    		if (instantiate !== false) {
    			$$invalidate(20, tab = new MDCTab(element));
    		} else {
    			$$invalidate(20, tab = await getInstance(tabEntry));
    		}

    		tabIndicatorPromiseResolve(tab.tabIndicator_);

    		if (!ripple) {
    			tab.ripple_ && tab.ripple_.destroy();
    		}
    	});

    	onDestroy(() => {
    		tab && tab.destroy();
    	});

    	function getTabIndicatorInstancePromise() {
    		return tabIndicatorPromise;
    	}

    	function interactedHandler() {
    		$$invalidate(0, active = tab.active);
    	}

    	function activate(...args) {
    		$$invalidate(0, active = true);
    		return tab.activate(...args);
    	}

    	function deactivate(...args) {
    		$$invalidate(0, active = false);
    		return tab.deactivate(...args);
    	}

    	function focus(...args) {
    		return tab.focus(...args);
    	}

    	function computeIndicatorClientRect(...args) {
    		return tab.computeIndicatorClientRect(...args);
    	}

    	function computeDimensions(...args) {
    		return tab.computeDimensions(...args);
    	}

    	let { $$slots = {}, $$scope } = $$props;

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(9, element = $$value);
    		});
    	}

    	$$self.$set = $$new_props => {
    		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("tab" in $$new_props) $$invalidate(13, tabEntry = $$new_props.tab);
    		if ("ripple" in $$new_props) $$invalidate(3, ripple = $$new_props.ripple);
    		if ("active" in $$new_props) $$invalidate(0, active = $$new_props.active);
    		if ("stacked" in $$new_props) $$invalidate(4, stacked = $$new_props.stacked);
    		if ("minWidth" in $$new_props) $$invalidate(5, minWidth = $$new_props.minWidth);
    		if ("indicatorSpanOnlyContent" in $$new_props) $$invalidate(6, indicatorSpanOnlyContent = $$new_props.indicatorSpanOnlyContent);
    		if ("focusOnActivate" in $$new_props) $$invalidate(14, focusOnActivate = $$new_props.focusOnActivate);
    		if ("content$use" in $$new_props) $$invalidate(7, content$use = $$new_props.content$use);
    		if ("content$class" in $$new_props) $$invalidate(8, content$class = $$new_props.content$class);
    		if ("$$scope" in $$new_props) $$invalidate(29, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			activeEntry,
    			use,
    			className,
    			tabEntry,
    			ripple,
    			active,
    			stacked,
    			minWidth,
    			indicatorSpanOnlyContent,
    			focusOnActivate,
    			content$use,
    			content$class,
    			element,
    			tab,
    			instantiate,
    			getInstance,
    			tabIndicatorPromiseResolve,
    			tabIndicatorPromise
    		};
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
    		if ("activeEntry" in $$props) activeEntry = $$new_props.activeEntry;
    		if ("use" in $$props) $$invalidate(1, use = $$new_props.use);
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("tabEntry" in $$props) $$invalidate(13, tabEntry = $$new_props.tabEntry);
    		if ("ripple" in $$props) $$invalidate(3, ripple = $$new_props.ripple);
    		if ("active" in $$props) $$invalidate(0, active = $$new_props.active);
    		if ("stacked" in $$props) $$invalidate(4, stacked = $$new_props.stacked);
    		if ("minWidth" in $$props) $$invalidate(5, minWidth = $$new_props.minWidth);
    		if ("indicatorSpanOnlyContent" in $$props) $$invalidate(6, indicatorSpanOnlyContent = $$new_props.indicatorSpanOnlyContent);
    		if ("focusOnActivate" in $$props) $$invalidate(14, focusOnActivate = $$new_props.focusOnActivate);
    		if ("content$use" in $$props) $$invalidate(7, content$use = $$new_props.content$use);
    		if ("content$class" in $$props) $$invalidate(8, content$class = $$new_props.content$class);
    		if ("element" in $$props) $$invalidate(9, element = $$new_props.element);
    		if ("tab" in $$props) $$invalidate(20, tab = $$new_props.tab);
    		if ("instantiate" in $$props) instantiate = $$new_props.instantiate;
    		if ("getInstance" in $$props) getInstance = $$new_props.getInstance;
    		if ("tabIndicatorPromiseResolve" in $$props) tabIndicatorPromiseResolve = $$new_props.tabIndicatorPromiseResolve;
    		if ("tabIndicatorPromise" in $$props) tabIndicatorPromise = $$new_props.tabIndicatorPromise;
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*tab, focusOnActivate*/ 1064960) {
    			 if (tab) {
    				$$invalidate(20, tab.focusOnActivate = focusOnActivate, tab);
    			}
    		}

    		if ($$self.$$.dirty & /*tab, active*/ 1048577) {
    			 if (tab && tab.active !== active) {
    				$$invalidate(0, active = tab.active);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		active,
    		use,
    		className,
    		ripple,
    		stacked,
    		minWidth,
    		indicatorSpanOnlyContent,
    		content$use,
    		content$class,
    		element,
    		forwardEvents,
    		interactedHandler,
    		$$props,
    		tabEntry,
    		focusOnActivate,
    		activate,
    		deactivate,
    		focus,
    		computeIndicatorClientRect,
    		computeDimensions,
    		tab,
    		tabIndicatorPromiseResolve,
    		activeEntry,
    		instantiate,
    		getInstance,
    		tabIndicatorPromise,
    		getTabIndicatorInstancePromise,
    		$$slots,
    		button_binding,
    		$$scope
    	];
    }

    class Tab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
    			use: 1,
    			class: 2,
    			tab: 13,
    			ripple: 3,
    			active: 0,
    			stacked: 4,
    			minWidth: 5,
    			indicatorSpanOnlyContent: 6,
    			focusOnActivate: 14,
    			content$use: 7,
    			content$class: 8,
    			activate: 15,
    			deactivate: 16,
    			focus: 17,
    			computeIndicatorClientRect: 18,
    			computeDimensions: 19
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tab",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*tabEntry*/ ctx[13] === undefined && !("tab" in props)) {
    			console.warn("<Tab> was created without expected prop 'tab'");
    		}
    	}

    	get use() {
    		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tab() {
    		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tab(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ripple() {
    		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ripple(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stacked() {
    		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stacked(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minWidth() {
    		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minWidth(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicatorSpanOnlyContent() {
    		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicatorSpanOnlyContent(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusOnActivate() {
    		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusOnActivate(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content$use() {
    		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content$use(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content$class() {
    		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content$class(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activate() {
    		return this.$$.ctx[15];
    	}

    	set activate(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get deactivate() {
    		return this.$$.ctx[16];
    	}

    	set deactivate(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focus() {
    		return this.$$.ctx[17];
    	}

    	set focus(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get computeIndicatorClientRect() {
    		return this.$$.ctx[18];
    	}

    	set computeIndicatorClientRect(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get computeDimensions() {
    		return this.$$.ctx[19];
    	}

    	set computeDimensions(value) {
    		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var css$5 = ".mdc-button{padding:0;min-width:24px}.mdc-button:after,.mdc-button:before{background:none}.mdc-menu{max-width:450px}.mdc-menu-surface{top:50px!important}.mdc-tab-bar{position:static}.mdc-list{height:300px;overflow:hidden;overflow-y:scroll;scroll-behavior:smooth;scrollbar-width:5px}::-webkit-scrollbar{width:5px}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px rgba(0,0,0,.3);-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);-webkit-border-radius:5px;border-radius:5px}::-webkit-scrollbar-thumb{-webkit-border-radius:5px;border-radius:5px;background:rgba(196,183,183,.8);-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.5);box-shadow:inset 0 0 6px rgba(0,0,0,.5)}::-webkit-scrollbar-thumb:window-inactive{background:rgba(138,129,129,.4)}.mdc-tab-bar{width:100%}.mdc-tab-scroller{overflow-y:hidden}.mdc-tab-scroller__test{position:absolute;top:-9999px;width:100px;height:100px;overflow-x:scroll}.mdc-tab-scroller__scroll-area{-webkit-overflow-scrolling:touch;display:flex;overflow-x:hidden}.mdc-tab-scroller__scroll-area::-webkit-scrollbar,.mdc-tab-scroller__test::-webkit-scrollbar{display:none}.mdc-tab-scroller__scroll-area--scroll{overflow-x:scroll}.mdc-tab-scroller__scroll-content{position:relative;display:flex;flex:1 0 auto;transform:none;will-change:transform}.mdc-tab-scroller--align-start .mdc-tab-scroller__scroll-content{justify-content:flex-start}.mdc-tab-scroller--align-end .mdc-tab-scroller__scroll-content{justify-content:flex-end}.mdc-tab-scroller--align-center .mdc-tab-scroller__scroll-content{justify-content:center}.mdc-tab-scroller--animating .mdc-tab-scroller__scroll-area{-webkit-overflow-scrolling:auto}.mdc-tab-scroller--animating .mdc-tab-scroller__scroll-content{transition:transform .25s cubic-bezier(.4,0,.2,1)}";
    styleInject(css$5);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$7 = {
        ANIMATING: 'mdc-tab-scroller--animating',
        SCROLL_AREA_SCROLL: 'mdc-tab-scroller__scroll-area--scroll',
        SCROLL_TEST: 'mdc-tab-scroller__test',
    };
    var strings$8 = {
        AREA_SELECTOR: '.mdc-tab-scroller__scroll-area',
        CONTENT_SELECTOR: '.mdc-tab-scroller__scroll-content',
    };
    //# sourceMappingURL=constants.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabScrollerRTL = /** @class */ (function () {
        function MDCTabScrollerRTL(adapter) {
            this.adapter_ = adapter;
        }
        return MDCTabScrollerRTL;
    }());
    //# sourceMappingURL=rtl-scroller.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabScrollerRTLDefault = /** @class */ (function (_super) {
        __extends(MDCTabScrollerRTLDefault, _super);
        function MDCTabScrollerRTLDefault() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTabScrollerRTLDefault.prototype.getScrollPositionRTL = function () {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            var right = this.calculateScrollEdges_().right;
            // Scroll values on most browsers are ints instead of floats so we round
            return Math.round(right - currentScrollLeft);
        };
        MDCTabScrollerRTLDefault.prototype.scrollToRTL = function (scrollX) {
            var edges = this.calculateScrollEdges_();
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            var clampedScrollLeft = this.clampScrollValue_(edges.right - scrollX);
            return {
                finalScrollPosition: clampedScrollLeft,
                scrollDelta: clampedScrollLeft - currentScrollLeft,
            };
        };
        MDCTabScrollerRTLDefault.prototype.incrementScrollRTL = function (scrollX) {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
            return {
                finalScrollPosition: clampedScrollLeft,
                scrollDelta: clampedScrollLeft - currentScrollLeft,
            };
        };
        MDCTabScrollerRTLDefault.prototype.getAnimatingScrollPosition = function (scrollX) {
            return scrollX;
        };
        MDCTabScrollerRTLDefault.prototype.calculateScrollEdges_ = function () {
            var contentWidth = this.adapter_.getScrollContentOffsetWidth();
            var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
            return {
                left: 0,
                right: contentWidth - rootWidth,
            };
        };
        MDCTabScrollerRTLDefault.prototype.clampScrollValue_ = function (scrollX) {
            var edges = this.calculateScrollEdges_();
            return Math.min(Math.max(edges.left, scrollX), edges.right);
        };
        return MDCTabScrollerRTLDefault;
    }(MDCTabScrollerRTL));
    //# sourceMappingURL=rtl-default-scroller.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabScrollerRTLNegative = /** @class */ (function (_super) {
        __extends(MDCTabScrollerRTLNegative, _super);
        function MDCTabScrollerRTLNegative() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTabScrollerRTLNegative.prototype.getScrollPositionRTL = function (translateX) {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            return Math.round(translateX - currentScrollLeft);
        };
        MDCTabScrollerRTLNegative.prototype.scrollToRTL = function (scrollX) {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            var clampedScrollLeft = this.clampScrollValue_(-scrollX);
            return {
                finalScrollPosition: clampedScrollLeft,
                scrollDelta: clampedScrollLeft - currentScrollLeft,
            };
        };
        MDCTabScrollerRTLNegative.prototype.incrementScrollRTL = function (scrollX) {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
            return {
                finalScrollPosition: clampedScrollLeft,
                scrollDelta: clampedScrollLeft - currentScrollLeft,
            };
        };
        MDCTabScrollerRTLNegative.prototype.getAnimatingScrollPosition = function (scrollX, translateX) {
            return scrollX - translateX;
        };
        MDCTabScrollerRTLNegative.prototype.calculateScrollEdges_ = function () {
            var contentWidth = this.adapter_.getScrollContentOffsetWidth();
            var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
            return {
                left: rootWidth - contentWidth,
                right: 0,
            };
        };
        MDCTabScrollerRTLNegative.prototype.clampScrollValue_ = function (scrollX) {
            var edges = this.calculateScrollEdges_();
            return Math.max(Math.min(edges.right, scrollX), edges.left);
        };
        return MDCTabScrollerRTLNegative;
    }(MDCTabScrollerRTL));
    //# sourceMappingURL=rtl-negative-scroller.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabScrollerRTLReverse = /** @class */ (function (_super) {
        __extends(MDCTabScrollerRTLReverse, _super);
        function MDCTabScrollerRTLReverse() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTabScrollerRTLReverse.prototype.getScrollPositionRTL = function (translateX) {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            // Scroll values on most browsers are ints instead of floats so we round
            return Math.round(currentScrollLeft - translateX);
        };
        MDCTabScrollerRTLReverse.prototype.scrollToRTL = function (scrollX) {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            var clampedScrollLeft = this.clampScrollValue_(scrollX);
            return {
                finalScrollPosition: clampedScrollLeft,
                scrollDelta: currentScrollLeft - clampedScrollLeft,
            };
        };
        MDCTabScrollerRTLReverse.prototype.incrementScrollRTL = function (scrollX) {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft + scrollX);
            return {
                finalScrollPosition: clampedScrollLeft,
                scrollDelta: currentScrollLeft - clampedScrollLeft,
            };
        };
        MDCTabScrollerRTLReverse.prototype.getAnimatingScrollPosition = function (scrollX, translateX) {
            return scrollX + translateX;
        };
        MDCTabScrollerRTLReverse.prototype.calculateScrollEdges_ = function () {
            var contentWidth = this.adapter_.getScrollContentOffsetWidth();
            var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
            return {
                left: contentWidth - rootWidth,
                right: 0,
            };
        };
        MDCTabScrollerRTLReverse.prototype.clampScrollValue_ = function (scrollX) {
            var edges = this.calculateScrollEdges_();
            return Math.min(Math.max(edges.right, scrollX), edges.left);
        };
        return MDCTabScrollerRTLReverse;
    }(MDCTabScrollerRTL));
    //# sourceMappingURL=rtl-reverse-scroller.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabScrollerFoundation = /** @class */ (function (_super) {
        __extends(MDCTabScrollerFoundation, _super);
        function MDCTabScrollerFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCTabScrollerFoundation.defaultAdapter, adapter)) || this;
            /**
             * Controls whether we should handle the transitionend and interaction events during the animation.
             */
            _this.isAnimating_ = false;
            return _this;
        }
        Object.defineProperty(MDCTabScrollerFoundation, "cssClasses", {
            get: function () {
                return cssClasses$7;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabScrollerFoundation, "strings", {
            get: function () {
                return strings$8;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabScrollerFoundation, "defaultAdapter", {
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    eventTargetMatchesSelector: function () { return false; },
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    addScrollAreaClass: function () { return undefined; },
                    setScrollAreaStyleProperty: function () { return undefined; },
                    setScrollContentStyleProperty: function () { return undefined; },
                    getScrollContentStyleValue: function () { return ''; },
                    setScrollAreaScrollLeft: function () { return undefined; },
                    getScrollAreaScrollLeft: function () { return 0; },
                    getScrollContentOffsetWidth: function () { return 0; },
                    getScrollAreaOffsetWidth: function () { return 0; },
                    computeScrollAreaClientRect: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                    computeScrollContentClientRect: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                    computeHorizontalScrollbarHeight: function () { return 0; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCTabScrollerFoundation.prototype.init = function () {
            // Compute horizontal scrollbar height on scroller with overflow initially hidden, then update overflow to scroll
            // and immediately adjust bottom margin to avoid the scrollbar initially appearing before JS runs.
            var horizontalScrollbarHeight = this.adapter_.computeHorizontalScrollbarHeight();
            this.adapter_.setScrollAreaStyleProperty('margin-bottom', -horizontalScrollbarHeight + 'px');
            this.adapter_.addScrollAreaClass(MDCTabScrollerFoundation.cssClasses.SCROLL_AREA_SCROLL);
        };
        /**
         * Computes the current visual scroll position
         */
        MDCTabScrollerFoundation.prototype.getScrollPosition = function () {
            if (this.isRTL_()) {
                return this.computeCurrentScrollPositionRTL_();
            }
            var currentTranslateX = this.calculateCurrentTranslateX_();
            var scrollLeft = this.adapter_.getScrollAreaScrollLeft();
            return scrollLeft - currentTranslateX;
        };
        /**
         * Handles interaction events that occur during transition
         */
        MDCTabScrollerFoundation.prototype.handleInteraction = function () {
            // Early exit if we aren't animating
            if (!this.isAnimating_) {
                return;
            }
            // Prevent other event listeners from handling this event
            this.stopScrollAnimation_();
        };
        /**
         * Handles the transitionend event
         */
        MDCTabScrollerFoundation.prototype.handleTransitionEnd = function (evt) {
            // Early exit if we aren't animating or the event was triggered by a different element.
            var evtTarget = evt.target;
            if (!this.isAnimating_ ||
                !this.adapter_.eventTargetMatchesSelector(evtTarget, MDCTabScrollerFoundation.strings.CONTENT_SELECTOR)) {
                return;
            }
            this.isAnimating_ = false;
            this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
        };
        /**
         * Increment the scroll value by the scrollXIncrement
         * @param scrollXIncrement The value by which to increment the scroll position
         */
        MDCTabScrollerFoundation.prototype.incrementScroll = function (scrollXIncrement) {
            // Early exit for non-operational increment values
            if (scrollXIncrement === 0) {
                return;
            }
            if (this.isRTL_()) {
                return this.incrementScrollRTL_(scrollXIncrement);
            }
            this.incrementScroll_(scrollXIncrement);
        };
        /**
         * Scrolls to the given scrollX value
         */
        MDCTabScrollerFoundation.prototype.scrollTo = function (scrollX) {
            if (this.isRTL_()) {
                return this.scrollToRTL_(scrollX);
            }
            this.scrollTo_(scrollX);
        };
        /**
         * @return Browser-specific {@link MDCTabScrollerRTL} instance.
         */
        MDCTabScrollerFoundation.prototype.getRTLScroller = function () {
            if (!this.rtlScrollerInstance_) {
                this.rtlScrollerInstance_ = this.rtlScrollerFactory_();
            }
            return this.rtlScrollerInstance_;
        };
        /**
         * @return translateX value from a CSS matrix transform function string.
         */
        MDCTabScrollerFoundation.prototype.calculateCurrentTranslateX_ = function () {
            var transformValue = this.adapter_.getScrollContentStyleValue('transform');
            // Early exit if no transform is present
            if (transformValue === 'none') {
                return 0;
            }
            // The transform value comes back as a matrix transformation in the form
            // of `matrix(a, b, c, d, tx, ty)`. We only care about tx (translateX) so
            // we're going to grab all the parenthesized values, strip out tx, and
            // parse it.
            var match = /\((.+?)\)/.exec(transformValue);
            if (!match) {
                return 0;
            }
            var matrixParams = match[1];
            // tslint:disable-next-line:ban-ts-ignore "Unused vars" should be a linter warning, not a compiler error.
            // @ts-ignore These unused variables should retain their semantic names for clarity.
            var _a = __read(matrixParams.split(','), 6), a = _a[0], b = _a[1], c = _a[2], d = _a[3], tx = _a[4], ty = _a[5];
            return parseFloat(tx); // tslint:disable-line:ban
        };
        /**
         * Calculates a safe scroll value that is > 0 and < the max scroll value
         * @param scrollX The distance to scroll
         */
        MDCTabScrollerFoundation.prototype.clampScrollValue_ = function (scrollX) {
            var edges = this.calculateScrollEdges_();
            return Math.min(Math.max(edges.left, scrollX), edges.right);
        };
        MDCTabScrollerFoundation.prototype.computeCurrentScrollPositionRTL_ = function () {
            var translateX = this.calculateCurrentTranslateX_();
            return this.getRTLScroller().getScrollPositionRTL(translateX);
        };
        MDCTabScrollerFoundation.prototype.calculateScrollEdges_ = function () {
            var contentWidth = this.adapter_.getScrollContentOffsetWidth();
            var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
            return {
                left: 0,
                right: contentWidth - rootWidth,
            };
        };
        /**
         * Internal scroll method
         * @param scrollX The new scroll position
         */
        MDCTabScrollerFoundation.prototype.scrollTo_ = function (scrollX) {
            var currentScrollX = this.getScrollPosition();
            var safeScrollX = this.clampScrollValue_(scrollX);
            var scrollDelta = safeScrollX - currentScrollX;
            this.animate_({
                finalScrollPosition: safeScrollX,
                scrollDelta: scrollDelta,
            });
        };
        /**
         * Internal RTL scroll method
         * @param scrollX The new scroll position
         */
        MDCTabScrollerFoundation.prototype.scrollToRTL_ = function (scrollX) {
            var animation = this.getRTLScroller().scrollToRTL(scrollX);
            this.animate_(animation);
        };
        /**
         * Internal increment scroll method
         * @param scrollX The new scroll position increment
         */
        MDCTabScrollerFoundation.prototype.incrementScroll_ = function (scrollX) {
            var currentScrollX = this.getScrollPosition();
            var targetScrollX = scrollX + currentScrollX;
            var safeScrollX = this.clampScrollValue_(targetScrollX);
            var scrollDelta = safeScrollX - currentScrollX;
            this.animate_({
                finalScrollPosition: safeScrollX,
                scrollDelta: scrollDelta,
            });
        };
        /**
         * Internal increment scroll RTL method
         * @param scrollX The new scroll position RTL increment
         */
        MDCTabScrollerFoundation.prototype.incrementScrollRTL_ = function (scrollX) {
            var animation = this.getRTLScroller().incrementScrollRTL(scrollX);
            this.animate_(animation);
        };
        /**
         * Animates the tab scrolling
         * @param animation The animation to apply
         */
        MDCTabScrollerFoundation.prototype.animate_ = function (animation) {
            var _this = this;
            // Early exit if translateX is 0, which means there's no animation to perform
            if (animation.scrollDelta === 0) {
                return;
            }
            this.stopScrollAnimation_();
            // This animation uses the FLIP approach.
            // Read more here: https://aerotwist.com/blog/flip-your-animations/
            this.adapter_.setScrollAreaScrollLeft(animation.finalScrollPosition);
            this.adapter_.setScrollContentStyleProperty('transform', "translateX(" + animation.scrollDelta + "px)");
            // Force repaint
            this.adapter_.computeScrollAreaClientRect();
            requestAnimationFrame(function () {
                _this.adapter_.addClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
                _this.adapter_.setScrollContentStyleProperty('transform', 'none');
            });
            this.isAnimating_ = true;
        };
        /**
         * Stops scroll animation
         */
        MDCTabScrollerFoundation.prototype.stopScrollAnimation_ = function () {
            this.isAnimating_ = false;
            var currentScrollPosition = this.getAnimatingScrollPosition_();
            this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
            this.adapter_.setScrollContentStyleProperty('transform', 'translateX(0px)');
            this.adapter_.setScrollAreaScrollLeft(currentScrollPosition);
        };
        /**
         * Gets the current scroll position during animation
         */
        MDCTabScrollerFoundation.prototype.getAnimatingScrollPosition_ = function () {
            var currentTranslateX = this.calculateCurrentTranslateX_();
            var scrollLeft = this.adapter_.getScrollAreaScrollLeft();
            if (this.isRTL_()) {
                return this.getRTLScroller().getAnimatingScrollPosition(scrollLeft, currentTranslateX);
            }
            return scrollLeft - currentTranslateX;
        };
        /**
         * Determines the RTL Scroller to use
         */
        MDCTabScrollerFoundation.prototype.rtlScrollerFactory_ = function () {
            // Browsers have three different implementations of scrollLeft in RTL mode,
            // dependent on the browser. The behavior is based off the max LTR
            // scrollLeft value and 0.
            //
            // * Default scrolling in RTL *
            //    - Left-most value: 0
            //    - Right-most value: Max LTR scrollLeft value
            //
            // * Negative scrolling in RTL *
            //    - Left-most value: Negated max LTR scrollLeft value
            //    - Right-most value: 0
            //
            // * Reverse scrolling in RTL *
            //    - Left-most value: Max LTR scrollLeft value
            //    - Right-most value: 0
            //
            // We use those principles below to determine which RTL scrollLeft
            // behavior is implemented in the current browser.
            var initialScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            this.adapter_.setScrollAreaScrollLeft(initialScrollLeft - 1);
            var newScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            // If the newScrollLeft value is negative,then we know that the browser has
            // implemented negative RTL scrolling, since all other implementations have
            // only positive values.
            if (newScrollLeft < 0) {
                // Undo the scrollLeft test check
                this.adapter_.setScrollAreaScrollLeft(initialScrollLeft);
                return new MDCTabScrollerRTLNegative(this.adapter_);
            }
            var rootClientRect = this.adapter_.computeScrollAreaClientRect();
            var contentClientRect = this.adapter_.computeScrollContentClientRect();
            var rightEdgeDelta = Math.round(contentClientRect.right - rootClientRect.right);
            // Undo the scrollLeft test check
            this.adapter_.setScrollAreaScrollLeft(initialScrollLeft);
            // By calculating the clientRect of the root element and the clientRect of
            // the content element, we can determine how much the scroll value changed
            // when we performed the scrollLeft subtraction above.
            if (rightEdgeDelta === newScrollLeft) {
                return new MDCTabScrollerRTLReverse(this.adapter_);
            }
            return new MDCTabScrollerRTLDefault(this.adapter_);
        };
        MDCTabScrollerFoundation.prototype.isRTL_ = function () {
            return this.adapter_.getScrollContentStyleValue('direction') === 'rtl';
        };
        return MDCTabScrollerFoundation;
    }(MDCFoundation));
    //# sourceMappingURL=foundation.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * Stores result from computeHorizontalScrollbarHeight to avoid redundant processing.
     */
    var horizontalScrollbarHeight_;
    /**
     * Computes the height of browser-rendered horizontal scrollbars using a self-created test element.
     * May return 0 (e.g. on OS X browsers under default configuration).
     */
    function computeHorizontalScrollbarHeight(documentObj, shouldCacheResult) {
        if (shouldCacheResult === void 0) { shouldCacheResult = true; }
        if (shouldCacheResult && typeof horizontalScrollbarHeight_ !== 'undefined') {
            return horizontalScrollbarHeight_;
        }
        var el = documentObj.createElement('div');
        el.classList.add(cssClasses$7.SCROLL_TEST);
        documentObj.body.appendChild(el);
        var horizontalScrollbarHeight = el.offsetHeight - el.clientHeight;
        documentObj.body.removeChild(el);
        if (shouldCacheResult) {
            horizontalScrollbarHeight_ = horizontalScrollbarHeight;
        }
        return horizontalScrollbarHeight;
    }
    //# sourceMappingURL=util.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabScroller = /** @class */ (function (_super) {
        __extends(MDCTabScroller, _super);
        function MDCTabScroller() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTabScroller.attachTo = function (root) {
            return new MDCTabScroller(root);
        };
        MDCTabScroller.prototype.initialize = function () {
            this.area_ = this.root_.querySelector(MDCTabScrollerFoundation.strings.AREA_SELECTOR);
            this.content_ = this.root_.querySelector(MDCTabScrollerFoundation.strings.CONTENT_SELECTOR);
        };
        MDCTabScroller.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.handleInteraction_ = function () { return _this.foundation_.handleInteraction(); };
            this.handleTransitionEnd_ = function (evt) { return _this.foundation_.handleTransitionEnd(evt); };
            this.area_.addEventListener('wheel', this.handleInteraction_, applyPassive());
            this.area_.addEventListener('touchstart', this.handleInteraction_, applyPassive());
            this.area_.addEventListener('pointerdown', this.handleInteraction_, applyPassive());
            this.area_.addEventListener('mousedown', this.handleInteraction_, applyPassive());
            this.area_.addEventListener('keydown', this.handleInteraction_, applyPassive());
            this.content_.addEventListener('transitionend', this.handleTransitionEnd_);
        };
        MDCTabScroller.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.area_.removeEventListener('wheel', this.handleInteraction_, applyPassive());
            this.area_.removeEventListener('touchstart', this.handleInteraction_, applyPassive());
            this.area_.removeEventListener('pointerdown', this.handleInteraction_, applyPassive());
            this.area_.removeEventListener('mousedown', this.handleInteraction_, applyPassive());
            this.area_.removeEventListener('keydown', this.handleInteraction_, applyPassive());
            this.content_.removeEventListener('transitionend', this.handleTransitionEnd_);
        };
        MDCTabScroller.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                eventTargetMatchesSelector: function (evtTarget, selector) { return matches$1(evtTarget, selector); },
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                addScrollAreaClass: function (className) { return _this.area_.classList.add(className); },
                setScrollAreaStyleProperty: function (prop, value) { return _this.area_.style.setProperty(prop, value); },
                setScrollContentStyleProperty: function (prop, value) { return _this.content_.style.setProperty(prop, value); },
                getScrollContentStyleValue: function (propName) { return window.getComputedStyle(_this.content_).getPropertyValue(propName); },
                setScrollAreaScrollLeft: function (scrollX) { return _this.area_.scrollLeft = scrollX; },
                getScrollAreaScrollLeft: function () { return _this.area_.scrollLeft; },
                getScrollContentOffsetWidth: function () { return _this.content_.offsetWidth; },
                getScrollAreaOffsetWidth: function () { return _this.area_.offsetWidth; },
                computeScrollAreaClientRect: function () { return _this.area_.getBoundingClientRect(); },
                computeScrollContentClientRect: function () { return _this.content_.getBoundingClientRect(); },
                computeHorizontalScrollbarHeight: function () { return computeHorizontalScrollbarHeight(document); },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCTabScrollerFoundation(adapter);
        };
        /**
         * Returns the current visual scroll position
         */
        MDCTabScroller.prototype.getScrollPosition = function () {
            return this.foundation_.getScrollPosition();
        };
        /**
         * Returns the width of the scroll content
         */
        MDCTabScroller.prototype.getScrollContentWidth = function () {
            return this.content_.offsetWidth;
        };
        /**
         * Increments the scroll value by the given amount
         * @param scrollXIncrement The pixel value by which to increment the scroll value
         */
        MDCTabScroller.prototype.incrementScroll = function (scrollXIncrement) {
            this.foundation_.incrementScroll(scrollXIncrement);
        };
        /**
         * Scrolls to the given pixel position
         * @param scrollX The pixel value to scroll to
         */
        MDCTabScroller.prototype.scrollTo = function (scrollX) {
            this.foundation_.scrollTo(scrollX);
        };
        return MDCTabScroller;
    }(MDCComponent));
    //# sourceMappingURL=component.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings$9 = {
        ARROW_LEFT_KEY: 'ArrowLeft',
        ARROW_RIGHT_KEY: 'ArrowRight',
        END_KEY: 'End',
        ENTER_KEY: 'Enter',
        HOME_KEY: 'Home',
        SPACE_KEY: 'Space',
        TAB_ACTIVATED_EVENT: 'MDCTabBar:activated',
        TAB_SCROLLER_SELECTOR: '.mdc-tab-scroller',
        TAB_SELECTOR: '.mdc-tab',
    };
    var numbers$4 = {
        ARROW_LEFT_KEYCODE: 37,
        ARROW_RIGHT_KEYCODE: 39,
        END_KEYCODE: 35,
        ENTER_KEYCODE: 13,
        EXTRA_SCROLL_AMOUNT: 20,
        HOME_KEYCODE: 36,
        SPACE_KEYCODE: 32,
    };
    //# sourceMappingURL=constants.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var ACCEPTABLE_KEYS = new Set();
    // IE11 has no support for new Set with iterable so we need to initialize this by hand
    ACCEPTABLE_KEYS.add(strings$9.ARROW_LEFT_KEY);
    ACCEPTABLE_KEYS.add(strings$9.ARROW_RIGHT_KEY);
    ACCEPTABLE_KEYS.add(strings$9.END_KEY);
    ACCEPTABLE_KEYS.add(strings$9.HOME_KEY);
    ACCEPTABLE_KEYS.add(strings$9.ENTER_KEY);
    ACCEPTABLE_KEYS.add(strings$9.SPACE_KEY);
    var KEYCODE_MAP = new Map();
    // IE11 has no support for new Map with iterable so we need to initialize this by hand
    KEYCODE_MAP.set(numbers$4.ARROW_LEFT_KEYCODE, strings$9.ARROW_LEFT_KEY);
    KEYCODE_MAP.set(numbers$4.ARROW_RIGHT_KEYCODE, strings$9.ARROW_RIGHT_KEY);
    KEYCODE_MAP.set(numbers$4.END_KEYCODE, strings$9.END_KEY);
    KEYCODE_MAP.set(numbers$4.HOME_KEYCODE, strings$9.HOME_KEY);
    KEYCODE_MAP.set(numbers$4.ENTER_KEYCODE, strings$9.ENTER_KEY);
    KEYCODE_MAP.set(numbers$4.SPACE_KEYCODE, strings$9.SPACE_KEY);
    var MDCTabBarFoundation = /** @class */ (function (_super) {
        __extends(MDCTabBarFoundation, _super);
        function MDCTabBarFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCTabBarFoundation.defaultAdapter, adapter)) || this;
            _this.useAutomaticActivation_ = false;
            return _this;
        }
        Object.defineProperty(MDCTabBarFoundation, "strings", {
            get: function () {
                return strings$9;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabBarFoundation, "numbers", {
            get: function () {
                return numbers$4;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabBarFoundation, "defaultAdapter", {
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    scrollTo: function () { return undefined; },
                    incrementScroll: function () { return undefined; },
                    getScrollPosition: function () { return 0; },
                    getScrollContentWidth: function () { return 0; },
                    getOffsetWidth: function () { return 0; },
                    isRTL: function () { return false; },
                    setActiveTab: function () { return undefined; },
                    activateTabAtIndex: function () { return undefined; },
                    deactivateTabAtIndex: function () { return undefined; },
                    focusTabAtIndex: function () { return undefined; },
                    getTabIndicatorClientRectAtIndex: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                    getTabDimensionsAtIndex: function () { return ({ rootLeft: 0, rootRight: 0, contentLeft: 0, contentRight: 0 }); },
                    getPreviousActiveTabIndex: function () { return -1; },
                    getFocusedTabIndex: function () { return -1; },
                    getIndexOfTabById: function () { return -1; },
                    getTabListLength: function () { return 0; },
                    notifyTabActivated: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Switches between automatic and manual activation modes.
         * See https://www.w3.org/TR/wai-aria-practices/#tabpanel for examples.
         */
        MDCTabBarFoundation.prototype.setUseAutomaticActivation = function (useAutomaticActivation) {
            this.useAutomaticActivation_ = useAutomaticActivation;
        };
        MDCTabBarFoundation.prototype.activateTab = function (index) {
            var previousActiveIndex = this.adapter_.getPreviousActiveTabIndex();
            if (!this.indexIsInRange_(index) || index === previousActiveIndex) {
                return;
            }
            var previousClientRect;
            if (previousActiveIndex !== -1) {
                this.adapter_.deactivateTabAtIndex(previousActiveIndex);
                previousClientRect = this.adapter_.getTabIndicatorClientRectAtIndex(previousActiveIndex);
            }
            this.adapter_.activateTabAtIndex(index, previousClientRect);
            this.scrollIntoView(index);
            this.adapter_.notifyTabActivated(index);
        };
        MDCTabBarFoundation.prototype.handleKeyDown = function (evt) {
            // Get the key from the event
            var key = this.getKeyFromEvent_(evt);
            // Early exit if the event key isn't one of the keyboard navigation keys
            if (key === undefined) {
                return;
            }
            // Prevent default behavior for movement keys, but not for activation keys, since :active is used to apply ripple
            if (!this.isActivationKey_(key)) {
                evt.preventDefault();
            }
            if (this.useAutomaticActivation_) {
                if (this.isActivationKey_(key)) {
                    return;
                }
                var index = this.determineTargetFromKey_(this.adapter_.getPreviousActiveTabIndex(), key);
                this.adapter_.setActiveTab(index);
                this.scrollIntoView(index);
            }
            else {
                var focusedTabIndex = this.adapter_.getFocusedTabIndex();
                if (this.isActivationKey_(key)) {
                    this.adapter_.setActiveTab(focusedTabIndex);
                }
                else {
                    var index = this.determineTargetFromKey_(focusedTabIndex, key);
                    this.adapter_.focusTabAtIndex(index);
                    this.scrollIntoView(index);
                }
            }
        };
        /**
         * Handles the MDCTab:interacted event
         */
        MDCTabBarFoundation.prototype.handleTabInteraction = function (evt) {
            this.adapter_.setActiveTab(this.adapter_.getIndexOfTabById(evt.detail.tabId));
        };
        /**
         * Scrolls the tab at the given index into view
         * @param index The tab index to make visible
         */
        MDCTabBarFoundation.prototype.scrollIntoView = function (index) {
            // Early exit if the index is out of range
            if (!this.indexIsInRange_(index)) {
                return;
            }
            // Always scroll to 0 if scrolling to the 0th index
            if (index === 0) {
                return this.adapter_.scrollTo(0);
            }
            // Always scroll to the max value if scrolling to the Nth index
            // MDCTabScroller.scrollTo() will never scroll past the max possible value
            if (index === this.adapter_.getTabListLength() - 1) {
                return this.adapter_.scrollTo(this.adapter_.getScrollContentWidth());
            }
            if (this.isRTL_()) {
                return this.scrollIntoViewRTL_(index);
            }
            this.scrollIntoView_(index);
        };
        /**
         * Private method for determining the index of the destination tab based on what key was pressed
         * @param origin The original index from which to determine the destination
         * @param key The name of the key
         */
        MDCTabBarFoundation.prototype.determineTargetFromKey_ = function (origin, key) {
            var isRTL = this.isRTL_();
            var maxIndex = this.adapter_.getTabListLength() - 1;
            var shouldGoToEnd = key === strings$9.END_KEY;
            var shouldDecrement = key === strings$9.ARROW_LEFT_KEY && !isRTL || key === strings$9.ARROW_RIGHT_KEY && isRTL;
            var shouldIncrement = key === strings$9.ARROW_RIGHT_KEY && !isRTL || key === strings$9.ARROW_LEFT_KEY && isRTL;
            var index = origin;
            if (shouldGoToEnd) {
                index = maxIndex;
            }
            else if (shouldDecrement) {
                index -= 1;
            }
            else if (shouldIncrement) {
                index += 1;
            }
            else {
                index = 0;
            }
            if (index < 0) {
                index = maxIndex;
            }
            else if (index > maxIndex) {
                index = 0;
            }
            return index;
        };
        /**
         * Calculates the scroll increment that will make the tab at the given index visible
         * @param index The index of the tab
         * @param nextIndex The index of the next tab
         * @param scrollPosition The current scroll position
         * @param barWidth The width of the Tab Bar
         */
        MDCTabBarFoundation.prototype.calculateScrollIncrement_ = function (index, nextIndex, scrollPosition, barWidth) {
            var nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
            var relativeContentLeft = nextTabDimensions.contentLeft - scrollPosition - barWidth;
            var relativeContentRight = nextTabDimensions.contentRight - scrollPosition;
            var leftIncrement = relativeContentRight - numbers$4.EXTRA_SCROLL_AMOUNT;
            var rightIncrement = relativeContentLeft + numbers$4.EXTRA_SCROLL_AMOUNT;
            if (nextIndex < index) {
                return Math.min(leftIncrement, 0);
            }
            return Math.max(rightIncrement, 0);
        };
        /**
         * Calculates the scroll increment that will make the tab at the given index visible in RTL
         * @param index The index of the tab
         * @param nextIndex The index of the next tab
         * @param scrollPosition The current scroll position
         * @param barWidth The width of the Tab Bar
         * @param scrollContentWidth The width of the scroll content
         */
        MDCTabBarFoundation.prototype.calculateScrollIncrementRTL_ = function (index, nextIndex, scrollPosition, barWidth, scrollContentWidth) {
            var nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
            var relativeContentLeft = scrollContentWidth - nextTabDimensions.contentLeft - scrollPosition;
            var relativeContentRight = scrollContentWidth - nextTabDimensions.contentRight - scrollPosition - barWidth;
            var leftIncrement = relativeContentRight + numbers$4.EXTRA_SCROLL_AMOUNT;
            var rightIncrement = relativeContentLeft - numbers$4.EXTRA_SCROLL_AMOUNT;
            if (nextIndex > index) {
                return Math.max(leftIncrement, 0);
            }
            return Math.min(rightIncrement, 0);
        };
        /**
         * Determines the index of the adjacent tab closest to either edge of the Tab Bar
         * @param index The index of the tab
         * @param tabDimensions The dimensions of the tab
         * @param scrollPosition The current scroll position
         * @param barWidth The width of the tab bar
         */
        MDCTabBarFoundation.prototype.findAdjacentTabIndexClosestToEdge_ = function (index, tabDimensions, scrollPosition, barWidth) {
            /**
             * Tabs are laid out in the Tab Scroller like this:
             *
             *    Scroll Position
             *    +---+
             *    |   |   Bar Width
             *    |   +-----------------------------------+
             *    |   |                                   |
             *    |   V                                   V
             *    |   +-----------------------------------+
             *    V   |             Tab Scroller          |
             *    +------------+--------------+-------------------+
             *    |    Tab     |      Tab     |        Tab        |
             *    +------------+--------------+-------------------+
             *        |                                   |
             *        +-----------------------------------+
             *
             * To determine the next adjacent index, we look at the Tab root left and
             * Tab root right, both relative to the scroll position. If the Tab root
             * left is less than 0, then we know it's out of view to the left. If the
             * Tab root right minus the bar width is greater than 0, we know the Tab is
             * out of view to the right. From there, we either increment or decrement
             * the index.
             */
            var relativeRootLeft = tabDimensions.rootLeft - scrollPosition;
            var relativeRootRight = tabDimensions.rootRight - scrollPosition - barWidth;
            var relativeRootDelta = relativeRootLeft + relativeRootRight;
            var leftEdgeIsCloser = relativeRootLeft < 0 || relativeRootDelta < 0;
            var rightEdgeIsCloser = relativeRootRight > 0 || relativeRootDelta > 0;
            if (leftEdgeIsCloser) {
                return index - 1;
            }
            if (rightEdgeIsCloser) {
                return index + 1;
            }
            return -1;
        };
        /**
         * Determines the index of the adjacent tab closest to either edge of the Tab Bar in RTL
         * @param index The index of the tab
         * @param tabDimensions The dimensions of the tab
         * @param scrollPosition The current scroll position
         * @param barWidth The width of the tab bar
         * @param scrollContentWidth The width of the scroller content
         */
        MDCTabBarFoundation.prototype.findAdjacentTabIndexClosestToEdgeRTL_ = function (index, tabDimensions, scrollPosition, barWidth, scrollContentWidth) {
            var rootLeft = scrollContentWidth - tabDimensions.rootLeft - barWidth - scrollPosition;
            var rootRight = scrollContentWidth - tabDimensions.rootRight - scrollPosition;
            var rootDelta = rootLeft + rootRight;
            var leftEdgeIsCloser = rootLeft > 0 || rootDelta > 0;
            var rightEdgeIsCloser = rootRight < 0 || rootDelta < 0;
            if (leftEdgeIsCloser) {
                return index + 1;
            }
            if (rightEdgeIsCloser) {
                return index - 1;
            }
            return -1;
        };
        /**
         * Returns the key associated with a keydown event
         * @param evt The keydown event
         */
        MDCTabBarFoundation.prototype.getKeyFromEvent_ = function (evt) {
            if (ACCEPTABLE_KEYS.has(evt.key)) {
                return evt.key;
            }
            return KEYCODE_MAP.get(evt.keyCode);
        };
        MDCTabBarFoundation.prototype.isActivationKey_ = function (key) {
            return key === strings$9.SPACE_KEY || key === strings$9.ENTER_KEY;
        };
        /**
         * Returns whether a given index is inclusively between the ends
         * @param index The index to test
         */
        MDCTabBarFoundation.prototype.indexIsInRange_ = function (index) {
            return index >= 0 && index < this.adapter_.getTabListLength();
        };
        /**
         * Returns the view's RTL property
         */
        MDCTabBarFoundation.prototype.isRTL_ = function () {
            return this.adapter_.isRTL();
        };
        /**
         * Scrolls the tab at the given index into view for left-to-right user agents.
         * @param index The index of the tab to scroll into view
         */
        MDCTabBarFoundation.prototype.scrollIntoView_ = function (index) {
            var scrollPosition = this.adapter_.getScrollPosition();
            var barWidth = this.adapter_.getOffsetWidth();
            var tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
            var nextIndex = this.findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth);
            if (!this.indexIsInRange_(nextIndex)) {
                return;
            }
            var scrollIncrement = this.calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth);
            this.adapter_.incrementScroll(scrollIncrement);
        };
        /**
         * Scrolls the tab at the given index into view in RTL
         * @param index The tab index to make visible
         */
        MDCTabBarFoundation.prototype.scrollIntoViewRTL_ = function (index) {
            var scrollPosition = this.adapter_.getScrollPosition();
            var barWidth = this.adapter_.getOffsetWidth();
            var tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
            var scrollWidth = this.adapter_.getScrollContentWidth();
            var nextIndex = this.findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollWidth);
            if (!this.indexIsInRange_(nextIndex)) {
                return;
            }
            var scrollIncrement = this.calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollWidth);
            this.adapter_.incrementScroll(scrollIncrement);
        };
        return MDCTabBarFoundation;
    }(MDCFoundation));
    //# sourceMappingURL=foundation.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings$a = MDCTabBarFoundation.strings;
    var tabIdCounter = 0;
    var MDCTabBar = /** @class */ (function (_super) {
        __extends(MDCTabBar, _super);
        function MDCTabBar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTabBar.attachTo = function (root) {
            return new MDCTabBar(root);
        };
        Object.defineProperty(MDCTabBar.prototype, "focusOnActivate", {
            set: function (focusOnActivate) {
                this.tabList_.forEach(function (tab) { return tab.focusOnActivate = focusOnActivate; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabBar.prototype, "useAutomaticActivation", {
            set: function (useAutomaticActivation) {
                this.foundation_.setUseAutomaticActivation(useAutomaticActivation);
            },
            enumerable: true,
            configurable: true
        });
        MDCTabBar.prototype.initialize = function (tabFactory, tabScrollerFactory) {
            if (tabFactory === void 0) { tabFactory = function (el) { return new MDCTab(el); }; }
            if (tabScrollerFactory === void 0) { tabScrollerFactory = function (el) { return new MDCTabScroller(el); }; }
            this.tabList_ = this.instantiateTabs_(tabFactory);
            this.tabScroller_ = this.instantiateTabScroller_(tabScrollerFactory);
        };
        MDCTabBar.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.handleTabInteraction_ = function (evt) { return _this.foundation_.handleTabInteraction(evt); };
            this.handleKeyDown_ = function (evt) { return _this.foundation_.handleKeyDown(evt); };
            this.listen(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
            this.listen('keydown', this.handleKeyDown_);
            for (var i = 0; i < this.tabList_.length; i++) {
                if (this.tabList_[i].active) {
                    this.scrollIntoView(i);
                    break;
                }
            }
        };
        MDCTabBar.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.unlisten(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
            this.unlisten('keydown', this.handleKeyDown_);
            this.tabList_.forEach(function (tab) { return tab.destroy(); });
            if (this.tabScroller_) {
                this.tabScroller_.destroy();
            }
        };
        MDCTabBar.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                scrollTo: function (scrollX) { return _this.tabScroller_.scrollTo(scrollX); },
                incrementScroll: function (scrollXIncrement) { return _this.tabScroller_.incrementScroll(scrollXIncrement); },
                getScrollPosition: function () { return _this.tabScroller_.getScrollPosition(); },
                getScrollContentWidth: function () { return _this.tabScroller_.getScrollContentWidth(); },
                getOffsetWidth: function () { return _this.root_.offsetWidth; },
                isRTL: function () { return window.getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl'; },
                setActiveTab: function (index) { return _this.foundation_.activateTab(index); },
                activateTabAtIndex: function (index, clientRect) { return _this.tabList_[index].activate(clientRect); },
                deactivateTabAtIndex: function (index) { return _this.tabList_[index].deactivate(); },
                focusTabAtIndex: function (index) { return _this.tabList_[index].focus(); },
                getTabIndicatorClientRectAtIndex: function (index) { return _this.tabList_[index].computeIndicatorClientRect(); },
                getTabDimensionsAtIndex: function (index) { return _this.tabList_[index].computeDimensions(); },
                getPreviousActiveTabIndex: function () {
                    for (var i = 0; i < _this.tabList_.length; i++) {
                        if (_this.tabList_[i].active) {
                            return i;
                        }
                    }
                    return -1;
                },
                getFocusedTabIndex: function () {
                    var tabElements = _this.getTabElements_();
                    var activeElement = document.activeElement;
                    return tabElements.indexOf(activeElement);
                },
                getIndexOfTabById: function (id) {
                    for (var i = 0; i < _this.tabList_.length; i++) {
                        if (_this.tabList_[i].id === id) {
                            return i;
                        }
                    }
                    return -1;
                },
                getTabListLength: function () { return _this.tabList_.length; },
                notifyTabActivated: function (index) {
                    return _this.emit(strings$a.TAB_ACTIVATED_EVENT, { index: index }, true);
                },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCTabBarFoundation(adapter);
        };
        /**
         * Activates the tab at the given index
         * @param index The index of the tab
         */
        MDCTabBar.prototype.activateTab = function (index) {
            this.foundation_.activateTab(index);
        };
        /**
         * Scrolls the tab at the given index into view
         * @param index THe index of the tab
         */
        MDCTabBar.prototype.scrollIntoView = function (index) {
            this.foundation_.scrollIntoView(index);
        };
        /**
         * Returns all the tab elements in a nice clean array
         */
        MDCTabBar.prototype.getTabElements_ = function () {
            return [].slice.call(this.root_.querySelectorAll(strings$a.TAB_SELECTOR));
        };
        /**
         * Instantiates tab components on all child tab elements
         */
        MDCTabBar.prototype.instantiateTabs_ = function (tabFactory) {
            return this.getTabElements_().map(function (el) {
                el.id = el.id || "mdc-tab-" + ++tabIdCounter;
                return tabFactory(el);
            });
        };
        /**
         * Instantiates tab scroller component on the child tab scroller element
         */
        MDCTabBar.prototype.instantiateTabScroller_ = function (tabScrollerFactory) {
            var tabScrollerElement = this.root_.querySelector(strings$a.TAB_SCROLLER_SELECTOR);
            if (tabScrollerElement) {
                return tabScrollerFactory(tabScrollerElement);
            }
            return null;
        };
        return MDCTabBar;
    }(MDCComponent));
    //# sourceMappingURL=component.js.map

    /* node_modules\@smui\tab-scroller\TabScroller.svelte generated by Svelte v3.18.1 */
    const file$k = "node_modules\\@smui\\tab-scroller\\TabScroller.svelte";

    function create_fragment$m(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let useActions_action;
    	let useActions_action_1;
    	let useActions_action_2;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

    	let div0_levels = [
    		{
    			class: "mdc-tab-scroller__scroll-content " + /*scrollContent$class*/ ctx[5]
    		},
    		exclude(prefixFilter(/*$$props*/ ctx[8], "scrollContent$"), ["use", "class"])
    	];

    	let div0_data = {};

    	for (let i = 0; i < div0_levels.length; i += 1) {
    		div0_data = assign(div0_data, div0_levels[i]);
    	}

    	let div1_levels = [
    		{
    			class: "mdc-tab-scroller__scroll-area " + /*scrollArea$class*/ ctx[3]
    		},
    		exclude(prefixFilter(/*$$props*/ ctx[8], "scrollArea$"), ["use", "class"])
    	];

    	let div1_data = {};

    	for (let i = 0; i < div1_levels.length; i += 1) {
    		div1_data = assign(div1_data, div1_levels[i]);
    	}

    	let div2_levels = [
    		{
    			class: "mdc-tab-scroller " + /*className*/ ctx[1]
    		},
    		exclude(/*$$props*/ ctx[8], ["use", "class", "scrollArea$", "scrollContent$"])
    	];

    	let div2_data = {};

    	for (let i = 0; i < div2_levels.length; i += 1) {
    		div2_data = assign(div2_data, div2_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div0, div0_data);
    			add_location(div0, file$k, 12, 4, 371);
    			set_attributes(div1, div1_data);
    			add_location(div1, file$k, 7, 2, 188);
    			set_attributes(div2, div2_data);
    			add_location(div2, file$k, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			/*div2_binding*/ ctx[18](div2);
    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, div0, /*scrollContent$use*/ ctx[4])),
    				action_destroyer(useActions_action_1 = useActions.call(null, div1, /*scrollArea$use*/ ctx[2])),
    				action_destroyer(useActions_action_2 = useActions.call(null, div2, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[7].call(null, div2))
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 65536) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[16], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null));
    			}

    			set_attributes(div0, get_spread_update(div0_levels, [
    				dirty & /*scrollContent$class*/ 32 && {
    					class: "mdc-tab-scroller__scroll-content " + /*scrollContent$class*/ ctx[5]
    				},
    				dirty & /*exclude, prefixFilter, $$props*/ 256 && exclude(prefixFilter(/*$$props*/ ctx[8], "scrollContent$"), ["use", "class"])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*scrollContent$use*/ 16) useActions_action.update.call(null, /*scrollContent$use*/ ctx[4]);

    			set_attributes(div1, get_spread_update(div1_levels, [
    				dirty & /*scrollArea$class*/ 8 && {
    					class: "mdc-tab-scroller__scroll-area " + /*scrollArea$class*/ ctx[3]
    				},
    				dirty & /*exclude, prefixFilter, $$props*/ 256 && exclude(prefixFilter(/*$$props*/ ctx[8], "scrollArea$"), ["use", "class"])
    			]));

    			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*scrollArea$use*/ 4) useActions_action_1.update.call(null, /*scrollArea$use*/ ctx[2]);

    			set_attributes(div2, get_spread_update(div2_levels, [
    				dirty & /*className*/ 2 && {
    					class: "mdc-tab-scroller " + /*className*/ ctx[1]
    				},
    				dirty & /*exclude, $$props*/ 256 && exclude(/*$$props*/ ctx[8], ["use", "class", "scrollArea$", "scrollContent$"])
    			]));

    			if (useActions_action_2 && is_function(useActions_action_2.update) && dirty & /*use*/ 1) useActions_action_2.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (default_slot) default_slot.d(detaching);
    			/*div2_binding*/ ctx[18](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { use = [] } = $$props;
    	let { class: className = "" } = $$props;
    	let { scrollArea$use = [] } = $$props;
    	let { scrollArea$class = "" } = $$props;
    	let { scrollContent$use = [] } = $$props;
    	let { scrollContent$class = "" } = $$props;
    	let element;
    	let tabScroller;
    	let instantiate = getContext("SMUI:tab-scroller:instantiate");
    	let getInstance = getContext("SMUI:tab-scroller:getInstance");

    	onMount(async () => {
    		if (instantiate !== false) {
    			tabScroller = new MDCTabScroller(element);
    		} else {
    			tabScroller = await getInstance();
    		}
    	});

    	onDestroy(() => {
    		tabScroller && tabScroller.destroy();
    	});

    	function scrollTo(...args) {
    		return tabScroller.scrollTo(...args);
    	}

    	function incrementScroll(...args) {
    		return tabScroller.incrementScroll(...args);
    	}

    	function getScrollPosition(...args) {
    		return tabScroller.getScrollPosition(...args);
    	}

    	function getScrollContentWidth(...args) {
    		return tabScroller.getScrollContentWidth(...args);
    	}

    	let { $$slots = {}, $$scope } = $$props;

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(6, element = $$value);
    		});
    	}

    	$$self.$set = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ("scrollArea$use" in $$new_props) $$invalidate(2, scrollArea$use = $$new_props.scrollArea$use);
    		if ("scrollArea$class" in $$new_props) $$invalidate(3, scrollArea$class = $$new_props.scrollArea$class);
    		if ("scrollContent$use" in $$new_props) $$invalidate(4, scrollContent$use = $$new_props.scrollContent$use);
    		if ("scrollContent$class" in $$new_props) $$invalidate(5, scrollContent$class = $$new_props.scrollContent$class);
    		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			use,
    			className,
    			scrollArea$use,
    			scrollArea$class,
    			scrollContent$use,
    			scrollContent$class,
    			element,
    			tabScroller,
    			instantiate,
    			getInstance
    		};
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
    		if ("scrollArea$use" in $$props) $$invalidate(2, scrollArea$use = $$new_props.scrollArea$use);
    		if ("scrollArea$class" in $$props) $$invalidate(3, scrollArea$class = $$new_props.scrollArea$class);
    		if ("scrollContent$use" in $$props) $$invalidate(4, scrollContent$use = $$new_props.scrollContent$use);
    		if ("scrollContent$class" in $$props) $$invalidate(5, scrollContent$class = $$new_props.scrollContent$class);
    		if ("element" in $$props) $$invalidate(6, element = $$new_props.element);
    		if ("tabScroller" in $$props) tabScroller = $$new_props.tabScroller;
    		if ("instantiate" in $$props) instantiate = $$new_props.instantiate;
    		if ("getInstance" in $$props) getInstance = $$new_props.getInstance;
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		scrollArea$use,
    		scrollArea$class,
    		scrollContent$use,
    		scrollContent$class,
    		element,
    		forwardEvents,
    		$$props,
    		scrollTo,
    		incrementScroll,
    		getScrollPosition,
    		getScrollContentWidth,
    		tabScroller,
    		instantiate,
    		getInstance,
    		$$scope,
    		$$slots,
    		div2_binding
    	];
    }

    class TabScroller extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
    			use: 0,
    			class: 1,
    			scrollArea$use: 2,
    			scrollArea$class: 3,
    			scrollContent$use: 4,
    			scrollContent$class: 5,
    			scrollTo: 9,
    			incrementScroll: 10,
    			getScrollPosition: 11,
    			getScrollContentWidth: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabScroller",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get use() {
    		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollArea$use() {
    		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollArea$use(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollArea$class() {
    		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollArea$class(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollContent$use() {
    		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollContent$use(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollContent$class() {
    		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollContent$class(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollTo() {
    		return this.$$.ctx[9];
    	}

    	set scrollTo(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get incrementScroll() {
    		return this.$$.ctx[10];
    	}

    	set incrementScroll(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getScrollPosition() {
    		return this.$$.ctx[11];
    	}

    	set getScrollPosition(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getScrollContentWidth() {
    		return this.$$.ctx[12];
    	}

    	set getScrollContentWidth(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\tab-bar\TabBar.svelte generated by Svelte v3.18.1 */
    const file$l = "node_modules\\@smui\\tab-bar\\TabBar.svelte";
    const get_default_slot_changes = dirty => ({ tab: dirty & /*tabs*/ 4 });
    const get_default_slot_context = ctx => ({ tab: /*tab*/ ctx[28] });

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[28] = list[i];
    	child_ctx[30] = i;
    	return child_ctx;
    }

    // (13:4) {#each tabs as tab, i (key(tab))}
    function create_each_block$1(key_2, ctx) {
    	let first;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[25].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[27], get_default_slot_context);

    	const block = {
    		key: key_2,
    		first: null,
    		c: function create() {
    			first = empty();
    			if (default_slot) default_slot.c();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot && default_slot.p && dirty & /*$$scope, tabs*/ 134217732) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[27], get_default_slot_context), get_slot_changes(default_slot_template, /*$$scope*/ ctx[27], dirty, get_default_slot_changes));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(13:4) {#each tabs as tab, i (key(tab))}",
    		ctx
    	});

    	return block;
    }

    // (10:2) <TabScroller     {...prefixFilter($$props, 'tabScroller$')}   >
    function create_default_slot$4(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = /*tabs*/ ctx[2];
    	const get_key = ctx => /*key*/ ctx[3](/*tab*/ ctx[28]);
    	validate_each_keys(ctx, each_value, get_each_context$1, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$1(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const each_value = /*tabs*/ ctx[2];
    			group_outros();
    			validate_each_keys(ctx, each_value, get_each_context$1, get_key);
    			each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$1, each_1_anchor, get_each_context$1);
    			check_outros();
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(10:2) <TabScroller     {...prefixFilter($$props, 'tabScroller$')}   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div;
    	let useActions_action;
    	let forwardEvents_action;
    	let current;
    	let dispose;
    	const tabscroller_spread_levels = [prefixFilter(/*$$props*/ ctx[7], "tabScroller$")];

    	let tabscroller_props = {
    		$$slots: { default: [create_default_slot$4] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < tabscroller_spread_levels.length; i += 1) {
    		tabscroller_props = assign(tabscroller_props, tabscroller_spread_levels[i]);
    	}

    	const tabscroller = new TabScroller({ props: tabscroller_props, $$inline: true });

    	let div_levels = [
    		{
    			class: "mdc-tab-bar " + /*className*/ ctx[1]
    		},
    		{ role: "tablist" },
    		exclude(/*$$props*/ ctx[7], [
    			"use",
    			"class",
    			"tabs",
    			"key",
    			"focusOnActivate",
    			"useAutomaticActivation",
    			"activeIndex",
    			"tabScroller$"
    		])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tabscroller.$$.fragment);
    			set_attributes(div, div_data);
    			add_location(div, file$l, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tabscroller, div, null);
    			/*div_binding*/ ctx[26](div);
    			current = true;

    			dispose = [
    				action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[0])),
    				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[5].call(null, div)),
    				listen_dev(div, "MDCTabBar:activated", /*activatedHandler*/ ctx[6], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			const tabscroller_changes = (dirty & /*prefixFilter, $$props*/ 128)
    			? get_spread_update(tabscroller_spread_levels, [get_spread_object(prefixFilter(/*$$props*/ ctx[7], "tabScroller$"))])
    			: {};

    			if (dirty & /*$$scope, tabs*/ 134217732) {
    				tabscroller_changes.$$scope = { dirty, ctx };
    			}

    			tabscroller.$set(tabscroller_changes);

    			set_attributes(div, get_spread_update(div_levels, [
    				dirty & /*className*/ 2 && {
    					class: "mdc-tab-bar " + /*className*/ ctx[1]
    				},
    				{ role: "tablist" },
    				dirty & /*exclude, $$props*/ 128 && exclude(/*$$props*/ ctx[7], [
    					"use",
    					"class",
    					"tabs",
    					"key",
    					"focusOnActivate",
    					"useAutomaticActivation",
    					"activeIndex",
    					"tabScroller$"
    				])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabscroller.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabscroller.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tabscroller);
    			/*div_binding*/ ctx[26](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component, ["MDCTabBar:activated"]);

    	let uninitializedValue = () => {
    		
    	};

    	let { use = [] } = $$props;
    	let { class: className = "" } = $$props;
    	let { tabs = [] } = $$props;
    	let { key = tab => tab } = $$props;
    	let { focusOnActivate = true } = $$props;
    	let { useAutomaticActivation = true } = $$props;
    	let { activeIndex = uninitializedValue } = $$props;
    	let { active = uninitializedValue } = $$props;

    	if (activeIndex === uninitializedValue && active === uninitializedValue) {
    		activeIndex = 0;
    		active = tabs[0];
    	} else if (activeIndex === uninitializedValue) {
    		activeIndex = tabs.indexOf(active);
    	} else if (active === uninitializedValue) {
    		active = tabs[activeIndex];
    	}

    	let element;
    	let tabBar;
    	let tabScrollerPromiseResolve;
    	let tabScrollerPromise = new Promise(resolve => tabScrollerPromiseResolve = resolve);
    	let tabPromiseResolve = [];
    	let tabPromise = tabs.map((tab, i) => new Promise(resolve => tabPromiseResolve[i] = resolve));
    	setContext("SMUI:tab-scroller:instantiate", false);
    	setContext("SMUI:tab-scroller:getInstance", getTabScrollerInstancePromise);
    	setContext("SMUI:tab:instantiate", false);
    	setContext("SMUI:tab:getInstance", getTabInstancePromise);
    	setContext("SMUI:tab:active", active);
    	let previousActiveIndex = activeIndex;
    	let previousActive = active;

    	onMount(() => {
    		$$invalidate(14, tabBar = new MDCTabBar(element));
    		tabScrollerPromiseResolve(tabBar.tabScroller_);

    		for (let i = 0; i < tabs.length; i++) {
    			tabPromiseResolve[i](tabBar.tabList_[i]);
    		}
    	});

    	onDestroy(() => {
    		tabBar && tabBar.destroy();
    	});

    	function getTabScrollerInstancePromise() {
    		return tabScrollerPromise;
    	}

    	function getTabInstancePromise(tabEntry) {
    		return tabPromise[tabs.indexOf(tabEntry)];
    	}

    	function updateIndexAfterActivate(index) {
    		$$invalidate(8, activeIndex = index);
    		$$invalidate(17, previousActiveIndex = index);
    		$$invalidate(9, active = tabs[index]);
    		$$invalidate(18, previousActive = tabs[index]);
    	}

    	function activatedHandler(e) {
    		updateIndexAfterActivate(e.detail.index);
    	}

    	function activateTab(index, ...args) {
    		updateIndexAfterActivate(index);
    		return tabBar.activateTab(index, ...args);
    	}

    	function scrollIntoView(...args) {
    		return tabBar.scrollIntoView(...args);
    	}

    	let { $$slots = {}, $$scope } = $$props;

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(4, element = $$value);
    		});
    	}

    	$$self.$set = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ("tabs" in $$new_props) $$invalidate(2, tabs = $$new_props.tabs);
    		if ("key" in $$new_props) $$invalidate(3, key = $$new_props.key);
    		if ("focusOnActivate" in $$new_props) $$invalidate(10, focusOnActivate = $$new_props.focusOnActivate);
    		if ("useAutomaticActivation" in $$new_props) $$invalidate(11, useAutomaticActivation = $$new_props.useAutomaticActivation);
    		if ("activeIndex" in $$new_props) $$invalidate(8, activeIndex = $$new_props.activeIndex);
    		if ("active" in $$new_props) $$invalidate(9, active = $$new_props.active);
    		if ("$$scope" in $$new_props) $$invalidate(27, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			uninitializedValue,
    			use,
    			className,
    			tabs,
    			key,
    			focusOnActivate,
    			useAutomaticActivation,
    			activeIndex,
    			active,
    			element,
    			tabBar,
    			tabScrollerPromiseResolve,
    			tabScrollerPromise,
    			tabPromiseResolve,
    			tabPromise,
    			previousActiveIndex,
    			previousActive
    		};
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    		if ("uninitializedValue" in $$props) uninitializedValue = $$new_props.uninitializedValue;
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
    		if ("tabs" in $$props) $$invalidate(2, tabs = $$new_props.tabs);
    		if ("key" in $$props) $$invalidate(3, key = $$new_props.key);
    		if ("focusOnActivate" in $$props) $$invalidate(10, focusOnActivate = $$new_props.focusOnActivate);
    		if ("useAutomaticActivation" in $$props) $$invalidate(11, useAutomaticActivation = $$new_props.useAutomaticActivation);
    		if ("activeIndex" in $$props) $$invalidate(8, activeIndex = $$new_props.activeIndex);
    		if ("active" in $$props) $$invalidate(9, active = $$new_props.active);
    		if ("element" in $$props) $$invalidate(4, element = $$new_props.element);
    		if ("tabBar" in $$props) $$invalidate(14, tabBar = $$new_props.tabBar);
    		if ("tabScrollerPromiseResolve" in $$props) tabScrollerPromiseResolve = $$new_props.tabScrollerPromiseResolve;
    		if ("tabScrollerPromise" in $$props) tabScrollerPromise = $$new_props.tabScrollerPromise;
    		if ("tabPromiseResolve" in $$props) tabPromiseResolve = $$new_props.tabPromiseResolve;
    		if ("tabPromise" in $$props) tabPromise = $$new_props.tabPromise;
    		if ("previousActiveIndex" in $$props) $$invalidate(17, previousActiveIndex = $$new_props.previousActiveIndex);
    		if ("previousActive" in $$props) $$invalidate(18, previousActive = $$new_props.previousActive);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*tabBar, focusOnActivate*/ 17408) {
    			 if (tabBar) {
    				$$invalidate(14, tabBar.focusOnActivate = focusOnActivate, tabBar);
    			}
    		}

    		if ($$self.$$.dirty & /*tabBar, useAutomaticActivation*/ 18432) {
    			 if (tabBar) {
    				$$invalidate(14, tabBar.useAutomaticActivation = useAutomaticActivation, tabBar);
    			}
    		}

    		if ($$self.$$.dirty & /*tabBar, tabs, activeIndex*/ 16644) {
    			 if (tabBar) {
    				$$invalidate(9, active = tabs[activeIndex]);
    			}
    		}

    		if ($$self.$$.dirty & /*tabBar, previousActiveIndex, activeIndex*/ 147712) {
    			 if (tabBar && previousActiveIndex !== activeIndex) {
    				activateTab(activeIndex);
    			}
    		}

    		if ($$self.$$.dirty & /*tabBar, previousActive, active, tabs*/ 279044) {
    			 if (tabBar && previousActive !== active) {
    				activateTab(tabs.indexOf(active));
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		tabs,
    		key,
    		element,
    		forwardEvents,
    		activatedHandler,
    		$$props,
    		activeIndex,
    		active,
    		focusOnActivate,
    		useAutomaticActivation,
    		activateTab,
    		scrollIntoView,
    		tabBar,
    		tabScrollerPromiseResolve,
    		tabPromiseResolve,
    		previousActiveIndex,
    		previousActive,
    		uninitializedValue,
    		tabScrollerPromise,
    		tabPromise,
    		getTabScrollerInstancePromise,
    		getTabInstancePromise,
    		updateIndexAfterActivate,
    		$$slots,
    		div_binding,
    		$$scope
    	];
    }

    class TabBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
    			use: 0,
    			class: 1,
    			tabs: 2,
    			key: 3,
    			focusOnActivate: 10,
    			useAutomaticActivation: 11,
    			activeIndex: 8,
    			active: 9,
    			activateTab: 12,
    			scrollIntoView: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabBar",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get use() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabs() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabs(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusOnActivate() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusOnActivate(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get useAutomaticActivation() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set useAutomaticActivation(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeIndex() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeIndex(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activateTab() {
    		return this.$$.ctx[12];
    	}

    	set activateTab(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollIntoView() {
    		return this.$$.ctx[13];
    	}

    	set scrollIntoView(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var css$6 = ".mdc-button{padding:0;min-width:24px}.mdc-button:after,.mdc-button:before{background:none}.mdc-menu{max-width:450px}.mdc-menu-surface{top:50px!important}.mdc-tab-bar{position:static}.mdc-list{height:300px;overflow:hidden;overflow-y:scroll;scroll-behavior:smooth;scrollbar-width:5px}::-webkit-scrollbar{width:5px}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px rgba(0,0,0,.3);-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);-webkit-border-radius:5px;border-radius:5px}::-webkit-scrollbar-thumb{-webkit-border-radius:5px;border-radius:5px;background:rgba(196,183,183,.8);-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.5);box-shadow:inset 0 0 6px rgba(0,0,0,.5)}::-webkit-scrollbar-thumb:window-inactive{background:rgba(138,129,129,.4)}@keyframes mdc-ripple-fg-radius-in{0%{animation-timing-function:cubic-bezier(.4,0,.2,1);transform:translate(var(--mdc-ripple-fg-translate-start,0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}}@keyframes mdc-ripple-fg-opacity-in{0%{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity,0)}}@keyframes mdc-ripple-fg-opacity-out{0%{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity,0)}to{opacity:0}}.mdc-ripple-surface--test-edge-var-bug{--mdc-ripple-surface-test-edge-var:1px solid #000;visibility:hidden}.mdc-ripple-surface--test-edge-var-bug:before{border:var(--mdc-ripple-surface-test-edge-var)}.mdc-menu{min-width:112px}.mdc-menu .mdc-list,.mdc-menu .mdc-list-item__graphic,.mdc-menu .mdc-list-item__meta{color:rgba(0,0,0,.87)}.mdc-menu .mdc-list-divider{margin:8px 0}.mdc-menu .mdc-list-item{user-select:none}.mdc-menu .mdc-list-item--disabled{cursor:auto}@media screen and (-ms-high-contrast:active){.mdc-menu .mdc-list-item--disabled{opacity:.38}}.mdc-menu a.mdc-list-item .mdc-list-item__graphic,.mdc-menu a.mdc-list-item .mdc-list-item__text{pointer-events:none}.mdc-menu__selection-group{padding:0;fill:currentColor}.mdc-menu__selection-group .mdc-list-item{padding-left:56px;padding-right:16px}.mdc-menu__selection-group .mdc-list-item[dir=rtl],[dir=rtl] .mdc-menu__selection-group .mdc-list-item{padding-left:16px;padding-right:56px}.mdc-menu__selection-group .mdc-menu__selection-group-icon{left:16px;right:auto;display:none;position:absolute;top:50%;transform:translateY(-50%)}.mdc-menu__selection-group .mdc-menu__selection-group-icon[dir=rtl],[dir=rtl] .mdc-menu__selection-group .mdc-menu__selection-group-icon{left:auto;right:16px}.mdc-menu-item--selected .mdc-menu__selection-group-icon{display:inline}.mdc-menu-surface{display:none;position:absolute;box-sizing:border-box;max-width:calc(100vw - 32px);max-height:calc(100vh - 32px);margin:0;padding:0;transform:scale(1);transform-origin:top left;opacity:0;overflow:auto;will-change:transform,opacity;z-index:8;transition:opacity .03s linear,transform .12s cubic-bezier(0,0,.2,1);box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);background-color:#fff;background-color:var(--mdc-theme-surface,#fff);color:#000;color:var(--mdc-theme-on-surface,#000);border-radius:4px;transform-origin-left:top left;transform-origin-right:top right}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--open{display:inline-block;transform:scale(1);opacity:1}.mdc-menu-surface--animating-open{display:inline-block;transform:scale(.8);opacity:0}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0;transition:opacity 75ms linear}.mdc-menu-surface[dir=rtl],[dir=rtl] .mdc-menu-surface{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{position:relative;overflow:visible}.mdc-menu-surface--fixed{position:fixed}.smui-menu-surface--static{position:static;z-index:0;display:inline-block;transform:scale(1);opacity:1}";
    styleInject(css$6);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$8 = {
        MENU_SELECTED_LIST_ITEM: 'mdc-menu-item--selected',
        MENU_SELECTION_GROUP: 'mdc-menu__selection-group',
        ROOT: 'mdc-menu',
    };
    var strings$b = {
        ARIA_CHECKED_ATTR: 'aria-checked',
        ARIA_DISABLED_ATTR: 'aria-disabled',
        CHECKBOX_SELECTOR: 'input[type="checkbox"]',
        LIST_SELECTOR: '.mdc-list',
        SELECTED_EVENT: 'MDCMenu:selected',
    };
    var numbers$5 = {
        FOCUS_ROOT_INDEX: -1,
    };
    var DefaultFocusState;
    (function (DefaultFocusState) {
        DefaultFocusState[DefaultFocusState["NONE"] = 0] = "NONE";
        DefaultFocusState[DefaultFocusState["LIST_ROOT"] = 1] = "LIST_ROOT";
        DefaultFocusState[DefaultFocusState["FIRST_ITEM"] = 2] = "FIRST_ITEM";
        DefaultFocusState[DefaultFocusState["LAST_ITEM"] = 3] = "LAST_ITEM";
    })(DefaultFocusState || (DefaultFocusState = {}));
    //# sourceMappingURL=constants.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCMenuFoundation = /** @class */ (function (_super) {
        __extends(MDCMenuFoundation, _super);
        function MDCMenuFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCMenuFoundation.defaultAdapter, adapter)) || this;
            _this.closeAnimationEndTimerId_ = 0;
            _this.defaultFocusState_ = DefaultFocusState.LIST_ROOT;
            return _this;
        }
        Object.defineProperty(MDCMenuFoundation, "cssClasses", {
            get: function () {
                return cssClasses$8;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenuFoundation, "strings", {
            get: function () {
                return strings$b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenuFoundation, "numbers", {
            get: function () {
                return numbers$5;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenuFoundation, "defaultAdapter", {
            /**
             * @see {@link MDCMenuAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClassToElementAtIndex: function () { return undefined; },
                    removeClassFromElementAtIndex: function () { return undefined; },
                    addAttributeToElementAtIndex: function () { return undefined; },
                    removeAttributeFromElementAtIndex: function () { return undefined; },
                    elementContainsClass: function () { return false; },
                    closeSurface: function () { return undefined; },
                    getElementIndex: function () { return -1; },
                    notifySelected: function () { return undefined; },
                    getMenuItemCount: function () { return 0; },
                    focusItemAtIndex: function () { return undefined; },
                    focusListRoot: function () { return undefined; },
                    getSelectedSiblingOfItemAtIndex: function () { return -1; },
                    isSelectableItemAtIndex: function () { return false; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCMenuFoundation.prototype.destroy = function () {
            if (this.closeAnimationEndTimerId_) {
                clearTimeout(this.closeAnimationEndTimerId_);
            }
            this.adapter_.closeSurface();
        };
        MDCMenuFoundation.prototype.handleKeydown = function (evt) {
            var key = evt.key, keyCode = evt.keyCode;
            var isTab = key === 'Tab' || keyCode === 9;
            if (isTab) {
                this.adapter_.closeSurface(/** skipRestoreFocus */ true);
            }
        };
        MDCMenuFoundation.prototype.handleItemAction = function (listItem) {
            var _this = this;
            var index = this.adapter_.getElementIndex(listItem);
            if (index < 0) {
                return;
            }
            this.adapter_.notifySelected({ index: index });
            this.adapter_.closeSurface();
            // Wait for the menu to close before adding/removing classes that affect styles.
            this.closeAnimationEndTimerId_ = setTimeout(function () {
                // Recompute the index in case the menu contents have changed.
                var recomputedIndex = _this.adapter_.getElementIndex(listItem);
                if (_this.adapter_.isSelectableItemAtIndex(recomputedIndex)) {
                    _this.setSelectedIndex(recomputedIndex);
                }
            }, MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
        };
        MDCMenuFoundation.prototype.handleMenuSurfaceOpened = function () {
            switch (this.defaultFocusState_) {
                case DefaultFocusState.FIRST_ITEM:
                    this.adapter_.focusItemAtIndex(0);
                    break;
                case DefaultFocusState.LAST_ITEM:
                    this.adapter_.focusItemAtIndex(this.adapter_.getMenuItemCount() - 1);
                    break;
                case DefaultFocusState.NONE:
                    // Do nothing.
                    break;
                default:
                    this.adapter_.focusListRoot();
                    break;
            }
        };
        /**
         * Sets default focus state where the menu should focus every time when menu
         * is opened. Focuses the list root (`DefaultFocusState.LIST_ROOT`) element by
         * default.
         */
        MDCMenuFoundation.prototype.setDefaultFocusState = function (focusState) {
            this.defaultFocusState_ = focusState;
        };
        /**
         * Selects the list item at `index` within the menu.
         * @param index Index of list item within the menu.
         */
        MDCMenuFoundation.prototype.setSelectedIndex = function (index) {
            this.validatedIndex_(index);
            if (!this.adapter_.isSelectableItemAtIndex(index)) {
                throw new Error('MDCMenuFoundation: No selection group at specified index.');
            }
            var prevSelectedIndex = this.adapter_.getSelectedSiblingOfItemAtIndex(index);
            if (prevSelectedIndex >= 0) {
                this.adapter_.removeAttributeFromElementAtIndex(prevSelectedIndex, strings$b.ARIA_CHECKED_ATTR);
                this.adapter_.removeClassFromElementAtIndex(prevSelectedIndex, cssClasses$8.MENU_SELECTED_LIST_ITEM);
            }
            this.adapter_.addClassToElementAtIndex(index, cssClasses$8.MENU_SELECTED_LIST_ITEM);
            this.adapter_.addAttributeToElementAtIndex(index, strings$b.ARIA_CHECKED_ATTR, 'true');
        };
        /**
         * Sets the enabled state to isEnabled for the menu item at the given index.
         * @param index Index of the menu item
         * @param isEnabled The desired enabled state of the menu item.
         */
        MDCMenuFoundation.prototype.setEnabled = function (index, isEnabled) {
            this.validatedIndex_(index);
            if (isEnabled) {
                this.adapter_.removeClassFromElementAtIndex(index, cssClasses$3.LIST_ITEM_DISABLED_CLASS);
                this.adapter_.addAttributeToElementAtIndex(index, strings$b.ARIA_DISABLED_ATTR, 'false');
            }
            else {
                this.adapter_.addClassToElementAtIndex(index, cssClasses$3.LIST_ITEM_DISABLED_CLASS);
                this.adapter_.addAttributeToElementAtIndex(index, strings$b.ARIA_DISABLED_ATTR, 'true');
            }
        };
        MDCMenuFoundation.prototype.validatedIndex_ = function (index) {
            var menuSize = this.adapter_.getMenuItemCount();
            var isIndexInRange = index >= 0 && index < menuSize;
            if (!isIndexInRange) {
                throw new Error('MDCMenuFoundation: No list item at specified index.');
            }
        };
        return MDCMenuFoundation;
    }(MDCFoundation));
    //# sourceMappingURL=foundation.js.map

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCMenu = /** @class */ (function (_super) {
        __extends(MDCMenu, _super);
        function MDCMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCMenu.attachTo = function (root) {
            return new MDCMenu(root);
        };
        MDCMenu.prototype.initialize = function (menuSurfaceFactory, listFactory) {
            if (menuSurfaceFactory === void 0) { menuSurfaceFactory = function (el) { return new MDCMenuSurface(el); }; }
            if (listFactory === void 0) { listFactory = function (el) { return new MDCList(el); }; }
            this.menuSurfaceFactory_ = menuSurfaceFactory;
            this.listFactory_ = listFactory;
        };
        MDCMenu.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.menuSurface_ = this.menuSurfaceFactory_(this.root_);
            var list = this.root_.querySelector(strings$b.LIST_SELECTOR);
            if (list) {
                this.list_ = this.listFactory_(list);
                this.list_.wrapFocus = true;
            }
            else {
                this.list_ = null;
            }
            this.handleKeydown_ = function (evt) { return _this.foundation_.handleKeydown(evt); };
            this.handleItemAction_ = function (evt) { return _this.foundation_.handleItemAction(_this.items[evt.detail.index]); };
            this.handleMenuSurfaceOpened_ = function () { return _this.foundation_.handleMenuSurfaceOpened(); };
            this.menuSurface_.listen(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened_);
            this.listen('keydown', this.handleKeydown_);
            this.listen(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction_);
        };
        MDCMenu.prototype.destroy = function () {
            if (this.list_) {
                this.list_.destroy();
            }
            this.menuSurface_.destroy();
            this.menuSurface_.unlisten(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened_);
            this.unlisten('keydown', this.handleKeydown_);
            this.unlisten(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction_);
            _super.prototype.destroy.call(this);
        };
        Object.defineProperty(MDCMenu.prototype, "open", {
            get: function () {
                return this.menuSurface_.isOpen();
            },
            set: function (value) {
                if (value) {
                    this.menuSurface_.open();
                }
                else {
                    this.menuSurface_.close();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenu.prototype, "wrapFocus", {
            get: function () {
                return this.list_ ? this.list_.wrapFocus : false;
            },
            set: function (value) {
                if (this.list_) {
                    this.list_.wrapFocus = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenu.prototype, "items", {
            /**
             * Return the items within the menu. Note that this only contains the set of elements within
             * the items container that are proper list items, and not supplemental / presentational DOM
             * elements.
             */
            get: function () {
                return this.list_ ? this.list_.listElements : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenu.prototype, "quickOpen", {
            set: function (quickOpen) {
                this.menuSurface_.quickOpen = quickOpen;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets default focus state where the menu should focus every time when menu
         * is opened. Focuses the list root (`DefaultFocusState.LIST_ROOT`) element by
         * default.
         * @param focusState Default focus state.
         */
        MDCMenu.prototype.setDefaultFocusState = function (focusState) {
            this.foundation_.setDefaultFocusState(focusState);
        };
        /**
         * @param corner Default anchor corner alignment of top-left menu corner.
         */
        MDCMenu.prototype.setAnchorCorner = function (corner) {
            this.menuSurface_.setAnchorCorner(corner);
        };
        MDCMenu.prototype.setAnchorMargin = function (margin) {
            this.menuSurface_.setAnchorMargin(margin);
        };
        /**
         * Sets the list item as the selected row at the specified index.
         * @param index Index of list item within menu.
         */
        MDCMenu.prototype.setSelectedIndex = function (index) {
            this.foundation_.setSelectedIndex(index);
        };
        /**
         * Sets the enabled state to isEnabled for the menu item at the given index.
         * @param index Index of the menu item
         * @param isEnabled The desired enabled state of the menu item.
         */
        MDCMenu.prototype.setEnabled = function (index, isEnabled) {
            this.foundation_.setEnabled(index, isEnabled);
        };
        /**
         * @return The item within the menu at the index specified.
         */
        MDCMenu.prototype.getOptionByIndex = function (index) {
            var items = this.items;
            if (index < items.length) {
                return this.items[index];
            }
            else {
                return null;
            }
        };
        MDCMenu.prototype.setFixedPosition = function (isFixed) {
            this.menuSurface_.setFixedPosition(isFixed);
        };
        MDCMenu.prototype.hoistMenuToBody = function () {
            this.menuSurface_.hoistMenuToBody();
        };
        MDCMenu.prototype.setIsHoisted = function (isHoisted) {
            this.menuSurface_.setIsHoisted(isHoisted);
        };
        MDCMenu.prototype.setAbsolutePosition = function (x, y) {
            this.menuSurface_.setAbsolutePosition(x, y);
        };
        /**
         * Sets the element that the menu-surface is anchored to.
         */
        MDCMenu.prototype.setAnchorElement = function (element) {
            this.menuSurface_.anchorElement = element;
        };
        MDCMenu.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                addClassToElementAtIndex: function (index, className) {
                    var list = _this.items;
                    list[index].classList.add(className);
                },
                removeClassFromElementAtIndex: function (index, className) {
                    var list = _this.items;
                    list[index].classList.remove(className);
                },
                addAttributeToElementAtIndex: function (index, attr, value) {
                    var list = _this.items;
                    list[index].setAttribute(attr, value);
                },
                removeAttributeFromElementAtIndex: function (index, attr) {
                    var list = _this.items;
                    list[index].removeAttribute(attr);
                },
                elementContainsClass: function (element, className) { return element.classList.contains(className); },
                closeSurface: function (skipRestoreFocus) { return _this.menuSurface_.close(skipRestoreFocus); },
                getElementIndex: function (element) { return _this.items.indexOf(element); },
                notifySelected: function (evtData) { return _this.emit(strings$b.SELECTED_EVENT, {
                    index: evtData.index,
                    item: _this.items[evtData.index],
                }); },
                getMenuItemCount: function () { return _this.items.length; },
                focusItemAtIndex: function (index) { return _this.items[index].focus(); },
                focusListRoot: function () { return _this.root_.querySelector(strings$b.LIST_SELECTOR).focus(); },
                isSelectableItemAtIndex: function (index) { return !!closest(_this.items[index], "." + cssClasses$8.MENU_SELECTION_GROUP); },
                getSelectedSiblingOfItemAtIndex: function (index) {
                    var selectionGroupEl = closest(_this.items[index], "." + cssClasses$8.MENU_SELECTION_GROUP);
                    var selectedItemEl = selectionGroupEl.querySelector("." + cssClasses$8.MENU_SELECTED_LIST_ITEM);
                    return selectedItemEl ? _this.items.indexOf(selectedItemEl) : -1;
                },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCMenuFoundation(adapter);
        };
        return MDCMenu;
    }(MDCComponent));
    //# sourceMappingURL=component.js.map

    /* node_modules\@smui\menu\Menu.svelte generated by Svelte v3.18.1 */

    // (1:0) <MenuSurface   bind:element   use={[forwardEvents, ...use]}   class="mdc-menu {className}"   on:MDCMenu:selected={updateOpen}   on:MDCMenuSurface:closed={updateOpen} on:MDCMenuSurface:opened={updateOpen}   {...exclude($$props, ['use', 'class', 'wrapFocus'])} >
    function create_default_slot$5(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[34].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[36], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot && default_slot.p && dirty[1] & /*$$scope*/ 32) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[36], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[36], dirty, null));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(1:0) <MenuSurface   bind:element   use={[forwardEvents, ...use]}   class=\\\"mdc-menu {className}\\\"   on:MDCMenu:selected={updateOpen}   on:MDCMenuSurface:closed={updateOpen} on:MDCMenuSurface:opened={updateOpen}   {...exclude($$props, ['use', 'class', 'wrapFocus'])} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let updating_element;
    	let current;

    	const menusurface_spread_levels = [
    		{
    			use: [/*forwardEvents*/ ctx[3], .../*use*/ ctx[0]]
    		},
    		{
    			class: "mdc-menu " + /*className*/ ctx[1]
    		},
    		exclude(/*$$props*/ ctx[5], ["use", "class", "wrapFocus"])
    	];

    	function menusurface_element_binding(value) {
    		/*menusurface_element_binding*/ ctx[35].call(null, value);
    	}

    	let menusurface_props = {
    		$$slots: { default: [create_default_slot$5] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < menusurface_spread_levels.length; i += 1) {
    		menusurface_props = assign(menusurface_props, menusurface_spread_levels[i]);
    	}

    	if (/*element*/ ctx[2] !== void 0) {
    		menusurface_props.element = /*element*/ ctx[2];
    	}

    	const menusurface = new MenuSurface({ props: menusurface_props, $$inline: true });
    	binding_callbacks.push(() => bind(menusurface, "element", menusurface_element_binding));
    	menusurface.$on("MDCMenu:selected", /*updateOpen*/ ctx[4]);
    	menusurface.$on("MDCMenuSurface:closed", /*updateOpen*/ ctx[4]);
    	menusurface.$on("MDCMenuSurface:opened", /*updateOpen*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(menusurface.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(menusurface, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menusurface_changes = (dirty[0] & /*forwardEvents, use, className, $$props*/ 43)
    			? get_spread_update(menusurface_spread_levels, [
    					dirty[0] & /*forwardEvents, use*/ 9 && {
    						use: [/*forwardEvents*/ ctx[3], .../*use*/ ctx[0]]
    					},
    					dirty[0] & /*className*/ 2 && {
    						class: "mdc-menu " + /*className*/ ctx[1]
    					},
    					dirty[0] & /*$$props*/ 32 && get_spread_object(exclude(/*$$props*/ ctx[5], ["use", "class", "wrapFocus"]))
    				])
    			: {};

    			if (dirty[1] & /*$$scope*/ 32) {
    				menusurface_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty[0] & /*element*/ 4) {
    				updating_element = true;
    				menusurface_changes.element = /*element*/ ctx[2];
    				add_flush_callback(() => updating_element = false);
    			}

    			menusurface.$set(menusurface_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menusurface.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menusurface.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menusurface, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	const forwardEvents = forwardEventsBuilder(current_component, ["MDCMenu:selected", "MDCMenuSurface:closed", "MDCMenuSurface:opened"]);
    	let { use = [] } = $$props;
    	let { class: className = "" } = $$props;
    	let { static: isStatic = false } = $$props;
    	let { open = isStatic } = $$props; // Purposely omitted from the exclude call above.
    	let { quickOpen = false } = $$props; // Purposely omitted from the exclude call above.
    	let { anchorCorner = null } = $$props; // Purposely omitted from the exclude call above.
    	let { wrapFocus = false } = $$props;
    	let element;
    	let menu;
    	let instantiate = getContext("SMUI:menu:instantiate");
    	let getInstance = getContext("SMUI:menu:getInstance");
    	let menuSurfacePromiseResolve;
    	let menuSurfacePromise = new Promise(resolve => menuSurfacePromiseResolve = resolve);
    	let listPromiseResolve;
    	let listPromise = new Promise(resolve => listPromiseResolve = resolve);
    	setContext("SMUI:menu-surface:instantiate", false);
    	setContext("SMUI:menu-surface:getInstance", getMenuSurfaceInstancePromise);
    	setContext("SMUI:list:instantiate", false);
    	setContext("SMUI:list:getInstance", getListInstancePromise);

    	onMount(async () => {
    		if (instantiate !== false) {
    			$$invalidate(25, menu = new MDCMenu(element));
    		} else {
    			$$invalidate(25, menu = await getInstance());
    		}

    		menuSurfacePromiseResolve(menu.menuSurface_);
    		listPromiseResolve(menu.list_);
    	});

    	onDestroy(() => {
    		if (instantiate !== false) {
    			menu && menu.destroy();
    		}
    	});

    	function getMenuSurfaceInstancePromise() {
    		return menuSurfacePromise;
    	}

    	function getListInstancePromise() {
    		return listPromise;
    	}

    	function updateOpen() {
    		$$invalidate(6, open = menu.open);
    	}

    	function setOpen(value) {
    		$$invalidate(6, open = value);
    	}

    	function getItems() {
    		return menu.items;
    	}

    	function setDefaultFocusState(...args) {
    		return menu.setDefaultFocusState(...args);
    	}

    	function setAnchorCorner(...args) {
    		return menu.setAnchorCorner(...args);
    	}

    	function setAnchorMargin(...args) {
    		return menu.setAnchorMargin(...args);
    	}

    	function setSelectedIndex(...args) {
    		return menu.setSelectedIndex(...args);
    	}

    	function setEnabled(...args) {
    		return menu.setEnabled(...args);
    	}

    	function getOptionByIndex(...args) {
    		return menu.getOptionByIndex(...args);
    	}

    	function setFixedPosition(...args) {
    		return menu.setFixedPosition(...args);
    	}

    	function hoistMenuToBody(...args) {
    		return menu.hoistMenuToBody(...args);
    	}

    	function setIsHoisted(...args) {
    		return menu.setIsHoisted(...args);
    	}

    	function setAbsolutePosition(...args) {
    		return menu.setAbsolutePosition(...args);
    	}

    	function setAnchorElement(...args) {
    		return menu.setAnchorElement(...args);
    	}

    	function getDefaultFoundation(...args) {
    		return menu.getDefaultFoundation(...args);
    	}

    	let { $$slots = {}, $$scope } = $$props;

    	function menusurface_element_binding(value) {
    		element = value;
    		$$invalidate(2, element);
    	}

    	$$self.$set = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ("static" in $$new_props) $$invalidate(7, isStatic = $$new_props.static);
    		if ("open" in $$new_props) $$invalidate(6, open = $$new_props.open);
    		if ("quickOpen" in $$new_props) $$invalidate(8, quickOpen = $$new_props.quickOpen);
    		if ("anchorCorner" in $$new_props) $$invalidate(9, anchorCorner = $$new_props.anchorCorner);
    		if ("wrapFocus" in $$new_props) $$invalidate(10, wrapFocus = $$new_props.wrapFocus);
    		if ("$$scope" in $$new_props) $$invalidate(36, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			use,
    			className,
    			isStatic,
    			open,
    			quickOpen,
    			anchorCorner,
    			wrapFocus,
    			element,
    			menu,
    			instantiate,
    			getInstance,
    			menuSurfacePromiseResolve,
    			menuSurfacePromise,
    			listPromiseResolve,
    			listPromise
    		};
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
    		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
    		if ("isStatic" in $$props) $$invalidate(7, isStatic = $$new_props.isStatic);
    		if ("open" in $$props) $$invalidate(6, open = $$new_props.open);
    		if ("quickOpen" in $$props) $$invalidate(8, quickOpen = $$new_props.quickOpen);
    		if ("anchorCorner" in $$props) $$invalidate(9, anchorCorner = $$new_props.anchorCorner);
    		if ("wrapFocus" in $$props) $$invalidate(10, wrapFocus = $$new_props.wrapFocus);
    		if ("element" in $$props) $$invalidate(2, element = $$new_props.element);
    		if ("menu" in $$props) $$invalidate(25, menu = $$new_props.menu);
    		if ("instantiate" in $$props) instantiate = $$new_props.instantiate;
    		if ("getInstance" in $$props) getInstance = $$new_props.getInstance;
    		if ("menuSurfacePromiseResolve" in $$props) menuSurfacePromiseResolve = $$new_props.menuSurfacePromiseResolve;
    		if ("menuSurfacePromise" in $$props) menuSurfacePromise = $$new_props.menuSurfacePromise;
    		if ("listPromiseResolve" in $$props) listPromiseResolve = $$new_props.listPromiseResolve;
    		if ("listPromise" in $$props) listPromise = $$new_props.listPromise;
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*menu, open, isStatic*/ 33554624) {
    			 if (menu && menu.open !== open) {
    				if (isStatic) {
    					$$invalidate(6, open = true);
    				}

    				$$invalidate(25, menu.open = open, menu);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*menu, wrapFocus*/ 33555456) {
    			 if (menu && menu.wrapFocus !== wrapFocus) {
    				$$invalidate(25, menu.wrapFocus = wrapFocus, menu);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*menu, quickOpen*/ 33554688) {
    			 if (menu) {
    				$$invalidate(25, menu.quickOpen = quickOpen, menu);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*menu, anchorCorner*/ 33554944) {
    			 if (menu && anchorCorner != null) {
    				if (Corner.hasOwnProperty(anchorCorner)) {
    					menu.setAnchorCorner(Corner[anchorCorner]);
    				} else if (CornerBit.hasOwnProperty(anchorCorner)) {
    					menu.setAnchorCorner(Corner[anchorCorner]);
    				} else {
    					menu.setAnchorCorner(anchorCorner);
    				}
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		element,
    		forwardEvents,
    		updateOpen,
    		$$props,
    		open,
    		isStatic,
    		quickOpen,
    		anchorCorner,
    		wrapFocus,
    		setOpen,
    		getItems,
    		setDefaultFocusState,
    		setAnchorCorner,
    		setAnchorMargin,
    		setSelectedIndex,
    		setEnabled,
    		getOptionByIndex,
    		setFixedPosition,
    		hoistMenuToBody,
    		setIsHoisted,
    		setAbsolutePosition,
    		setAnchorElement,
    		getDefaultFoundation,
    		menu,
    		menuSurfacePromiseResolve,
    		listPromiseResolve,
    		instantiate,
    		getInstance,
    		menuSurfacePromise,
    		listPromise,
    		getMenuSurfaceInstancePromise,
    		getListInstancePromise,
    		$$slots,
    		menusurface_element_binding,
    		$$scope
    	];
    }

    class Menu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$o,
    			create_fragment$o,
    			safe_not_equal,
    			{
    				use: 0,
    				class: 1,
    				static: 7,
    				open: 6,
    				quickOpen: 8,
    				anchorCorner: 9,
    				wrapFocus: 10,
    				setOpen: 11,
    				getItems: 12,
    				setDefaultFocusState: 13,
    				setAnchorCorner: 14,
    				setAnchorMargin: 15,
    				setSelectedIndex: 16,
    				setEnabled: 17,
    				getOptionByIndex: 18,
    				setFixedPosition: 19,
    				hoistMenuToBody: 20,
    				setIsHoisted: 21,
    				setAbsolutePosition: 22,
    				setAnchorElement: 23,
    				getDefaultFoundation: 24
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Menu",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get use() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get static() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set static(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get open() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get quickOpen() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set quickOpen(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchorCorner() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchorCorner(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrapFocus() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrapFocus(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setOpen() {
    		return this.$$.ctx[11];
    	}

    	set setOpen(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getItems() {
    		return this.$$.ctx[12];
    	}

    	set getItems(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setDefaultFocusState() {
    		return this.$$.ctx[13];
    	}

    	set setDefaultFocusState(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setAnchorCorner() {
    		return this.$$.ctx[14];
    	}

    	set setAnchorCorner(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setAnchorMargin() {
    		return this.$$.ctx[15];
    	}

    	set setAnchorMargin(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setSelectedIndex() {
    		return this.$$.ctx[16];
    	}

    	set setSelectedIndex(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setEnabled() {
    		return this.$$.ctx[17];
    	}

    	set setEnabled(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getOptionByIndex() {
    		return this.$$.ctx[18];
    	}

    	set getOptionByIndex(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setFixedPosition() {
    		return this.$$.ctx[19];
    	}

    	set setFixedPosition(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hoistMenuToBody() {
    		return this.$$.ctx[20];
    	}

    	set hoistMenuToBody(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setIsHoisted() {
    		return this.$$.ctx[21];
    	}

    	set setIsHoisted(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setAbsolutePosition() {
    		return this.$$.ctx[22];
    	}

    	set setAbsolutePosition(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setAnchorElement() {
    		return this.$$.ctx[23];
    	}

    	set setAnchorElement(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getDefaultFoundation() {
    		return this.$$.ctx[24];
    	}

    	set getDefaultFoundation(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    classAdderBuilder({
      class: 'mdc-menu__selection-group-icon',
      component: Graphic,
      contexts: {}
    });

    /* src\components\emoji.svelte generated by Svelte v3.18.1 */

    const { console: console_1 } = globals;
    const file$m = "src\\components\\emoji.svelte";

    // (160:0) <Button on:click={() => {menu2.setOpen(true); dispatch("windowrz",{detail:"sdsf"}); console.log('sdfs');}}>
    function create_default_slot_5$1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "/icons8-batman-emoji-30.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Emoji");
    			add_location(img, file$m, 160, 2, 3724);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(160:0) <Button on:click={() => {menu2.setOpen(true); dispatch(\\\"windowrz\\\",{detail:\\\"sdsf\\\"}); console.log('sdfs');}}>",
    		ctx
    	});

    	return block;
    }

    // (180:3) <Icon class="material-icons">
    function create_default_slot_4$1(ctx) {
    	let t_value = /*tab*/ ctx[11].icon + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*tab*/ 2048 && t_value !== (t_value = /*tab*/ ctx[11].icon + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(180:3) <Icon class=\\\"material-icons\\\">",
    		ctx
    	});

    	return block;
    }

    // (175:1) <Tab     {tab}     stacked={false}     indicatorSpanOnlyContent={false}     tabIndicator$transition="slide">
    function create_default_slot_3$1(ctx) {
    	let current;

    	const icon = new Icon({
    			props: {
    				class: "material-icons",
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};

    			if (dirty & /*$$scope, tab*/ 6144) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(175:1) <Tab     {tab}     stacked={false}     indicatorSpanOnlyContent={false}     tabIndicator$transition=\\\"slide\\\">",
    		ctx
    	});

    	return block;
    }

    // (170:2) <TabBar   tabs={keyedTabs}   let:tab   key={tab => tab.k}   bind:active={keyedTabsActive}>
    function create_default_slot_2$1(ctx) {
    	let current;

    	const tab = new Tab({
    			props: {
    				tab: /*tab*/ ctx[11],
    				stacked: false,
    				indicatorSpanOnlyContent: false,
    				tabIndicator$transition: "slide",
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tab.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tab, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tab_changes = {};
    			if (dirty & /*tab*/ 2048) tab_changes.tab = /*tab*/ ctx[11];

    			if (dirty & /*$$scope, tab*/ 6144) {
    				tab_changes.$$scope = { dirty, ctx };
    			}

    			tab.$set(tab_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tab, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(170:2) <TabBar   tabs={keyedTabs}   let:tab   key={tab => tab.k}   bind:active={keyedTabsActive}>",
    		ctx
    	});

    	return block;
    }

    // (186:3) <List>
    function create_default_slot_1$2(ctx) {
    	let div;
    	let current;

    	const emojitab = new Emojitab({
    			props: { emoji: /*Filterlist*/ ctx[3] },
    			$$inline: true
    		});

    	emojitab.$on("emojiClicked", /*emojiClicked_handler*/ ctx[8]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(emojitab.$$.fragment);
    			attr_dev(div, "class", "divasd");
    			add_location(div, file$m, 185, 10, 4263);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(emojitab, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const emojitab_changes = {};
    			if (dirty & /*Filterlist*/ 8) emojitab_changes.emoji = /*Filterlist*/ ctx[3];
    			emojitab.$set(emojitab_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(emojitab.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(emojitab.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(emojitab);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(186:3) <List>",
    		ctx
    	});

    	return block;
    }

    // (163:0) <Menu    bind:this={menu2}    anchor={true}    bind:anchorElement={anchor}    anchorCorner="BOTTOM_END">
    function create_default_slot$6(ctx) {
    	let updating_active;
    	let t;
    	let current;

    	function tabbar_active_binding(value) {
    		/*tabbar_active_binding*/ ctx[7].call(null, value);
    	}

    	let tabbar_props = {
    		tabs: /*keyedTabs*/ ctx[5],
    		key: func,
    		$$slots: {
    			default: [
    				create_default_slot_2$1,
    				({ tab }) => ({ 11: tab }),
    				({ tab }) => tab ? 2048 : 0
    			]
    		},
    		$$scope: { ctx }
    	};

    	if (/*keyedTabsActive*/ ctx[2] !== void 0) {
    		tabbar_props.active = /*keyedTabsActive*/ ctx[2];
    	}

    	const tabbar = new TabBar({ props: tabbar_props, $$inline: true });
    	binding_callbacks.push(() => bind(tabbar, "active", tabbar_active_binding));

    	const list = new List({
    			props: {
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tabbar.$$.fragment);
    			t = space();
    			create_component(list.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tabbar, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(list, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tabbar_changes = {};

    			if (dirty & /*$$scope, tab*/ 6144) {
    				tabbar_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty & /*keyedTabsActive*/ 4) {
    				updating_active = true;
    				tabbar_changes.active = /*keyedTabsActive*/ ctx[2];
    				add_flush_callback(() => updating_active = false);
    			}

    			tabbar.$set(tabbar_changes);
    			const list_changes = {};

    			if (dirty & /*$$scope, Filterlist*/ 4104) {
    				list_changes.$$scope = { dirty, ctx };
    			}

    			list.$set(list_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabbar.$$.fragment, local);
    			transition_in(list.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabbar.$$.fragment, local);
    			transition_out(list.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tabbar, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(list, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(163:0) <Menu    bind:this={menu2}    anchor={true}    bind:anchorElement={anchor}    anchorCorner=\\\"BOTTOM_END\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let t;
    	let updating_anchorElement;
    	let current;

    	const button = new Button_1({
    			props: {
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[6]);

    	function menu_anchorElement_binding(value) {
    		/*menu_anchorElement_binding*/ ctx[10].call(null, value);
    	}

    	let menu_props = {
    		anchor: true,
    		anchorCorner: "BOTTOM_END",
    		$$slots: { default: [create_default_slot$6] },
    		$$scope: { ctx }
    	};

    	if (/*anchor*/ ctx[0] !== void 0) {
    		menu_props.anchorElement = /*anchor*/ ctx[0];
    	}

    	const menu = new Menu({ props: menu_props, $$inline: true });
    	/*menu_binding*/ ctx[9](menu);
    	binding_callbacks.push(() => bind(menu, "anchorElement", menu_anchorElement_binding));

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    			t = space();
    			create_component(menu.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			const menu_changes = {};

    			if (dirty & /*$$scope, Filterlist, keyedTabsActive*/ 4108) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_anchorElement && dirty & /*anchor*/ 1) {
    				updating_anchorElement = true;
    				menu_changes.anchorElement = /*anchor*/ ctx[0];
    				add_flush_callback(() => updating_anchorElement = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t);
    			/*menu_binding*/ ctx[9](null);
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func = tab => tab.k;

    function instance$p($$self, $$props, $$invalidate) {
    	let dispatch = createEventDispatcher();
    	let { anchor } = $$props;
    	let menu2;

    	let keyedTabs = [
    		{
    			k: "Smileys & Emotion",
    			icon: "c1",
    			label: "Code"
    		},
    		{
    			k: "People & Body",
    			icon: "c2",
    			label: "Code"
    		},
    		{
    			k: "Animals & Nature",
    			icon: "c3",
    			label: "Code"
    		},
    		{
    			k: "Travel & Places",
    			icon: "c4",
    			label: "Code"
    		},
    		{ k: "delete", icon: "Delete" }
    	];

    	let keyedTabsActive = keyedTabs[0];
    	const writable_props = ["anchor"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Emoji> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		menu2.setOpen(true);
    		dispatch("windowrz", { detail: "sdsf" });
    		console.log("sdfs");
    	};

    	function tabbar_active_binding(value) {
    		keyedTabsActive = value;
    		$$invalidate(2, keyedTabsActive);
    	}

    	function emojiClicked_handler(event) {
    		bubble($$self, event);
    	}

    	function menu_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(1, menu2 = $$value);
    		});
    	}

    	function menu_anchorElement_binding(value) {
    		anchor = value;
    		$$invalidate(0, anchor);
    	}

    	$$self.$set = $$props => {
    		if ("anchor" in $$props) $$invalidate(0, anchor = $$props.anchor);
    	};

    	$$self.$capture_state = () => {
    		return {
    			dispatch,
    			anchor,
    			menu2,
    			keyedTabs,
    			keyedTabsActive,
    			Filterlist
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("dispatch" in $$props) $$invalidate(4, dispatch = $$props.dispatch);
    		if ("anchor" in $$props) $$invalidate(0, anchor = $$props.anchor);
    		if ("menu2" in $$props) $$invalidate(1, menu2 = $$props.menu2);
    		if ("keyedTabs" in $$props) $$invalidate(5, keyedTabs = $$props.keyedTabs);
    		if ("keyedTabsActive" in $$props) $$invalidate(2, keyedTabsActive = $$props.keyedTabsActive);
    		if ("Filterlist" in $$props) $$invalidate(3, Filterlist = $$props.Filterlist);
    	};

    	let Filterlist;

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*keyedTabsActive*/ 4) {
    			 $$invalidate(3, Filterlist = temoji.filter(t => t.group === keyedTabsActive.k));
    		}
    	};

    	return [
    		anchor,
    		menu2,
    		keyedTabsActive,
    		Filterlist,
    		dispatch,
    		keyedTabs,
    		click_handler,
    		tabbar_active_binding,
    		emojiClicked_handler,
    		menu_binding,
    		menu_anchorElement_binding
    	];
    }

    class Emoji extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, { anchor: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Emoji",
    			options,
    			id: create_fragment$p.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*anchor*/ ctx[0] === undefined && !("anchor" in props)) {
    			console_1.warn("<Emoji> was created without expected prop 'anchor'");
    		}
    	}

    	get anchor() {
    		throw new Error("<Emoji>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchor(value) {
    		throw new Error("<Emoji>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * Parses an URI
     *
     * @author Steven Levithan <stevenlevithan.com> (MIT license)
     * @api private
     */

    var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

    var parts = [
        'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
    ];

    var parseuri = function parseuri(str) {
        var src = str,
            b = str.indexOf('['),
            e = str.indexOf(']');

        if (b != -1 && e != -1) {
            str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
        }

        var m = re.exec(str || ''),
            uri = {},
            i = 14;

        while (i--) {
            uri[parts[i]] = m[i] || '';
        }

        if (b != -1 && e != -1) {
            uri.source = src;
            uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
            uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
            uri.ipv6uri = true;
        }

        return uri;
    };

    /**
     * Helpers.
     */

    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} [options]
     * @throws {Error} throw an error if val is not a non-empty string or a number
     * @return {String|Number}
     * @api public
     */

    var ms = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse(val);
      } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        'val is not a non-empty string or a valid number. val=' +
          JSON.stringify(val)
      );
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'weeks':
        case 'week':
        case 'w':
          return n * w;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
      }
      return ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    }

    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     */

    function setup(env) {
    	createDebug.debug = createDebug;
    	createDebug.default = createDebug;
    	createDebug.coerce = coerce;
    	createDebug.disable = disable;
    	createDebug.enable = enable;
    	createDebug.enabled = enabled;
    	createDebug.humanize = ms;

    	Object.keys(env).forEach(key => {
    		createDebug[key] = env[key];
    	});

    	/**
    	* Active `debug` instances.
    	*/
    	createDebug.instances = [];

    	/**
    	* The currently active debug mode names, and names to skip.
    	*/

    	createDebug.names = [];
    	createDebug.skips = [];

    	/**
    	* Map of special "%n" handling functions, for the debug "format" argument.
    	*
    	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    	*/
    	createDebug.formatters = {};

    	/**
    	* Selects a color for a debug namespace
    	* @param {String} namespace The namespace string for the for the debug instance to be colored
    	* @return {Number|String} An ANSI color code for the given namespace
    	* @api private
    	*/
    	function selectColor(namespace) {
    		let hash = 0;

    		for (let i = 0; i < namespace.length; i++) {
    			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
    			hash |= 0; // Convert to 32bit integer
    		}

    		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    	}
    	createDebug.selectColor = selectColor;

    	/**
    	* Create a debugger with the given `namespace`.
    	*
    	* @param {String} namespace
    	* @return {Function}
    	* @api public
    	*/
    	function createDebug(namespace) {
    		let prevTime;

    		function debug(...args) {
    			// Disabled?
    			if (!debug.enabled) {
    				return;
    			}

    			const self = debug;

    			// Set `diff` timestamp
    			const curr = Number(new Date());
    			const ms = curr - (prevTime || curr);
    			self.diff = ms;
    			self.prev = prevTime;
    			self.curr = curr;
    			prevTime = curr;

    			args[0] = createDebug.coerce(args[0]);

    			if (typeof args[0] !== 'string') {
    				// Anything else let's inspect with %O
    				args.unshift('%O');
    			}

    			// Apply any `formatters` transformations
    			let index = 0;
    			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
    				// If we encounter an escaped % then don't increase the array index
    				if (match === '%%') {
    					return match;
    				}
    				index++;
    				const formatter = createDebug.formatters[format];
    				if (typeof formatter === 'function') {
    					const val = args[index];
    					match = formatter.call(self, val);

    					// Now we need to remove `args[index]` since it's inlined in the `format`
    					args.splice(index, 1);
    					index--;
    				}
    				return match;
    			});

    			// Apply env-specific formatting (colors, etc.)
    			createDebug.formatArgs.call(self, args);

    			const logFn = self.log || createDebug.log;
    			logFn.apply(self, args);
    		}

    		debug.namespace = namespace;
    		debug.enabled = createDebug.enabled(namespace);
    		debug.useColors = createDebug.useColors();
    		debug.color = selectColor(namespace);
    		debug.destroy = destroy;
    		debug.extend = extend;
    		// Debug.formatArgs = formatArgs;
    		// debug.rawLog = rawLog;

    		// env-specific initialization logic for debug instances
    		if (typeof createDebug.init === 'function') {
    			createDebug.init(debug);
    		}

    		createDebug.instances.push(debug);

    		return debug;
    	}

    	function destroy() {
    		const index = createDebug.instances.indexOf(this);
    		if (index !== -1) {
    			createDebug.instances.splice(index, 1);
    			return true;
    		}
    		return false;
    	}

    	function extend(namespace, delimiter) {
    		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    		newDebug.log = this.log;
    		return newDebug;
    	}

    	/**
    	* Enables a debug mode by namespaces. This can include modes
    	* separated by a colon and wildcards.
    	*
    	* @param {String} namespaces
    	* @api public
    	*/
    	function enable(namespaces) {
    		createDebug.save(namespaces);

    		createDebug.names = [];
    		createDebug.skips = [];

    		let i;
    		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    		const len = split.length;

    		for (i = 0; i < len; i++) {
    			if (!split[i]) {
    				// ignore empty strings
    				continue;
    			}

    			namespaces = split[i].replace(/\*/g, '.*?');

    			if (namespaces[0] === '-') {
    				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    			} else {
    				createDebug.names.push(new RegExp('^' + namespaces + '$'));
    			}
    		}

    		for (i = 0; i < createDebug.instances.length; i++) {
    			const instance = createDebug.instances[i];
    			instance.enabled = createDebug.enabled(instance.namespace);
    		}
    	}

    	/**
    	* Disable debug output.
    	*
    	* @return {String} namespaces
    	* @api public
    	*/
    	function disable() {
    		const namespaces = [
    			...createDebug.names.map(toNamespace),
    			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
    		].join(',');
    		createDebug.enable('');
    		return namespaces;
    	}

    	/**
    	* Returns true if the given mode name is enabled, false otherwise.
    	*
    	* @param {String} name
    	* @return {Boolean}
    	* @api public
    	*/
    	function enabled(name) {
    		if (name[name.length - 1] === '*') {
    			return true;
    		}

    		let i;
    		let len;

    		for (i = 0, len = createDebug.skips.length; i < len; i++) {
    			if (createDebug.skips[i].test(name)) {
    				return false;
    			}
    		}

    		for (i = 0, len = createDebug.names.length; i < len; i++) {
    			if (createDebug.names[i].test(name)) {
    				return true;
    			}
    		}

    		return false;
    	}

    	/**
    	* Convert regexp to namespace
    	*
    	* @param {RegExp} regxep
    	* @return {String} namespace
    	* @api private
    	*/
    	function toNamespace(regexp) {
    		return regexp.toString()
    			.substring(2, regexp.toString().length - 2)
    			.replace(/\.\*\?$/, '*');
    	}

    	/**
    	* Coerce `val`.
    	*
    	* @param {Mixed} val
    	* @return {Mixed}
    	* @api private
    	*/
    	function coerce(val) {
    		if (val instanceof Error) {
    			return val.stack || val.message;
    		}
    		return val;
    	}

    	createDebug.enable(createDebug.load());

    	return createDebug;
    }

    var common = setup;

    var browser = createCommonjsModule(function (module, exports) {
    /* eslint-env browser */

    /**
     * This is the web browser implementation of `debug()`.
     */

    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();

    /**
     * Colors.
     */

    exports.colors = [
    	'#0000CC',
    	'#0000FF',
    	'#0033CC',
    	'#0033FF',
    	'#0066CC',
    	'#0066FF',
    	'#0099CC',
    	'#0099FF',
    	'#00CC00',
    	'#00CC33',
    	'#00CC66',
    	'#00CC99',
    	'#00CCCC',
    	'#00CCFF',
    	'#3300CC',
    	'#3300FF',
    	'#3333CC',
    	'#3333FF',
    	'#3366CC',
    	'#3366FF',
    	'#3399CC',
    	'#3399FF',
    	'#33CC00',
    	'#33CC33',
    	'#33CC66',
    	'#33CC99',
    	'#33CCCC',
    	'#33CCFF',
    	'#6600CC',
    	'#6600FF',
    	'#6633CC',
    	'#6633FF',
    	'#66CC00',
    	'#66CC33',
    	'#9900CC',
    	'#9900FF',
    	'#9933CC',
    	'#9933FF',
    	'#99CC00',
    	'#99CC33',
    	'#CC0000',
    	'#CC0033',
    	'#CC0066',
    	'#CC0099',
    	'#CC00CC',
    	'#CC00FF',
    	'#CC3300',
    	'#CC3333',
    	'#CC3366',
    	'#CC3399',
    	'#CC33CC',
    	'#CC33FF',
    	'#CC6600',
    	'#CC6633',
    	'#CC9900',
    	'#CC9933',
    	'#CCCC00',
    	'#CCCC33',
    	'#FF0000',
    	'#FF0033',
    	'#FF0066',
    	'#FF0099',
    	'#FF00CC',
    	'#FF00FF',
    	'#FF3300',
    	'#FF3333',
    	'#FF3366',
    	'#FF3399',
    	'#FF33CC',
    	'#FF33FF',
    	'#FF6600',
    	'#FF6633',
    	'#FF9900',
    	'#FF9933',
    	'#FFCC00',
    	'#FFCC33'
    ];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    // eslint-disable-next-line complexity
    function useColors() {
    	// NB: In an Electron preload script, document will be defined but not fully
    	// initialized. Since we know we're in Chrome, we'll just detect this case
    	// explicitly
    	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    		return true;
    	}

    	// Internet Explorer and Edge do not support colors.
    	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    		return false;
    	}

    	// Is webkit? http://stackoverflow.com/a/16459606/376773
    	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    		// Is firebug? http://stackoverflow.com/a/398120/376773
    		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    		// Is firefox >= v31?
    		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    		// Double check webkit in userAgent just in case we are in a worker
    		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
    }

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
    	args[0] = (this.useColors ? '%c' : '') +
    		this.namespace +
    		(this.useColors ? ' %c' : ' ') +
    		args[0] +
    		(this.useColors ? '%c ' : ' ') +
    		'+' + module.exports.humanize(this.diff);

    	if (!this.useColors) {
    		return;
    	}

    	const c = 'color: ' + this.color;
    	args.splice(1, 0, c, 'color: inherit');

    	// The final "%c" is somewhat tricky, because there could be other
    	// arguments passed either before or after the %c, so we need to
    	// figure out the correct index to insert the CSS into
    	let index = 0;
    	let lastC = 0;
    	args[0].replace(/%[a-zA-Z%]/g, match => {
    		if (match === '%%') {
    			return;
    		}
    		index++;
    		if (match === '%c') {
    			// We only are interested in the *last* %c
    			// (the user may have provided their own)
    			lastC = index;
    		}
    	});

    	args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */
    function log(...args) {
    	// This hackery is required for IE8/9, where
    	// the `console.log` function doesn't have 'apply'
    	return typeof console === 'object' &&
    		console.log &&
    		console.log(...args);
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
    	try {
    		if (namespaces) {
    			exports.storage.setItem('debug', namespaces);
    		} else {
    			exports.storage.removeItem('debug');
    		}
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    function load() {
    	let r;
    	try {
    		r = exports.storage.getItem('debug');
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}

    	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    	if (!r && typeof process !== 'undefined' && 'env' in process) {
    		r = process.env.DEBUG;
    	}

    	return r;
    }

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
    	try {
    		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    		// The Browser also has localStorage in the global context.
    		return localStorage;
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}
    }

    module.exports = common(exports);

    const {formatters} = module.exports;

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
    	try {
    		return JSON.stringify(v);
    	} catch (error) {
    		return '[UnexpectedJSONParseError]: ' + error.message;
    	}
    };
    });
    var browser_1 = browser.log;
    var browser_2 = browser.formatArgs;
    var browser_3 = browser.save;
    var browser_4 = browser.load;
    var browser_5 = browser.useColors;
    var browser_6 = browser.storage;
    var browser_7 = browser.colors;

    /**
     * Module dependencies.
     */


    var debug = browser('socket.io-client:url');

    /**
     * Module exports.
     */

    var url_1 = url;

    /**
     * URL parser.
     *
     * @param {String} url
     * @param {Object} An object meant to mimic window.location.
     *                 Defaults to window.location.
     * @api public
     */

    function url (uri, loc) {
      var obj = uri;

      // default to window.location
      loc = loc || (typeof location !== 'undefined' && location);
      if (null == uri) uri = loc.protocol + '//' + loc.host;

      // relative path support
      if ('string' === typeof uri) {
        if ('/' === uri.charAt(0)) {
          if ('/' === uri.charAt(1)) {
            uri = loc.protocol + uri;
          } else {
            uri = loc.host + uri;
          }
        }

        if (!/^(https?|wss?):\/\//.test(uri)) {
          debug('protocol-less url %s', uri);
          if ('undefined' !== typeof loc) {
            uri = loc.protocol + '//' + uri;
          } else {
            uri = 'https://' + uri;
          }
        }

        // parse
        debug('parse %s', uri);
        obj = parseuri(uri);
      }

      // make sure we treat `localhost:80` and `localhost` equally
      if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
          obj.port = '80';
        } else if (/^(http|ws)s$/.test(obj.protocol)) {
          obj.port = '443';
        }
      }

      obj.path = obj.path || '/';

      var ipv6 = obj.host.indexOf(':') !== -1;
      var host = ipv6 ? '[' + obj.host + ']' : obj.host;

      // define unique id
      obj.id = obj.protocol + '://' + host + ':' + obj.port;
      // define href
      obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

      return obj;
    }

    /**
     * Helpers.
     */

    var s$1 = 1000;
    var m$1 = s$1 * 60;
    var h$1 = m$1 * 60;
    var d$1 = h$1 * 24;
    var y$1 = d$1 * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} [options]
     * @throws {Error} throw an error if val is not a non-empty string or a number
     * @return {String|Number}
     * @api public
     */

    var ms$1 = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse$1(val);
      } else if (type === 'number' && isNaN(val) === false) {
        return options.long ? fmtLong$1(val) : fmtShort$1(val);
      }
      throw new Error(
        'val is not a non-empty string or a valid number. val=' +
          JSON.stringify(val)
      );
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse$1(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y$1;
        case 'days':
        case 'day':
        case 'd':
          return n * d$1;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h$1;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m$1;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s$1;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtShort$1(ms) {
      if (ms >= d$1) {
        return Math.round(ms / d$1) + 'd';
      }
      if (ms >= h$1) {
        return Math.round(ms / h$1) + 'h';
      }
      if (ms >= m$1) {
        return Math.round(ms / m$1) + 'm';
      }
      if (ms >= s$1) {
        return Math.round(ms / s$1) + 's';
      }
      return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtLong$1(ms) {
      return plural$1(ms, d$1, 'day') ||
        plural$1(ms, h$1, 'hour') ||
        plural$1(ms, m$1, 'minute') ||
        plural$1(ms, s$1, 'second') ||
        ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural$1(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + ' ' + name;
      }
      return Math.ceil(ms / n) + ' ' + name + 's';
    }

    var debug$1 = createCommonjsModule(function (module, exports) {
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = ms$1;

    /**
     * Active `debug` instances.
     */
    exports.instances = [];

    /**
     * The currently active debug mode names, and names to skip.
     */

    exports.names = [];
    exports.skips = [];

    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
     */

    exports.formatters = {};

    /**
     * Select a color.
     * @param {String} namespace
     * @return {Number}
     * @api private
     */

    function selectColor(namespace) {
      var hash = 0, i;

      for (i in namespace) {
        hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      return exports.colors[Math.abs(hash) % exports.colors.length];
    }

    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */

    function createDebug(namespace) {

      var prevTime;

      function debug() {
        // disabled?
        if (!debug.enabled) return;

        var self = debug;

        // set `diff` timestamp
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;

        // turn the `arguments` into a proper Array
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }

        args[0] = exports.coerce(args[0]);

        if ('string' !== typeof args[0]) {
          // anything else let's inspect with %O
          args.unshift('%O');
        }

        // apply any `formatters` transformations
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          // if we encounter an escaped % then don't increase the array index
          if (match === '%%') return match;
          index++;
          var formatter = exports.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);

            // now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index, 1);
            index--;
          }
          return match;
        });

        // apply env-specific formatting (colors, etc.)
        exports.formatArgs.call(self, args);

        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;

      // env-specific initialization logic for debug instances
      if ('function' === typeof exports.init) {
        exports.init(debug);
      }

      exports.instances.push(debug);

      return debug;
    }

    function destroy () {
      var index = exports.instances.indexOf(this);
      if (index !== -1) {
        exports.instances.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }

    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */

    function enable(namespaces) {
      exports.save(namespaces);

      exports.names = [];
      exports.skips = [];

      var i;
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;

      for (i = 0; i < len; i++) {
        if (!split[i]) continue; // ignore empty strings
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }

      for (i = 0; i < exports.instances.length; i++) {
        var instance = exports.instances[i];
        instance.enabled = exports.enabled(instance.namespace);
      }
    }

    /**
     * Disable debug output.
     *
     * @api public
     */

    function disable() {
      exports.enable('');
    }

    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */

    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */

    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
    });
    var debug_1 = debug$1.coerce;
    var debug_2 = debug$1.disable;
    var debug_3 = debug$1.enable;
    var debug_4 = debug$1.enabled;
    var debug_5 = debug$1.humanize;
    var debug_6 = debug$1.instances;
    var debug_7 = debug$1.names;
    var debug_8 = debug$1.skips;
    var debug_9 = debug$1.formatters;

    var browser$1 = createCommonjsModule(function (module, exports) {
    /**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = debug$1;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome
                   && 'undefined' != typeof chrome.storage
                      ? chrome.storage.local
                      : localstorage();

    /**
     * Colors.
     */

    exports.colors = [
      '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
      '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
      '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
      '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
      '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
      '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
      '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
      '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
      '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
      '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
      '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
    ];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
        return true;
      }

      // Internet Explorer and Edge do not support colors.
      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }

      // is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
      return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
        // is firebug? http://stackoverflow.com/a/398120/376773
        (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
        // is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
        // double check webkit in userAgent just in case we are in a worker
        (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
    }

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return '[UnexpectedJSONParseError]: ' + err.message;
      }
    };


    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      var useColors = this.useColors;

      args[0] = (useColors ? '%c' : '')
        + this.namespace
        + (useColors ? ' %c' : ' ')
        + args[0]
        + (useColors ? '%c ' : ' ')
        + '+' + exports.humanize(this.diff);

      if (!useColors) return;

      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');

      // the final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ('%%' === match) return;
        index++;
        if ('%c' === match) {
          // we only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });

      args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */

    function log() {
      // this hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return 'object' === typeof console
        && console.log
        && Function.prototype.apply.call(console.log, console, arguments);
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem('debug');
        } else {
          exports.storage.debug = namespaces;
        }
      } catch(e) {}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch(e) {}

      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }

      return r;
    }

    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */

    exports.enable(load());

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {}
    }
    });
    var browser_1$1 = browser$1.log;
    var browser_2$1 = browser$1.formatArgs;
    var browser_3$1 = browser$1.save;
    var browser_4$1 = browser$1.load;
    var browser_5$1 = browser$1.useColors;
    var browser_6$1 = browser$1.storage;
    var browser_7$1 = browser$1.colors;

    var componentEmitter = createCommonjsModule(function (module) {
    /**
     * Expose `Emitter`.
     */

    {
      module.exports = Emitter;
    }

    /**
     * Initialize a new `Emitter`.
     *
     * @api public
     */

    function Emitter(obj) {
      if (obj) return mixin(obj);
    }
    /**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }

    /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.on =
    Emitter.prototype.addEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};
      (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
        .push(fn);
      return this;
    };

    /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.once = function(event, fn){
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }

      on.fn = fn;
      this.on(event, on);
      return this;
    };

    /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.off =
    Emitter.prototype.removeListener =
    Emitter.prototype.removeAllListeners =
    Emitter.prototype.removeEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};

      // all
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }

      // specific event
      var callbacks = this._callbacks['$' + event];
      if (!callbacks) return this;

      // remove all handlers
      if (1 == arguments.length) {
        delete this._callbacks['$' + event];
        return this;
      }

      // remove specific handler
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      return this;
    };

    /**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */

    Emitter.prototype.emit = function(event){
      this._callbacks = this._callbacks || {};
      var args = [].slice.call(arguments, 1)
        , callbacks = this._callbacks['$' + event];

      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }

      return this;
    };

    /**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */

    Emitter.prototype.listeners = function(event){
      this._callbacks = this._callbacks || {};
      return this._callbacks['$' + event] || [];
    };

    /**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */

    Emitter.prototype.hasListeners = function(event){
      return !! this.listeners(event).length;
    };
    });

    var toString = {}.toString;

    var isarray = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };

    var isBuffer = isBuf;

    var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
    var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

    var isView = function (obj) {
      return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
    };

    /**
     * Returns true if obj is a buffer or an arraybuffer.
     *
     * @api private
     */

    function isBuf(obj) {
      return (withNativeBuffer && Buffer.isBuffer(obj)) ||
              (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
    }

    /*global Blob,File*/

    /**
     * Module requirements
     */



    var toString$1 = Object.prototype.toString;
    var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString$1.call(Blob) === '[object BlobConstructor]');
    var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString$1.call(File) === '[object FileConstructor]');

    /**
     * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
     * Anything with blobs or files should be fed through removeBlobs before coming
     * here.
     *
     * @param {Object} packet - socket.io event packet
     * @return {Object} with deconstructed packet and list of buffers
     * @api public
     */

    var deconstructPacket = function(packet) {
      var buffers = [];
      var packetData = packet.data;
      var pack = packet;
      pack.data = _deconstructPacket(packetData, buffers);
      pack.attachments = buffers.length; // number of binary 'attachments'
      return {packet: pack, buffers: buffers};
    };

    function _deconstructPacket(data, buffers) {
      if (!data) return data;

      if (isBuffer(data)) {
        var placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
      } else if (isarray(data)) {
        var newData = new Array(data.length);
        for (var i = 0; i < data.length; i++) {
          newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
      } else if (typeof data === 'object' && !(data instanceof Date)) {
        var newData = {};
        for (var key in data) {
          newData[key] = _deconstructPacket(data[key], buffers);
        }
        return newData;
      }
      return data;
    }

    /**
     * Reconstructs a binary packet from its placeholder packet and buffers
     *
     * @param {Object} packet - event packet with placeholders
     * @param {Array} buffers - binary buffers to put in placeholder positions
     * @return {Object} reconstructed packet
     * @api public
     */

    var reconstructPacket = function(packet, buffers) {
      packet.data = _reconstructPacket(packet.data, buffers);
      packet.attachments = undefined; // no longer useful
      return packet;
    };

    function _reconstructPacket(data, buffers) {
      if (!data) return data;

      if (data && data._placeholder) {
        return buffers[data.num]; // appropriate buffer (should be natural order anyway)
      } else if (isarray(data)) {
        for (var i = 0; i < data.length; i++) {
          data[i] = _reconstructPacket(data[i], buffers);
        }
      } else if (typeof data === 'object') {
        for (var key in data) {
          data[key] = _reconstructPacket(data[key], buffers);
        }
      }

      return data;
    }

    /**
     * Asynchronously removes Blobs or Files from data via
     * FileReader's readAsArrayBuffer method. Used before encoding
     * data as msgpack. Calls callback with the blobless data.
     *
     * @param {Object} data
     * @param {Function} callback
     * @api private
     */

    var removeBlobs = function(data, callback) {
      function _removeBlobs(obj, curKey, containingObject) {
        if (!obj) return obj;

        // convert any blob
        if ((withNativeBlob && obj instanceof Blob) ||
            (withNativeFile && obj instanceof File)) {
          pendingBlobs++;

          // async filereader
          var fileReader = new FileReader();
          fileReader.onload = function() { // this.result == arraybuffer
            if (containingObject) {
              containingObject[curKey] = this.result;
            }
            else {
              bloblessData = this.result;
            }

            // if nothing pending its callback time
            if(! --pendingBlobs) {
              callback(bloblessData);
            }
          };

          fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
        } else if (isarray(obj)) { // handle array
          for (var i = 0; i < obj.length; i++) {
            _removeBlobs(obj[i], i, obj);
          }
        } else if (typeof obj === 'object' && !isBuffer(obj)) { // and object
          for (var key in obj) {
            _removeBlobs(obj[key], key, obj);
          }
        }
      }

      var pendingBlobs = 0;
      var bloblessData = data;
      _removeBlobs(bloblessData);
      if (!pendingBlobs) {
        callback(bloblessData);
      }
    };

    var binary = {
    	deconstructPacket: deconstructPacket,
    	reconstructPacket: reconstructPacket,
    	removeBlobs: removeBlobs
    };

    var socket_ioParser = createCommonjsModule(function (module, exports) {
    /**
     * Module dependencies.
     */

    var debug = browser$1('socket.io-parser');





    /**
     * Protocol version.
     *
     * @api public
     */

    exports.protocol = 4;

    /**
     * Packet types.
     *
     * @api public
     */

    exports.types = [
      'CONNECT',
      'DISCONNECT',
      'EVENT',
      'ACK',
      'ERROR',
      'BINARY_EVENT',
      'BINARY_ACK'
    ];

    /**
     * Packet type `connect`.
     *
     * @api public
     */

    exports.CONNECT = 0;

    /**
     * Packet type `disconnect`.
     *
     * @api public
     */

    exports.DISCONNECT = 1;

    /**
     * Packet type `event`.
     *
     * @api public
     */

    exports.EVENT = 2;

    /**
     * Packet type `ack`.
     *
     * @api public
     */

    exports.ACK = 3;

    /**
     * Packet type `error`.
     *
     * @api public
     */

    exports.ERROR = 4;

    /**
     * Packet type 'binary event'
     *
     * @api public
     */

    exports.BINARY_EVENT = 5;

    /**
     * Packet type `binary ack`. For acks with binary arguments.
     *
     * @api public
     */

    exports.BINARY_ACK = 6;

    /**
     * Encoder constructor.
     *
     * @api public
     */

    exports.Encoder = Encoder;

    /**
     * Decoder constructor.
     *
     * @api public
     */

    exports.Decoder = Decoder;

    /**
     * A socket.io Encoder instance
     *
     * @api public
     */

    function Encoder() {}

    var ERROR_PACKET = exports.ERROR + '"encode error"';

    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     * @param {Function} callback - function to handle encodings (likely engine.write)
     * @return Calls callback with Array of encodings
     * @api public
     */

    Encoder.prototype.encode = function(obj, callback){
      debug('encoding packet %j', obj);

      if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
        encodeAsBinary(obj, callback);
      } else {
        var encoding = encodeAsString(obj);
        callback([encoding]);
      }
    };

    /**
     * Encode packet as string.
     *
     * @param {Object} packet
     * @return {String} encoded
     * @api private
     */

    function encodeAsString(obj) {

      // first is type
      var str = '' + obj.type;

      // attachments if we have them
      if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
        str += obj.attachments + '-';
      }

      // if we have a namespace other than `/`
      // we append it followed by a comma `,`
      if (obj.nsp && '/' !== obj.nsp) {
        str += obj.nsp + ',';
      }

      // immediately followed by the id
      if (null != obj.id) {
        str += obj.id;
      }

      // json data
      if (null != obj.data) {
        var payload = tryStringify(obj.data);
        if (payload !== false) {
          str += payload;
        } else {
          return ERROR_PACKET;
        }
      }

      debug('encoded %j as %s', obj, str);
      return str;
    }

    function tryStringify(str) {
      try {
        return JSON.stringify(str);
      } catch(e){
        return false;
      }
    }

    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     *
     * @param {Object} packet
     * @return {Buffer} encoded
     * @api private
     */

    function encodeAsBinary(obj, callback) {

      function writeEncoding(bloblessData) {
        var deconstruction = binary.deconstructPacket(bloblessData);
        var pack = encodeAsString(deconstruction.packet);
        var buffers = deconstruction.buffers;

        buffers.unshift(pack); // add packet info to beginning of data list
        callback(buffers); // write all the buffers
      }

      binary.removeBlobs(obj, writeEncoding);
    }

    /**
     * A socket.io Decoder instance
     *
     * @return {Object} decoder
     * @api public
     */

    function Decoder() {
      this.reconstructor = null;
    }

    /**
     * Mix in `Emitter` with Decoder.
     */

    componentEmitter(Decoder.prototype);

    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     * @return {Object} packet
     * @api public
     */

    Decoder.prototype.add = function(obj) {
      var packet;
      if (typeof obj === 'string') {
        packet = decodeString(obj);
        if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
          this.reconstructor = new BinaryReconstructor(packet);

          // no attachments, labeled binary but no binary data to follow
          if (this.reconstructor.reconPack.attachments === 0) {
            this.emit('decoded', packet);
          }
        } else { // non-binary full packet
          this.emit('decoded', packet);
        }
      } else if (isBuffer(obj) || obj.base64) { // raw binary data
        if (!this.reconstructor) {
          throw new Error('got binary data when not reconstructing a packet');
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) { // received final buffer
            this.reconstructor = null;
            this.emit('decoded', packet);
          }
        }
      } else {
        throw new Error('Unknown type: ' + obj);
      }
    };

    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     * @api private
     */

    function decodeString(str) {
      var i = 0;
      // look up type
      var p = {
        type: Number(str.charAt(0))
      };

      if (null == exports.types[p.type]) {
        return error('unknown packet type ' + p.type);
      }

      // look up attachments if type binary
      if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
        var buf = '';
        while (str.charAt(++i) !== '-') {
          buf += str.charAt(i);
          if (i == str.length) break;
        }
        if (buf != Number(buf) || str.charAt(i) !== '-') {
          throw new Error('Illegal attachments');
        }
        p.attachments = Number(buf);
      }

      // look up namespace (if any)
      if ('/' === str.charAt(i + 1)) {
        p.nsp = '';
        while (++i) {
          var c = str.charAt(i);
          if (',' === c) break;
          p.nsp += c;
          if (i === str.length) break;
        }
      } else {
        p.nsp = '/';
      }

      // look up id
      var next = str.charAt(i + 1);
      if ('' !== next && Number(next) == next) {
        p.id = '';
        while (++i) {
          var c = str.charAt(i);
          if (null == c || Number(c) != c) {
            --i;
            break;
          }
          p.id += str.charAt(i);
          if (i === str.length) break;
        }
        p.id = Number(p.id);
      }

      // look up json data
      if (str.charAt(++i)) {
        var payload = tryParse(str.substr(i));
        var isPayloadValid = payload !== false && (p.type === exports.ERROR || isarray(payload));
        if (isPayloadValid) {
          p.data = payload;
        } else {
          return error('invalid payload');
        }
      }

      debug('decoded %s as %j', str, p);
      return p;
    }

    function tryParse(str) {
      try {
        return JSON.parse(str);
      } catch(e){
        return false;
      }
    }

    /**
     * Deallocates a parser's resources
     *
     * @api public
     */

    Decoder.prototype.destroy = function() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
      }
    };

    /**
     * A manager of a binary event's 'buffer sequence'. Should
     * be constructed whenever a packet of type BINARY_EVENT is
     * decoded.
     *
     * @param {Object} packet
     * @return {BinaryReconstructor} initialized reconstructor
     * @api private
     */

    function BinaryReconstructor(packet) {
      this.reconPack = packet;
      this.buffers = [];
    }

    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     * @api private
     */

    BinaryReconstructor.prototype.takeBinaryData = function(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
        var packet = binary.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    };

    /**
     * Cleans up binary packet reconstruction variables.
     *
     * @api private
     */

    BinaryReconstructor.prototype.finishedReconstruction = function() {
      this.reconPack = null;
      this.buffers = [];
    };

    function error(msg) {
      return {
        type: exports.ERROR,
        data: 'parser error: ' + msg
      };
    }
    });
    var socket_ioParser_1 = socket_ioParser.protocol;
    var socket_ioParser_2 = socket_ioParser.types;
    var socket_ioParser_3 = socket_ioParser.CONNECT;
    var socket_ioParser_4 = socket_ioParser.DISCONNECT;
    var socket_ioParser_5 = socket_ioParser.EVENT;
    var socket_ioParser_6 = socket_ioParser.ACK;
    var socket_ioParser_7 = socket_ioParser.ERROR;
    var socket_ioParser_8 = socket_ioParser.BINARY_EVENT;
    var socket_ioParser_9 = socket_ioParser.BINARY_ACK;
    var socket_ioParser_10 = socket_ioParser.Encoder;
    var socket_ioParser_11 = socket_ioParser.Decoder;

    var hasCors = createCommonjsModule(function (module) {
    /**
     * Module exports.
     *
     * Logic borrowed from Modernizr:
     *
     *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
     */

    try {
      module.exports = typeof XMLHttpRequest !== 'undefined' &&
        'withCredentials' in new XMLHttpRequest();
    } catch (err) {
      // if XMLHttp support is disabled in IE then it will throw
      // when trying to create
      module.exports = false;
    }
    });

    // browser shim for xmlhttprequest module



    var xmlhttprequest = function (opts) {
      var xdomain = opts.xdomain;

      // scheme must be same when usign XDomainRequest
      // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
      var xscheme = opts.xscheme;

      // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
      // https://github.com/Automattic/engine.io-client/pull/217
      var enablesXDR = opts.enablesXDR;

      // XMLHttpRequest can be disabled on IE
      try {
        if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCors)) {
          return new XMLHttpRequest();
        }
      } catch (e) { }

      // Use XDomainRequest for IE8 if enablesXDR is true
      // because loading bar keeps flashing when using jsonp-polling
      // https://github.com/yujiosaka/socke.io-ie8-loading-example
      try {
        if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
          return new XDomainRequest();
        }
      } catch (e) { }

      if (!xdomain) {
        try {
          return new self[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
        } catch (e) { }
      }
    };

    /**
     * Gets the keys for an object.
     *
     * @return {Array} keys
     * @api private
     */

    var keys = Object.keys || function keys (obj){
      var arr = [];
      var has = Object.prototype.hasOwnProperty;

      for (var i in obj) {
        if (has.call(obj, i)) {
          arr.push(i);
        }
      }
      return arr;
    };

    var toString$2 = {}.toString;

    var isarray$1 = Array.isArray || function (arr) {
      return toString$2.call(arr) == '[object Array]';
    };

    /* global Blob File */

    /*
     * Module requirements.
     */



    var toString$3 = Object.prototype.toString;
    var withNativeBlob$1 = typeof Blob === 'function' ||
                            typeof Blob !== 'undefined' && toString$3.call(Blob) === '[object BlobConstructor]';
    var withNativeFile$1 = typeof File === 'function' ||
                            typeof File !== 'undefined' && toString$3.call(File) === '[object FileConstructor]';

    /**
     * Module exports.
     */

    var hasBinary2 = hasBinary;

    /**
     * Checks for binary data.
     *
     * Supports Buffer, ArrayBuffer, Blob and File.
     *
     * @param {Object} anything
     * @api public
     */

    function hasBinary (obj) {
      if (!obj || typeof obj !== 'object') {
        return false;
      }

      if (isarray$1(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          if (hasBinary(obj[i])) {
            return true;
          }
        }
        return false;
      }

      if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
        (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
        (withNativeBlob$1 && obj instanceof Blob) ||
        (withNativeFile$1 && obj instanceof File)
      ) {
        return true;
      }

      // see: https://github.com/Automattic/has-binary/pull/4
      if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
          return true;
        }
      }

      return false;
    }

    /**
     * An abstraction for slicing an arraybuffer even when
     * ArrayBuffer.prototype.slice is not supported
     *
     * @api public
     */

    var arraybuffer_slice = function(arraybuffer, start, end) {
      var bytes = arraybuffer.byteLength;
      start = start || 0;
      end = end || bytes;

      if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

      if (start < 0) { start += bytes; }
      if (end < 0) { end += bytes; }
      if (end > bytes) { end = bytes; }

      if (start >= bytes || start >= end || bytes === 0) {
        return new ArrayBuffer(0);
      }

      var abv = new Uint8Array(arraybuffer);
      var result = new Uint8Array(end - start);
      for (var i = start, ii = 0; i < end; i++, ii++) {
        result[ii] = abv[i];
      }
      return result.buffer;
    };

    var after_1 = after;

    function after(count, callback, err_cb) {
        var bail = false;
        err_cb = err_cb || noop$1;
        proxy.count = count;

        return (count === 0) ? callback() : proxy

        function proxy(err, result) {
            if (proxy.count <= 0) {
                throw new Error('after called too many times')
            }
            --proxy.count;

            // after first error, rest are passed to err_cb
            if (err) {
                bail = true;
                callback(err);
                // future error callbacks will go to error handler
                callback = err_cb;
            } else if (proxy.count === 0 && !bail) {
                callback(null, result);
            }
        }
    }

    function noop$1() {}

    /*! https://mths.be/utf8js v2.1.2 by @mathias */

    var stringFromCharCode = String.fromCharCode;

    // Taken from https://mths.be/punycode
    function ucs2decode(string) {
    	var output = [];
    	var counter = 0;
    	var length = string.length;
    	var value;
    	var extra;
    	while (counter < length) {
    		value = string.charCodeAt(counter++);
    		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
    			// high surrogate, and there is a next character
    			extra = string.charCodeAt(counter++);
    			if ((extra & 0xFC00) == 0xDC00) { // low surrogate
    				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
    			} else {
    				// unmatched surrogate; only append this code unit, in case the next
    				// code unit is the high surrogate of a surrogate pair
    				output.push(value);
    				counter--;
    			}
    		} else {
    			output.push(value);
    		}
    	}
    	return output;
    }

    // Taken from https://mths.be/punycode
    function ucs2encode(array) {
    	var length = array.length;
    	var index = -1;
    	var value;
    	var output = '';
    	while (++index < length) {
    		value = array[index];
    		if (value > 0xFFFF) {
    			value -= 0x10000;
    			output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
    			value = 0xDC00 | value & 0x3FF;
    		}
    		output += stringFromCharCode(value);
    	}
    	return output;
    }

    function checkScalarValue(codePoint, strict) {
    	if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
    		if (strict) {
    			throw Error(
    				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
    				' is not a scalar value'
    			);
    		}
    		return false;
    	}
    	return true;
    }
    /*--------------------------------------------------------------------------*/

    function createByte(codePoint, shift) {
    	return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
    }

    function encodeCodePoint(codePoint, strict) {
    	if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
    		return stringFromCharCode(codePoint);
    	}
    	var symbol = '';
    	if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
    		symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
    	}
    	else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
    		if (!checkScalarValue(codePoint, strict)) {
    			codePoint = 0xFFFD;
    		}
    		symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
    		symbol += createByte(codePoint, 6);
    	}
    	else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
    		symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
    		symbol += createByte(codePoint, 12);
    		symbol += createByte(codePoint, 6);
    	}
    	symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
    	return symbol;
    }

    function utf8encode(string, opts) {
    	opts = opts || {};
    	var strict = false !== opts.strict;

    	var codePoints = ucs2decode(string);
    	var length = codePoints.length;
    	var index = -1;
    	var codePoint;
    	var byteString = '';
    	while (++index < length) {
    		codePoint = codePoints[index];
    		byteString += encodeCodePoint(codePoint, strict);
    	}
    	return byteString;
    }

    /*--------------------------------------------------------------------------*/

    function readContinuationByte() {
    	if (byteIndex >= byteCount) {
    		throw Error('Invalid byte index');
    	}

    	var continuationByte = byteArray[byteIndex] & 0xFF;
    	byteIndex++;

    	if ((continuationByte & 0xC0) == 0x80) {
    		return continuationByte & 0x3F;
    	}

    	// If we end up here, its not a continuation byte
    	throw Error('Invalid continuation byte');
    }

    function decodeSymbol(strict) {
    	var byte1;
    	var byte2;
    	var byte3;
    	var byte4;
    	var codePoint;

    	if (byteIndex > byteCount) {
    		throw Error('Invalid byte index');
    	}

    	if (byteIndex == byteCount) {
    		return false;
    	}

    	// Read first byte
    	byte1 = byteArray[byteIndex] & 0xFF;
    	byteIndex++;

    	// 1-byte sequence (no continuation bytes)
    	if ((byte1 & 0x80) == 0) {
    		return byte1;
    	}

    	// 2-byte sequence
    	if ((byte1 & 0xE0) == 0xC0) {
    		byte2 = readContinuationByte();
    		codePoint = ((byte1 & 0x1F) << 6) | byte2;
    		if (codePoint >= 0x80) {
    			return codePoint;
    		} else {
    			throw Error('Invalid continuation byte');
    		}
    	}

    	// 3-byte sequence (may include unpaired surrogates)
    	if ((byte1 & 0xF0) == 0xE0) {
    		byte2 = readContinuationByte();
    		byte3 = readContinuationByte();
    		codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
    		if (codePoint >= 0x0800) {
    			return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
    		} else {
    			throw Error('Invalid continuation byte');
    		}
    	}

    	// 4-byte sequence
    	if ((byte1 & 0xF8) == 0xF0) {
    		byte2 = readContinuationByte();
    		byte3 = readContinuationByte();
    		byte4 = readContinuationByte();
    		codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
    			(byte3 << 0x06) | byte4;
    		if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
    			return codePoint;
    		}
    	}

    	throw Error('Invalid UTF-8 detected');
    }

    var byteArray;
    var byteCount;
    var byteIndex;
    function utf8decode(byteString, opts) {
    	opts = opts || {};
    	var strict = false !== opts.strict;

    	byteArray = ucs2decode(byteString);
    	byteCount = byteArray.length;
    	byteIndex = 0;
    	var codePoints = [];
    	var tmp;
    	while ((tmp = decodeSymbol(strict)) !== false) {
    		codePoints.push(tmp);
    	}
    	return ucs2encode(codePoints);
    }

    var utf8 = {
    	version: '2.1.2',
    	encode: utf8encode,
    	decode: utf8decode
    };

    var base64Arraybuffer = createCommonjsModule(function (module, exports) {
    /*
     * base64-arraybuffer
     * https://github.com/niklasvh/base64-arraybuffer
     *
     * Copyright (c) 2012 Niklas von Hertzen
     * Licensed under the MIT license.
     */
    (function(){

      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

      // Use a lookup table to find the index.
      var lookup = new Uint8Array(256);
      for (var i = 0; i < chars.length; i++) {
        lookup[chars.charCodeAt(i)] = i;
      }

      exports.encode = function(arraybuffer) {
        var bytes = new Uint8Array(arraybuffer),
        i, len = bytes.length, base64 = "";

        for (i = 0; i < len; i+=3) {
          base64 += chars[bytes[i] >> 2];
          base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
          base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
          base64 += chars[bytes[i + 2] & 63];
        }

        if ((len % 3) === 2) {
          base64 = base64.substring(0, base64.length - 1) + "=";
        } else if (len % 3 === 1) {
          base64 = base64.substring(0, base64.length - 2) + "==";
        }

        return base64;
      };

      exports.decode =  function(base64) {
        var bufferLength = base64.length * 0.75,
        len = base64.length, i, p = 0,
        encoded1, encoded2, encoded3, encoded4;

        if (base64[base64.length - 1] === "=") {
          bufferLength--;
          if (base64[base64.length - 2] === "=") {
            bufferLength--;
          }
        }

        var arraybuffer = new ArrayBuffer(bufferLength),
        bytes = new Uint8Array(arraybuffer);

        for (i = 0; i < len; i+=4) {
          encoded1 = lookup[base64.charCodeAt(i)];
          encoded2 = lookup[base64.charCodeAt(i+1)];
          encoded3 = lookup[base64.charCodeAt(i+2)];
          encoded4 = lookup[base64.charCodeAt(i+3)];

          bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
          bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
          bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
        }

        return arraybuffer;
      };
    })();
    });
    var base64Arraybuffer_1 = base64Arraybuffer.encode;
    var base64Arraybuffer_2 = base64Arraybuffer.decode;

    /**
     * Create a blob builder even when vendor prefixes exist
     */

    var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
      typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :
      typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
      typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : 
      false;

    /**
     * Check if Blob constructor is supported
     */

    var blobSupported = (function() {
      try {
        var a = new Blob(['hi']);
        return a.size === 2;
      } catch(e) {
        return false;
      }
    })();

    /**
     * Check if Blob constructor supports ArrayBufferViews
     * Fails in Safari 6, so we need to map to ArrayBuffers there.
     */

    var blobSupportsArrayBufferView = blobSupported && (function() {
      try {
        var b = new Blob([new Uint8Array([1,2])]);
        return b.size === 2;
      } catch(e) {
        return false;
      }
    })();

    /**
     * Check if BlobBuilder is supported
     */

    var blobBuilderSupported = BlobBuilder
      && BlobBuilder.prototype.append
      && BlobBuilder.prototype.getBlob;

    /**
     * Helper function that maps ArrayBufferViews to ArrayBuffers
     * Used by BlobBuilder constructor and old browsers that didn't
     * support it in the Blob constructor.
     */

    function mapArrayBufferViews(ary) {
      return ary.map(function(chunk) {
        if (chunk.buffer instanceof ArrayBuffer) {
          var buf = chunk.buffer;

          // if this is a subarray, make a copy so we only
          // include the subarray region from the underlying buffer
          if (chunk.byteLength !== buf.byteLength) {
            var copy = new Uint8Array(chunk.byteLength);
            copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
            buf = copy.buffer;
          }

          return buf;
        }

        return chunk;
      });
    }

    function BlobBuilderConstructor(ary, options) {
      options = options || {};

      var bb = new BlobBuilder();
      mapArrayBufferViews(ary).forEach(function(part) {
        bb.append(part);
      });

      return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
    }
    function BlobConstructor(ary, options) {
      return new Blob(mapArrayBufferViews(ary), options || {});
    }
    if (typeof Blob !== 'undefined') {
      BlobBuilderConstructor.prototype = Blob.prototype;
      BlobConstructor.prototype = Blob.prototype;
    }

    var blob = (function() {
      if (blobSupported) {
        return blobSupportsArrayBufferView ? Blob : BlobConstructor;
      } else if (blobBuilderSupported) {
        return BlobBuilderConstructor;
      } else {
        return undefined;
      }
    })();

    var browser$2 = createCommonjsModule(function (module, exports) {
    /**
     * Module dependencies.
     */







    var base64encoder;
    if (typeof ArrayBuffer !== 'undefined') {
      base64encoder = base64Arraybuffer;
    }

    /**
     * Check if we are running an android browser. That requires us to use
     * ArrayBuffer with polling transports...
     *
     * http://ghinda.net/jpeg-blob-ajax-android/
     */

    var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

    /**
     * Check if we are running in PhantomJS.
     * Uploading a Blob with PhantomJS does not work correctly, as reported here:
     * https://github.com/ariya/phantomjs/issues/11395
     * @type boolean
     */
    var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

    /**
     * When true, avoids using Blobs to encode payloads.
     * @type boolean
     */
    var dontSendBlobs = isAndroid || isPhantomJS;

    /**
     * Current protocol version.
     */

    exports.protocol = 3;

    /**
     * Packet types.
     */

    var packets = exports.packets = {
        open:     0    // non-ws
      , close:    1    // non-ws
      , ping:     2
      , pong:     3
      , message:  4
      , upgrade:  5
      , noop:     6
    };

    var packetslist = keys(packets);

    /**
     * Premade error packet.
     */

    var err = { type: 'error', data: 'parser error' };

    /**
     * Create a blob api even for blob builder when vendor prefixes exist
     */



    /**
     * Encodes a packet.
     *
     *     <packet type id> [ <data> ]
     *
     * Example:
     *
     *     5hello world
     *     3
     *     4
     *
     * Binary is encoded in an identical principle
     *
     * @api private
     */

    exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
      if (typeof supportsBinary === 'function') {
        callback = supportsBinary;
        supportsBinary = false;
      }

      if (typeof utf8encode === 'function') {
        callback = utf8encode;
        utf8encode = null;
      }

      var data = (packet.data === undefined)
        ? undefined
        : packet.data.buffer || packet.data;

      if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
        return encodeArrayBuffer(packet, supportsBinary, callback);
      } else if (typeof blob !== 'undefined' && data instanceof blob) {
        return encodeBlob(packet, supportsBinary, callback);
      }

      // might be an object with { base64: true, data: dataAsBase64String }
      if (data && data.base64) {
        return encodeBase64Object(packet, callback);
      }

      // Sending data as a utf-8 string
      var encoded = packets[packet.type];

      // data fragment is optional
      if (undefined !== packet.data) {
        encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
      }

      return callback('' + encoded);

    };

    function encodeBase64Object(packet, callback) {
      // packet data is an object { base64: true, data: dataAsBase64String }
      var message = 'b' + exports.packets[packet.type] + packet.data.data;
      return callback(message);
    }

    /**
     * Encode packet helpers for binary types
     */

    function encodeArrayBuffer(packet, supportsBinary, callback) {
      if (!supportsBinary) {
        return exports.encodeBase64Packet(packet, callback);
      }

      var data = packet.data;
      var contentArray = new Uint8Array(data);
      var resultBuffer = new Uint8Array(1 + data.byteLength);

      resultBuffer[0] = packets[packet.type];
      for (var i = 0; i < contentArray.length; i++) {
        resultBuffer[i+1] = contentArray[i];
      }

      return callback(resultBuffer.buffer);
    }

    function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
      if (!supportsBinary) {
        return exports.encodeBase64Packet(packet, callback);
      }

      var fr = new FileReader();
      fr.onload = function() {
        exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);
      };
      return fr.readAsArrayBuffer(packet.data);
    }

    function encodeBlob(packet, supportsBinary, callback) {
      if (!supportsBinary) {
        return exports.encodeBase64Packet(packet, callback);
      }

      if (dontSendBlobs) {
        return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
      }

      var length = new Uint8Array(1);
      length[0] = packets[packet.type];
      var blob$1 = new blob([length.buffer, packet.data]);

      return callback(blob$1);
    }

    /**
     * Encodes a packet with binary data in a base64 string
     *
     * @param {Object} packet, has `type` and `data`
     * @return {String} base64 encoded message
     */

    exports.encodeBase64Packet = function(packet, callback) {
      var message = 'b' + exports.packets[packet.type];
      if (typeof blob !== 'undefined' && packet.data instanceof blob) {
        var fr = new FileReader();
        fr.onload = function() {
          var b64 = fr.result.split(',')[1];
          callback(message + b64);
        };
        return fr.readAsDataURL(packet.data);
      }

      var b64data;
      try {
        b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
      } catch (e) {
        // iPhone Safari doesn't let you apply with typed arrays
        var typed = new Uint8Array(packet.data);
        var basic = new Array(typed.length);
        for (var i = 0; i < typed.length; i++) {
          basic[i] = typed[i];
        }
        b64data = String.fromCharCode.apply(null, basic);
      }
      message += btoa(b64data);
      return callback(message);
    };

    /**
     * Decodes a packet. Changes format to Blob if requested.
     *
     * @return {Object} with `type` and `data` (if any)
     * @api private
     */

    exports.decodePacket = function (data, binaryType, utf8decode) {
      if (data === undefined) {
        return err;
      }
      // String data
      if (typeof data === 'string') {
        if (data.charAt(0) === 'b') {
          return exports.decodeBase64Packet(data.substr(1), binaryType);
        }

        if (utf8decode) {
          data = tryDecode(data);
          if (data === false) {
            return err;
          }
        }
        var type = data.charAt(0);

        if (Number(type) != type || !packetslist[type]) {
          return err;
        }

        if (data.length > 1) {
          return { type: packetslist[type], data: data.substring(1) };
        } else {
          return { type: packetslist[type] };
        }
      }

      var asArray = new Uint8Array(data);
      var type = asArray[0];
      var rest = arraybuffer_slice(data, 1);
      if (blob && binaryType === 'blob') {
        rest = new blob([rest]);
      }
      return { type: packetslist[type], data: rest };
    };

    function tryDecode(data) {
      try {
        data = utf8.decode(data, { strict: false });
      } catch (e) {
        return false;
      }
      return data;
    }

    /**
     * Decodes a packet encoded in a base64 string
     *
     * @param {String} base64 encoded message
     * @return {Object} with `type` and `data` (if any)
     */

    exports.decodeBase64Packet = function(msg, binaryType) {
      var type = packetslist[msg.charAt(0)];
      if (!base64encoder) {
        return { type: type, data: { base64: true, data: msg.substr(1) } };
      }

      var data = base64encoder.decode(msg.substr(1));

      if (binaryType === 'blob' && blob) {
        data = new blob([data]);
      }

      return { type: type, data: data };
    };

    /**
     * Encodes multiple messages (payload).
     *
     *     <length>:data
     *
     * Example:
     *
     *     11:hello world2:hi
     *
     * If any contents are binary, they will be encoded as base64 strings. Base64
     * encoded strings are marked with a b before the length specifier
     *
     * @param {Array} packets
     * @api private
     */

    exports.encodePayload = function (packets, supportsBinary, callback) {
      if (typeof supportsBinary === 'function') {
        callback = supportsBinary;
        supportsBinary = null;
      }

      var isBinary = hasBinary2(packets);

      if (supportsBinary && isBinary) {
        if (blob && !dontSendBlobs) {
          return exports.encodePayloadAsBlob(packets, callback);
        }

        return exports.encodePayloadAsArrayBuffer(packets, callback);
      }

      if (!packets.length) {
        return callback('0:');
      }

      function setLengthHeader(message) {
        return message.length + ':' + message;
      }

      function encodeOne(packet, doneCallback) {
        exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
          doneCallback(null, setLengthHeader(message));
        });
      }

      map(packets, encodeOne, function(err, results) {
        return callback(results.join(''));
      });
    };

    /**
     * Async array map using after
     */

    function map(ary, each, done) {
      var result = new Array(ary.length);
      var next = after_1(ary.length, done);

      var eachWithIndex = function(i, el, cb) {
        each(el, function(error, msg) {
          result[i] = msg;
          cb(error, result);
        });
      };

      for (var i = 0; i < ary.length; i++) {
        eachWithIndex(i, ary[i], next);
      }
    }

    /*
     * Decodes data when a payload is maybe expected. Possible binary contents are
     * decoded from their base64 representation
     *
     * @param {String} data, callback method
     * @api public
     */

    exports.decodePayload = function (data, binaryType, callback) {
      if (typeof data !== 'string') {
        return exports.decodePayloadAsBinary(data, binaryType, callback);
      }

      if (typeof binaryType === 'function') {
        callback = binaryType;
        binaryType = null;
      }

      var packet;
      if (data === '') {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      var length = '', n, msg;

      for (var i = 0, l = data.length; i < l; i++) {
        var chr = data.charAt(i);

        if (chr !== ':') {
          length += chr;
          continue;
        }

        if (length === '' || (length != (n = Number(length)))) {
          // parser error - ignoring payload
          return callback(err, 0, 1);
        }

        msg = data.substr(i + 1, n);

        if (length != msg.length) {
          // parser error - ignoring payload
          return callback(err, 0, 1);
        }

        if (msg.length) {
          packet = exports.decodePacket(msg, binaryType, false);

          if (err.type === packet.type && err.data === packet.data) {
            // parser error in individual packet - ignoring payload
            return callback(err, 0, 1);
          }

          var ret = callback(packet, i + n, l);
          if (false === ret) return;
        }

        // advance cursor
        i += n;
        length = '';
      }

      if (length !== '') {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

    };

    /**
     * Encodes multiple messages (payload) as binary.
     *
     * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
     * 255><data>
     *
     * Example:
     * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
     *
     * @param {Array} packets
     * @return {ArrayBuffer} encoded payload
     * @api private
     */

    exports.encodePayloadAsArrayBuffer = function(packets, callback) {
      if (!packets.length) {
        return callback(new ArrayBuffer(0));
      }

      function encodeOne(packet, doneCallback) {
        exports.encodePacket(packet, true, true, function(data) {
          return doneCallback(null, data);
        });
      }

      map(packets, encodeOne, function(err, encodedPackets) {
        var totalLength = encodedPackets.reduce(function(acc, p) {
          var len;
          if (typeof p === 'string'){
            len = p.length;
          } else {
            len = p.byteLength;
          }
          return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
        }, 0);

        var resultArray = new Uint8Array(totalLength);

        var bufferIndex = 0;
        encodedPackets.forEach(function(p) {
          var isString = typeof p === 'string';
          var ab = p;
          if (isString) {
            var view = new Uint8Array(p.length);
            for (var i = 0; i < p.length; i++) {
              view[i] = p.charCodeAt(i);
            }
            ab = view.buffer;
          }

          if (isString) { // not true binary
            resultArray[bufferIndex++] = 0;
          } else { // true binary
            resultArray[bufferIndex++] = 1;
          }

          var lenStr = ab.byteLength.toString();
          for (var i = 0; i < lenStr.length; i++) {
            resultArray[bufferIndex++] = parseInt(lenStr[i]);
          }
          resultArray[bufferIndex++] = 255;

          var view = new Uint8Array(ab);
          for (var i = 0; i < view.length; i++) {
            resultArray[bufferIndex++] = view[i];
          }
        });

        return callback(resultArray.buffer);
      });
    };

    /**
     * Encode as Blob
     */

    exports.encodePayloadAsBlob = function(packets, callback) {
      function encodeOne(packet, doneCallback) {
        exports.encodePacket(packet, true, true, function(encoded) {
          var binaryIdentifier = new Uint8Array(1);
          binaryIdentifier[0] = 1;
          if (typeof encoded === 'string') {
            var view = new Uint8Array(encoded.length);
            for (var i = 0; i < encoded.length; i++) {
              view[i] = encoded.charCodeAt(i);
            }
            encoded = view.buffer;
            binaryIdentifier[0] = 0;
          }

          var len = (encoded instanceof ArrayBuffer)
            ? encoded.byteLength
            : encoded.size;

          var lenStr = len.toString();
          var lengthAry = new Uint8Array(lenStr.length + 1);
          for (var i = 0; i < lenStr.length; i++) {
            lengthAry[i] = parseInt(lenStr[i]);
          }
          lengthAry[lenStr.length] = 255;

          if (blob) {
            var blob$1 = new blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
            doneCallback(null, blob$1);
          }
        });
      }

      map(packets, encodeOne, function(err, results) {
        return callback(new blob(results));
      });
    };

    /*
     * Decodes data when a payload is maybe expected. Strings are decoded by
     * interpreting each byte as a key code for entries marked to start with 0. See
     * description of encodePayloadAsBinary
     *
     * @param {ArrayBuffer} data, callback method
     * @api public
     */

    exports.decodePayloadAsBinary = function (data, binaryType, callback) {
      if (typeof binaryType === 'function') {
        callback = binaryType;
        binaryType = null;
      }

      var bufferTail = data;
      var buffers = [];

      while (bufferTail.byteLength > 0) {
        var tailArray = new Uint8Array(bufferTail);
        var isString = tailArray[0] === 0;
        var msgLength = '';

        for (var i = 1; ; i++) {
          if (tailArray[i] === 255) break;

          // 310 = char length of Number.MAX_VALUE
          if (msgLength.length > 310) {
            return callback(err, 0, 1);
          }

          msgLength += tailArray[i];
        }

        bufferTail = arraybuffer_slice(bufferTail, 2 + msgLength.length);
        msgLength = parseInt(msgLength);

        var msg = arraybuffer_slice(bufferTail, 0, msgLength);
        if (isString) {
          try {
            msg = String.fromCharCode.apply(null, new Uint8Array(msg));
          } catch (e) {
            // iPhone Safari doesn't let you apply to typed arrays
            var typed = new Uint8Array(msg);
            msg = '';
            for (var i = 0; i < typed.length; i++) {
              msg += String.fromCharCode(typed[i]);
            }
          }
        }

        buffers.push(msg);
        bufferTail = arraybuffer_slice(bufferTail, msgLength);
      }

      var total = buffers.length;
      buffers.forEach(function(buffer, i) {
        callback(exports.decodePacket(buffer, binaryType, true), i, total);
      });
    };
    });
    var browser_1$2 = browser$2.protocol;
    var browser_2$2 = browser$2.packets;
    var browser_3$2 = browser$2.encodePacket;
    var browser_4$2 = browser$2.encodeBase64Packet;
    var browser_5$2 = browser$2.decodePacket;
    var browser_6$2 = browser$2.decodeBase64Packet;
    var browser_7$2 = browser$2.encodePayload;
    var browser_8 = browser$2.decodePayload;
    var browser_9 = browser$2.encodePayloadAsArrayBuffer;
    var browser_10 = browser$2.encodePayloadAsBlob;
    var browser_11 = browser$2.decodePayloadAsBinary;

    var componentEmitter$1 = createCommonjsModule(function (module) {
    /**
     * Expose `Emitter`.
     */

    {
      module.exports = Emitter;
    }

    /**
     * Initialize a new `Emitter`.
     *
     * @api public
     */

    function Emitter(obj) {
      if (obj) return mixin(obj);
    }
    /**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }

    /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.on =
    Emitter.prototype.addEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};
      (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
        .push(fn);
      return this;
    };

    /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.once = function(event, fn){
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }

      on.fn = fn;
      this.on(event, on);
      return this;
    };

    /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.off =
    Emitter.prototype.removeListener =
    Emitter.prototype.removeAllListeners =
    Emitter.prototype.removeEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};

      // all
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }

      // specific event
      var callbacks = this._callbacks['$' + event];
      if (!callbacks) return this;

      // remove all handlers
      if (1 == arguments.length) {
        delete this._callbacks['$' + event];
        return this;
      }

      // remove specific handler
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      return this;
    };

    /**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */

    Emitter.prototype.emit = function(event){
      this._callbacks = this._callbacks || {};
      var args = [].slice.call(arguments, 1)
        , callbacks = this._callbacks['$' + event];

      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }

      return this;
    };

    /**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */

    Emitter.prototype.listeners = function(event){
      this._callbacks = this._callbacks || {};
      return this._callbacks['$' + event] || [];
    };

    /**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */

    Emitter.prototype.hasListeners = function(event){
      return !! this.listeners(event).length;
    };
    });

    /**
     * Module dependencies.
     */




    /**
     * Module exports.
     */

    var transport = Transport;

    /**
     * Transport abstract constructor.
     *
     * @param {Object} options.
     * @api private
     */

    function Transport (opts) {
      this.path = opts.path;
      this.hostname = opts.hostname;
      this.port = opts.port;
      this.secure = opts.secure;
      this.query = opts.query;
      this.timestampParam = opts.timestampParam;
      this.timestampRequests = opts.timestampRequests;
      this.readyState = '';
      this.agent = opts.agent || false;
      this.socket = opts.socket;
      this.enablesXDR = opts.enablesXDR;
      this.withCredentials = opts.withCredentials;

      // SSL options for Node.js client
      this.pfx = opts.pfx;
      this.key = opts.key;
      this.passphrase = opts.passphrase;
      this.cert = opts.cert;
      this.ca = opts.ca;
      this.ciphers = opts.ciphers;
      this.rejectUnauthorized = opts.rejectUnauthorized;
      this.forceNode = opts.forceNode;

      // results of ReactNative environment detection
      this.isReactNative = opts.isReactNative;

      // other options for Node.js client
      this.extraHeaders = opts.extraHeaders;
      this.localAddress = opts.localAddress;
    }

    /**
     * Mix in `Emitter`.
     */

    componentEmitter$1(Transport.prototype);

    /**
     * Emits an error.
     *
     * @param {String} str
     * @return {Transport} for chaining
     * @api public
     */

    Transport.prototype.onError = function (msg, desc) {
      var err = new Error(msg);
      err.type = 'TransportError';
      err.description = desc;
      this.emit('error', err);
      return this;
    };

    /**
     * Opens the transport.
     *
     * @api public
     */

    Transport.prototype.open = function () {
      if ('closed' === this.readyState || '' === this.readyState) {
        this.readyState = 'opening';
        this.doOpen();
      }

      return this;
    };

    /**
     * Closes the transport.
     *
     * @api private
     */

    Transport.prototype.close = function () {
      if ('opening' === this.readyState || 'open' === this.readyState) {
        this.doClose();
        this.onClose();
      }

      return this;
    };

    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     * @api private
     */

    Transport.prototype.send = function (packets) {
      if ('open' === this.readyState) {
        this.write(packets);
      } else {
        throw new Error('Transport not open');
      }
    };

    /**
     * Called upon open
     *
     * @api private
     */

    Transport.prototype.onOpen = function () {
      this.readyState = 'open';
      this.writable = true;
      this.emit('open');
    };

    /**
     * Called with data.
     *
     * @param {String} data
     * @api private
     */

    Transport.prototype.onData = function (data) {
      var packet = browser$2.decodePacket(data, this.socket.binaryType);
      this.onPacket(packet);
    };

    /**
     * Called with a decoded packet.
     */

    Transport.prototype.onPacket = function (packet) {
      this.emit('packet', packet);
    };

    /**
     * Called upon close.
     *
     * @api private
     */

    Transport.prototype.onClose = function () {
      this.readyState = 'closed';
      this.emit('close');
    };

    /**
     * Compiles a querystring
     * Returns string representation of the object
     *
     * @param {Object}
     * @api private
     */

    var encode = function (obj) {
      var str = '';

      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          if (str.length) str += '&';
          str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
        }
      }

      return str;
    };

    /**
     * Parses a simple querystring into an object
     *
     * @param {String} qs
     * @api private
     */

    var decode = function(qs){
      var qry = {};
      var pairs = qs.split('&');
      for (var i = 0, l = pairs.length; i < l; i++) {
        var pair = pairs[i].split('=');
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
      }
      return qry;
    };

    var parseqs = {
    	encode: encode,
    	decode: decode
    };

    var componentInherit = function(a, b){
      var fn = function(){};
      fn.prototype = b.prototype;
      a.prototype = new fn;
      a.prototype.constructor = a;
    };

    var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
      , length = 64
      , map = {}
      , seed = 0
      , i = 0
      , prev;

    /**
     * Return a string representing the specified number.
     *
     * @param {Number} num The number to convert.
     * @returns {String} The string representation of the number.
     * @api public
     */
    function encode$1(num) {
      var encoded = '';

      do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
      } while (num > 0);

      return encoded;
    }

    /**
     * Return the integer value specified by the given string.
     *
     * @param {String} str The string to convert.
     * @returns {Number} The integer value represented by the string.
     * @api public
     */
    function decode$1(str) {
      var decoded = 0;

      for (i = 0; i < str.length; i++) {
        decoded = decoded * length + map[str.charAt(i)];
      }

      return decoded;
    }

    /**
     * Yeast: A tiny growing id generator.
     *
     * @returns {String} A unique id.
     * @api public
     */
    function yeast() {
      var now = encode$1(+new Date());

      if (now !== prev) return seed = 0, prev = now;
      return now +'.'+ encode$1(seed++);
    }

    //
    // Map each character to its index.
    //
    for (; i < length; i++) map[alphabet[i]] = i;

    //
    // Expose the `yeast`, `encode` and `decode` functions.
    //
    yeast.encode = encode$1;
    yeast.decode = decode$1;
    var yeast_1 = yeast;

    /**
     * Helpers.
     */

    var s$2 = 1000;
    var m$2 = s$2 * 60;
    var h$2 = m$2 * 60;
    var d$2 = h$2 * 24;
    var w$1 = d$2 * 7;
    var y$2 = d$2 * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} [options]
     * @throws {Error} throw an error if val is not a non-empty string or a number
     * @return {String|Number}
     * @api public
     */

    var ms$2 = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse$2(val);
      } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong$2(val) : fmtShort$2(val);
      }
      throw new Error(
        'val is not a non-empty string or a valid number. val=' +
          JSON.stringify(val)
      );
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse$2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y$2;
        case 'weeks':
        case 'week':
        case 'w':
          return n * w$1;
        case 'days':
        case 'day':
        case 'd':
          return n * d$2;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h$2;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m$2;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s$2;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtShort$2(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d$2) {
        return Math.round(ms / d$2) + 'd';
      }
      if (msAbs >= h$2) {
        return Math.round(ms / h$2) + 'h';
      }
      if (msAbs >= m$2) {
        return Math.round(ms / m$2) + 'm';
      }
      if (msAbs >= s$2) {
        return Math.round(ms / s$2) + 's';
      }
      return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtLong$2(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d$2) {
        return plural$2(ms, msAbs, d$2, 'day');
      }
      if (msAbs >= h$2) {
        return plural$2(ms, msAbs, h$2, 'hour');
      }
      if (msAbs >= m$2) {
        return plural$2(ms, msAbs, m$2, 'minute');
      }
      if (msAbs >= s$2) {
        return plural$2(ms, msAbs, s$2, 'second');
      }
      return ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural$2(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    }

    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     */

    function setup$1(env) {
    	createDebug.debug = createDebug;
    	createDebug.default = createDebug;
    	createDebug.coerce = coerce;
    	createDebug.disable = disable;
    	createDebug.enable = enable;
    	createDebug.enabled = enabled;
    	createDebug.humanize = ms$2;

    	Object.keys(env).forEach(key => {
    		createDebug[key] = env[key];
    	});

    	/**
    	* Active `debug` instances.
    	*/
    	createDebug.instances = [];

    	/**
    	* The currently active debug mode names, and names to skip.
    	*/

    	createDebug.names = [];
    	createDebug.skips = [];

    	/**
    	* Map of special "%n" handling functions, for the debug "format" argument.
    	*
    	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    	*/
    	createDebug.formatters = {};

    	/**
    	* Selects a color for a debug namespace
    	* @param {String} namespace The namespace string for the for the debug instance to be colored
    	* @return {Number|String} An ANSI color code for the given namespace
    	* @api private
    	*/
    	function selectColor(namespace) {
    		let hash = 0;

    		for (let i = 0; i < namespace.length; i++) {
    			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
    			hash |= 0; // Convert to 32bit integer
    		}

    		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    	}
    	createDebug.selectColor = selectColor;

    	/**
    	* Create a debugger with the given `namespace`.
    	*
    	* @param {String} namespace
    	* @return {Function}
    	* @api public
    	*/
    	function createDebug(namespace) {
    		let prevTime;

    		function debug(...args) {
    			// Disabled?
    			if (!debug.enabled) {
    				return;
    			}

    			const self = debug;

    			// Set `diff` timestamp
    			const curr = Number(new Date());
    			const ms = curr - (prevTime || curr);
    			self.diff = ms;
    			self.prev = prevTime;
    			self.curr = curr;
    			prevTime = curr;

    			args[0] = createDebug.coerce(args[0]);

    			if (typeof args[0] !== 'string') {
    				// Anything else let's inspect with %O
    				args.unshift('%O');
    			}

    			// Apply any `formatters` transformations
    			let index = 0;
    			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
    				// If we encounter an escaped % then don't increase the array index
    				if (match === '%%') {
    					return match;
    				}
    				index++;
    				const formatter = createDebug.formatters[format];
    				if (typeof formatter === 'function') {
    					const val = args[index];
    					match = formatter.call(self, val);

    					// Now we need to remove `args[index]` since it's inlined in the `format`
    					args.splice(index, 1);
    					index--;
    				}
    				return match;
    			});

    			// Apply env-specific formatting (colors, etc.)
    			createDebug.formatArgs.call(self, args);

    			const logFn = self.log || createDebug.log;
    			logFn.apply(self, args);
    		}

    		debug.namespace = namespace;
    		debug.enabled = createDebug.enabled(namespace);
    		debug.useColors = createDebug.useColors();
    		debug.color = selectColor(namespace);
    		debug.destroy = destroy;
    		debug.extend = extend;
    		// Debug.formatArgs = formatArgs;
    		// debug.rawLog = rawLog;

    		// env-specific initialization logic for debug instances
    		if (typeof createDebug.init === 'function') {
    			createDebug.init(debug);
    		}

    		createDebug.instances.push(debug);

    		return debug;
    	}

    	function destroy() {
    		const index = createDebug.instances.indexOf(this);
    		if (index !== -1) {
    			createDebug.instances.splice(index, 1);
    			return true;
    		}
    		return false;
    	}

    	function extend(namespace, delimiter) {
    		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    		newDebug.log = this.log;
    		return newDebug;
    	}

    	/**
    	* Enables a debug mode by namespaces. This can include modes
    	* separated by a colon and wildcards.
    	*
    	* @param {String} namespaces
    	* @api public
    	*/
    	function enable(namespaces) {
    		createDebug.save(namespaces);

    		createDebug.names = [];
    		createDebug.skips = [];

    		let i;
    		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    		const len = split.length;

    		for (i = 0; i < len; i++) {
    			if (!split[i]) {
    				// ignore empty strings
    				continue;
    			}

    			namespaces = split[i].replace(/\*/g, '.*?');

    			if (namespaces[0] === '-') {
    				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    			} else {
    				createDebug.names.push(new RegExp('^' + namespaces + '$'));
    			}
    		}

    		for (i = 0; i < createDebug.instances.length; i++) {
    			const instance = createDebug.instances[i];
    			instance.enabled = createDebug.enabled(instance.namespace);
    		}
    	}

    	/**
    	* Disable debug output.
    	*
    	* @return {String} namespaces
    	* @api public
    	*/
    	function disable() {
    		const namespaces = [
    			...createDebug.names.map(toNamespace),
    			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
    		].join(',');
    		createDebug.enable('');
    		return namespaces;
    	}

    	/**
    	* Returns true if the given mode name is enabled, false otherwise.
    	*
    	* @param {String} name
    	* @return {Boolean}
    	* @api public
    	*/
    	function enabled(name) {
    		if (name[name.length - 1] === '*') {
    			return true;
    		}

    		let i;
    		let len;

    		for (i = 0, len = createDebug.skips.length; i < len; i++) {
    			if (createDebug.skips[i].test(name)) {
    				return false;
    			}
    		}

    		for (i = 0, len = createDebug.names.length; i < len; i++) {
    			if (createDebug.names[i].test(name)) {
    				return true;
    			}
    		}

    		return false;
    	}

    	/**
    	* Convert regexp to namespace
    	*
    	* @param {RegExp} regxep
    	* @return {String} namespace
    	* @api private
    	*/
    	function toNamespace(regexp) {
    		return regexp.toString()
    			.substring(2, regexp.toString().length - 2)
    			.replace(/\.\*\?$/, '*');
    	}

    	/**
    	* Coerce `val`.
    	*
    	* @param {Mixed} val
    	* @return {Mixed}
    	* @api private
    	*/
    	function coerce(val) {
    		if (val instanceof Error) {
    			return val.stack || val.message;
    		}
    		return val;
    	}

    	createDebug.enable(createDebug.load());

    	return createDebug;
    }

    var common$1 = setup$1;

    var browser$3 = createCommonjsModule(function (module, exports) {
    /* eslint-env browser */

    /**
     * This is the web browser implementation of `debug()`.
     */

    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();

    /**
     * Colors.
     */

    exports.colors = [
    	'#0000CC',
    	'#0000FF',
    	'#0033CC',
    	'#0033FF',
    	'#0066CC',
    	'#0066FF',
    	'#0099CC',
    	'#0099FF',
    	'#00CC00',
    	'#00CC33',
    	'#00CC66',
    	'#00CC99',
    	'#00CCCC',
    	'#00CCFF',
    	'#3300CC',
    	'#3300FF',
    	'#3333CC',
    	'#3333FF',
    	'#3366CC',
    	'#3366FF',
    	'#3399CC',
    	'#3399FF',
    	'#33CC00',
    	'#33CC33',
    	'#33CC66',
    	'#33CC99',
    	'#33CCCC',
    	'#33CCFF',
    	'#6600CC',
    	'#6600FF',
    	'#6633CC',
    	'#6633FF',
    	'#66CC00',
    	'#66CC33',
    	'#9900CC',
    	'#9900FF',
    	'#9933CC',
    	'#9933FF',
    	'#99CC00',
    	'#99CC33',
    	'#CC0000',
    	'#CC0033',
    	'#CC0066',
    	'#CC0099',
    	'#CC00CC',
    	'#CC00FF',
    	'#CC3300',
    	'#CC3333',
    	'#CC3366',
    	'#CC3399',
    	'#CC33CC',
    	'#CC33FF',
    	'#CC6600',
    	'#CC6633',
    	'#CC9900',
    	'#CC9933',
    	'#CCCC00',
    	'#CCCC33',
    	'#FF0000',
    	'#FF0033',
    	'#FF0066',
    	'#FF0099',
    	'#FF00CC',
    	'#FF00FF',
    	'#FF3300',
    	'#FF3333',
    	'#FF3366',
    	'#FF3399',
    	'#FF33CC',
    	'#FF33FF',
    	'#FF6600',
    	'#FF6633',
    	'#FF9900',
    	'#FF9933',
    	'#FFCC00',
    	'#FFCC33'
    ];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    // eslint-disable-next-line complexity
    function useColors() {
    	// NB: In an Electron preload script, document will be defined but not fully
    	// initialized. Since we know we're in Chrome, we'll just detect this case
    	// explicitly
    	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    		return true;
    	}

    	// Internet Explorer and Edge do not support colors.
    	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    		return false;
    	}

    	// Is webkit? http://stackoverflow.com/a/16459606/376773
    	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    		// Is firebug? http://stackoverflow.com/a/398120/376773
    		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    		// Is firefox >= v31?
    		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    		// Double check webkit in userAgent just in case we are in a worker
    		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
    }

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
    	args[0] = (this.useColors ? '%c' : '') +
    		this.namespace +
    		(this.useColors ? ' %c' : ' ') +
    		args[0] +
    		(this.useColors ? '%c ' : ' ') +
    		'+' + module.exports.humanize(this.diff);

    	if (!this.useColors) {
    		return;
    	}

    	const c = 'color: ' + this.color;
    	args.splice(1, 0, c, 'color: inherit');

    	// The final "%c" is somewhat tricky, because there could be other
    	// arguments passed either before or after the %c, so we need to
    	// figure out the correct index to insert the CSS into
    	let index = 0;
    	let lastC = 0;
    	args[0].replace(/%[a-zA-Z%]/g, match => {
    		if (match === '%%') {
    			return;
    		}
    		index++;
    		if (match === '%c') {
    			// We only are interested in the *last* %c
    			// (the user may have provided their own)
    			lastC = index;
    		}
    	});

    	args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */
    function log(...args) {
    	// This hackery is required for IE8/9, where
    	// the `console.log` function doesn't have 'apply'
    	return typeof console === 'object' &&
    		console.log &&
    		console.log(...args);
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
    	try {
    		if (namespaces) {
    			exports.storage.setItem('debug', namespaces);
    		} else {
    			exports.storage.removeItem('debug');
    		}
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    function load() {
    	let r;
    	try {
    		r = exports.storage.getItem('debug');
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}

    	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    	if (!r && typeof process !== 'undefined' && 'env' in process) {
    		r = process.env.DEBUG;
    	}

    	return r;
    }

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
    	try {
    		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    		// The Browser also has localStorage in the global context.
    		return localStorage;
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}
    }

    module.exports = common$1(exports);

    const {formatters} = module.exports;

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
    	try {
    		return JSON.stringify(v);
    	} catch (error) {
    		return '[UnexpectedJSONParseError]: ' + error.message;
    	}
    };
    });
    var browser_1$3 = browser$3.log;
    var browser_2$3 = browser$3.formatArgs;
    var browser_3$3 = browser$3.save;
    var browser_4$3 = browser$3.load;
    var browser_5$3 = browser$3.useColors;
    var browser_6$3 = browser$3.storage;
    var browser_7$3 = browser$3.colors;

    /**
     * Module dependencies.
     */






    var debug$2 = browser$3('engine.io-client:polling');

    /**
     * Module exports.
     */

    var polling = Polling;

    /**
     * Is XHR2 supported?
     */

    var hasXHR2 = (function () {
      var XMLHttpRequest = xmlhttprequest;
      var xhr = new XMLHttpRequest({ xdomain: false });
      return null != xhr.responseType;
    })();

    /**
     * Polling interface.
     *
     * @param {Object} opts
     * @api private
     */

    function Polling (opts) {
      var forceBase64 = (opts && opts.forceBase64);
      if (!hasXHR2 || forceBase64) {
        this.supportsBinary = false;
      }
      transport.call(this, opts);
    }

    /**
     * Inherits from Transport.
     */

    componentInherit(Polling, transport);

    /**
     * Transport name.
     */

    Polling.prototype.name = 'polling';

    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @api private
     */

    Polling.prototype.doOpen = function () {
      this.poll();
    };

    /**
     * Pauses polling.
     *
     * @param {Function} callback upon buffers are flushed and transport is paused
     * @api private
     */

    Polling.prototype.pause = function (onPause) {
      var self = this;

      this.readyState = 'pausing';

      function pause () {
        debug$2('paused');
        self.readyState = 'paused';
        onPause();
      }

      if (this.polling || !this.writable) {
        var total = 0;

        if (this.polling) {
          debug$2('we are currently polling - waiting to pause');
          total++;
          this.once('pollComplete', function () {
            debug$2('pre-pause polling complete');
            --total || pause();
          });
        }

        if (!this.writable) {
          debug$2('we are currently writing - waiting to pause');
          total++;
          this.once('drain', function () {
            debug$2('pre-pause writing complete');
            --total || pause();
          });
        }
      } else {
        pause();
      }
    };

    /**
     * Starts polling cycle.
     *
     * @api public
     */

    Polling.prototype.poll = function () {
      debug$2('polling');
      this.polling = true;
      this.doPoll();
      this.emit('poll');
    };

    /**
     * Overloads onData to detect payloads.
     *
     * @api private
     */

    Polling.prototype.onData = function (data) {
      var self = this;
      debug$2('polling got data %s', data);
      var callback = function (packet, index, total) {
        // if its the first message we consider the transport open
        if ('opening' === self.readyState) {
          self.onOpen();
        }

        // if its a close packet, we close the ongoing requests
        if ('close' === packet.type) {
          self.onClose();
          return false;
        }

        // otherwise bypass onData and handle the message
        self.onPacket(packet);
      };

      // decode payload
      browser$2.decodePayload(data, this.socket.binaryType, callback);

      // if an event did not trigger closing
      if ('closed' !== this.readyState) {
        // if we got data we're not polling
        this.polling = false;
        this.emit('pollComplete');

        if ('open' === this.readyState) {
          this.poll();
        } else {
          debug$2('ignoring poll - transport state "%s"', this.readyState);
        }
      }
    };

    /**
     * For polling, send a close packet.
     *
     * @api private
     */

    Polling.prototype.doClose = function () {
      var self = this;

      function close () {
        debug$2('writing close packet');
        self.write([{ type: 'close' }]);
      }

      if ('open' === this.readyState) {
        debug$2('transport open - closing');
        close();
      } else {
        // in case we're trying to close while
        // handshaking is in progress (GH-164)
        debug$2('transport not open - deferring close');
        this.once('open', close);
      }
    };

    /**
     * Writes a packets payload.
     *
     * @param {Array} data packets
     * @param {Function} drain callback
     * @api private
     */

    Polling.prototype.write = function (packets) {
      var self = this;
      this.writable = false;
      var callbackfn = function () {
        self.writable = true;
        self.emit('drain');
      };

      browser$2.encodePayload(packets, this.supportsBinary, function (data) {
        self.doWrite(data, callbackfn);
      });
    };

    /**
     * Generates uri for connection.
     *
     * @api private
     */

    Polling.prototype.uri = function () {
      var query = this.query || {};
      var schema = this.secure ? 'https' : 'http';
      var port = '';

      // cache busting is forced
      if (false !== this.timestampRequests) {
        query[this.timestampParam] = yeast_1();
      }

      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }

      query = parseqs.encode(query);

      // avoid port if default for schema
      if (this.port && (('https' === schema && Number(this.port) !== 443) ||
         ('http' === schema && Number(this.port) !== 80))) {
        port = ':' + this.port;
      }

      // prepend ? to query
      if (query.length) {
        query = '?' + query;
      }

      var ipv6 = this.hostname.indexOf(':') !== -1;
      return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
    };

    /* global attachEvent */

    /**
     * Module requirements.
     */





    var debug$3 = browser$3('engine.io-client:polling-xhr');

    /**
     * Module exports.
     */

    var pollingXhr = XHR;
    var Request_1 = Request;

    /**
     * Empty function
     */

    function empty$1 () {}

    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @api public
     */

    function XHR (opts) {
      polling.call(this, opts);
      this.requestTimeout = opts.requestTimeout;
      this.extraHeaders = opts.extraHeaders;

      if (typeof location !== 'undefined') {
        var isSSL = 'https:' === location.protocol;
        var port = location.port;

        // some user agents have empty `location.port`
        if (!port) {
          port = isSSL ? 443 : 80;
        }

        this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||
          port !== opts.port;
        this.xs = opts.secure !== isSSL;
      }
    }

    /**
     * Inherits from Polling.
     */

    componentInherit(XHR, polling);

    /**
     * XHR supports binary
     */

    XHR.prototype.supportsBinary = true;

    /**
     * Creates a request.
     *
     * @param {String} method
     * @api private
     */

    XHR.prototype.request = function (opts) {
      opts = opts || {};
      opts.uri = this.uri();
      opts.xd = this.xd;
      opts.xs = this.xs;
      opts.agent = this.agent || false;
      opts.supportsBinary = this.supportsBinary;
      opts.enablesXDR = this.enablesXDR;
      opts.withCredentials = this.withCredentials;

      // SSL options for Node.js client
      opts.pfx = this.pfx;
      opts.key = this.key;
      opts.passphrase = this.passphrase;
      opts.cert = this.cert;
      opts.ca = this.ca;
      opts.ciphers = this.ciphers;
      opts.rejectUnauthorized = this.rejectUnauthorized;
      opts.requestTimeout = this.requestTimeout;

      // other options for Node.js client
      opts.extraHeaders = this.extraHeaders;

      return new Request(opts);
    };

    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @api private
     */

    XHR.prototype.doWrite = function (data, fn) {
      var isBinary = typeof data !== 'string' && data !== undefined;
      var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
      var self = this;
      req.on('success', fn);
      req.on('error', function (err) {
        self.onError('xhr post error', err);
      });
      this.sendXhr = req;
    };

    /**
     * Starts a poll cycle.
     *
     * @api private
     */

    XHR.prototype.doPoll = function () {
      debug$3('xhr poll');
      var req = this.request();
      var self = this;
      req.on('data', function (data) {
        self.onData(data);
      });
      req.on('error', function (err) {
        self.onError('xhr poll error', err);
      });
      this.pollXhr = req;
    };

    /**
     * Request constructor
     *
     * @param {Object} options
     * @api public
     */

    function Request (opts) {
      this.method = opts.method || 'GET';
      this.uri = opts.uri;
      this.xd = !!opts.xd;
      this.xs = !!opts.xs;
      this.async = false !== opts.async;
      this.data = undefined !== opts.data ? opts.data : null;
      this.agent = opts.agent;
      this.isBinary = opts.isBinary;
      this.supportsBinary = opts.supportsBinary;
      this.enablesXDR = opts.enablesXDR;
      this.withCredentials = opts.withCredentials;
      this.requestTimeout = opts.requestTimeout;

      // SSL options for Node.js client
      this.pfx = opts.pfx;
      this.key = opts.key;
      this.passphrase = opts.passphrase;
      this.cert = opts.cert;
      this.ca = opts.ca;
      this.ciphers = opts.ciphers;
      this.rejectUnauthorized = opts.rejectUnauthorized;

      // other options for Node.js client
      this.extraHeaders = opts.extraHeaders;

      this.create();
    }

    /**
     * Mix in `Emitter`.
     */

    componentEmitter$1(Request.prototype);

    /**
     * Creates the XHR object and sends the request.
     *
     * @api private
     */

    Request.prototype.create = function () {
      var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

      // SSL options for Node.js client
      opts.pfx = this.pfx;
      opts.key = this.key;
      opts.passphrase = this.passphrase;
      opts.cert = this.cert;
      opts.ca = this.ca;
      opts.ciphers = this.ciphers;
      opts.rejectUnauthorized = this.rejectUnauthorized;

      var xhr = this.xhr = new xmlhttprequest(opts);
      var self = this;

      try {
        debug$3('xhr open %s: %s', this.method, this.uri);
        xhr.open(this.method, this.uri, this.async);
        try {
          if (this.extraHeaders) {
            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
            for (var i in this.extraHeaders) {
              if (this.extraHeaders.hasOwnProperty(i)) {
                xhr.setRequestHeader(i, this.extraHeaders[i]);
              }
            }
          }
        } catch (e) {}

        if ('POST' === this.method) {
          try {
            if (this.isBinary) {
              xhr.setRequestHeader('Content-type', 'application/octet-stream');
            } else {
              xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
            }
          } catch (e) {}
        }

        try {
          xhr.setRequestHeader('Accept', '*/*');
        } catch (e) {}

        // ie6 check
        if ('withCredentials' in xhr) {
          xhr.withCredentials = this.withCredentials;
        }

        if (this.requestTimeout) {
          xhr.timeout = this.requestTimeout;
        }

        if (this.hasXDR()) {
          xhr.onload = function () {
            self.onLoad();
          };
          xhr.onerror = function () {
            self.onError(xhr.responseText);
          };
        } else {
          xhr.onreadystatechange = function () {
            if (xhr.readyState === 2) {
              try {
                var contentType = xhr.getResponseHeader('Content-Type');
                if (self.supportsBinary && contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
                  xhr.responseType = 'arraybuffer';
                }
              } catch (e) {}
            }
            if (4 !== xhr.readyState) return;
            if (200 === xhr.status || 1223 === xhr.status) {
              self.onLoad();
            } else {
              // make sure the `error` event handler that's user-set
              // does not throw in the same tick and gets caught here
              setTimeout(function () {
                self.onError(typeof xhr.status === 'number' ? xhr.status : 0);
              }, 0);
            }
          };
        }

        debug$3('xhr data %s', this.data);
        xhr.send(this.data);
      } catch (e) {
        // Need to defer since .create() is called directly fhrom the constructor
        // and thus the 'error' event can only be only bound *after* this exception
        // occurs.  Therefore, also, we cannot throw here at all.
        setTimeout(function () {
          self.onError(e);
        }, 0);
        return;
      }

      if (typeof document !== 'undefined') {
        this.index = Request.requestsCount++;
        Request.requests[this.index] = this;
      }
    };

    /**
     * Called upon successful response.
     *
     * @api private
     */

    Request.prototype.onSuccess = function () {
      this.emit('success');
      this.cleanup();
    };

    /**
     * Called if we have data.
     *
     * @api private
     */

    Request.prototype.onData = function (data) {
      this.emit('data', data);
      this.onSuccess();
    };

    /**
     * Called upon error.
     *
     * @api private
     */

    Request.prototype.onError = function (err) {
      this.emit('error', err);
      this.cleanup(true);
    };

    /**
     * Cleans up house.
     *
     * @api private
     */

    Request.prototype.cleanup = function (fromError) {
      if ('undefined' === typeof this.xhr || null === this.xhr) {
        return;
      }
      // xmlhttprequest
      if (this.hasXDR()) {
        this.xhr.onload = this.xhr.onerror = empty$1;
      } else {
        this.xhr.onreadystatechange = empty$1;
      }

      if (fromError) {
        try {
          this.xhr.abort();
        } catch (e) {}
      }

      if (typeof document !== 'undefined') {
        delete Request.requests[this.index];
      }

      this.xhr = null;
    };

    /**
     * Called upon load.
     *
     * @api private
     */

    Request.prototype.onLoad = function () {
      var data;
      try {
        var contentType;
        try {
          contentType = this.xhr.getResponseHeader('Content-Type');
        } catch (e) {}
        if (contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
          data = this.xhr.response || this.xhr.responseText;
        } else {
          data = this.xhr.responseText;
        }
      } catch (e) {
        this.onError(e);
      }
      if (null != data) {
        this.onData(data);
      }
    };

    /**
     * Check if it has XDomainRequest.
     *
     * @api private
     */

    Request.prototype.hasXDR = function () {
      return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
    };

    /**
     * Aborts the request.
     *
     * @api public
     */

    Request.prototype.abort = function () {
      this.cleanup();
    };

    /**
     * Aborts pending requests when unloading the window. This is needed to prevent
     * memory leaks (e.g. when using IE) and to ensure that no spurious error is
     * emitted.
     */

    Request.requestsCount = 0;
    Request.requests = {};

    if (typeof document !== 'undefined') {
      if (typeof attachEvent === 'function') {
        attachEvent('onunload', unloadHandler);
      } else if (typeof addEventListener === 'function') {
        var terminationEvent = 'onpagehide' in self ? 'pagehide' : 'unload';
        addEventListener(terminationEvent, unloadHandler, false);
      }
    }

    function unloadHandler () {
      for (var i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
          Request.requests[i].abort();
        }
      }
    }
    pollingXhr.Request = Request_1;

    /**
     * Module requirements.
     */




    /**
     * Module exports.
     */

    var pollingJsonp = JSONPPolling;

    /**
     * Cached regular expressions.
     */

    var rNewline = /\n/g;
    var rEscapedNewline = /\\n/g;

    /**
     * Global JSONP callbacks.
     */

    var callbacks;

    /**
     * Noop.
     */

    function empty$2 () { }

    /**
     * Until https://github.com/tc39/proposal-global is shipped.
     */
    function glob () {
      return typeof self !== 'undefined' ? self
          : typeof window !== 'undefined' ? window
          : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : {};
    }

    /**
     * JSONP Polling constructor.
     *
     * @param {Object} opts.
     * @api public
     */

    function JSONPPolling (opts) {
      polling.call(this, opts);

      this.query = this.query || {};

      // define global callbacks array if not present
      // we do this here (lazily) to avoid unneeded global pollution
      if (!callbacks) {
        // we need to consider multiple engines in the same page
        var global = glob();
        callbacks = global.___eio = (global.___eio || []);
      }

      // callback identifier
      this.index = callbacks.length;

      // add callback to jsonp global
      var self = this;
      callbacks.push(function (msg) {
        self.onData(msg);
      });

      // append to query string
      this.query.j = this.index;

      // prevent spurious errors from being emitted when the window is unloaded
      if (typeof addEventListener === 'function') {
        addEventListener('beforeunload', function () {
          if (self.script) self.script.onerror = empty$2;
        }, false);
      }
    }

    /**
     * Inherits from Polling.
     */

    componentInherit(JSONPPolling, polling);

    /*
     * JSONP only supports binary as base64 encoded strings
     */

    JSONPPolling.prototype.supportsBinary = false;

    /**
     * Closes the socket.
     *
     * @api private
     */

    JSONPPolling.prototype.doClose = function () {
      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }

      if (this.form) {
        this.form.parentNode.removeChild(this.form);
        this.form = null;
        this.iframe = null;
      }

      polling.prototype.doClose.call(this);
    };

    /**
     * Starts a poll cycle.
     *
     * @api private
     */

    JSONPPolling.prototype.doPoll = function () {
      var self = this;
      var script = document.createElement('script');

      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }

      script.async = true;
      script.src = this.uri();
      script.onerror = function (e) {
        self.onError('jsonp poll error', e);
      };

      var insertAt = document.getElementsByTagName('script')[0];
      if (insertAt) {
        insertAt.parentNode.insertBefore(script, insertAt);
      } else {
        (document.head || document.body).appendChild(script);
      }
      this.script = script;

      var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

      if (isUAgecko) {
        setTimeout(function () {
          var iframe = document.createElement('iframe');
          document.body.appendChild(iframe);
          document.body.removeChild(iframe);
        }, 100);
      }
    };

    /**
     * Writes with a hidden iframe.
     *
     * @param {String} data to send
     * @param {Function} called upon flush.
     * @api private
     */

    JSONPPolling.prototype.doWrite = function (data, fn) {
      var self = this;

      if (!this.form) {
        var form = document.createElement('form');
        var area = document.createElement('textarea');
        var id = this.iframeId = 'eio_iframe_' + this.index;
        var iframe;

        form.className = 'socketio';
        form.style.position = 'absolute';
        form.style.top = '-1000px';
        form.style.left = '-1000px';
        form.target = id;
        form.method = 'POST';
        form.setAttribute('accept-charset', 'utf-8');
        area.name = 'd';
        form.appendChild(area);
        document.body.appendChild(form);

        this.form = form;
        this.area = area;
      }

      this.form.action = this.uri();

      function complete () {
        initIframe();
        fn();
      }

      function initIframe () {
        if (self.iframe) {
          try {
            self.form.removeChild(self.iframe);
          } catch (e) {
            self.onError('jsonp polling iframe removal error', e);
          }
        }

        try {
          // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
          var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
          iframe = document.createElement(html);
        } catch (e) {
          iframe = document.createElement('iframe');
          iframe.name = self.iframeId;
          iframe.src = 'javascript:0';
        }

        iframe.id = self.iframeId;

        self.form.appendChild(iframe);
        self.iframe = iframe;
      }

      initIframe();

      // escape \n to prevent it from being converted into \r\n by some UAs
      // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
      data = data.replace(rEscapedNewline, '\\\n');
      this.area.value = data.replace(rNewline, '\\n');

      try {
        this.form.submit();
      } catch (e) {}

      if (this.iframe.attachEvent) {
        this.iframe.onreadystatechange = function () {
          if (self.iframe.readyState === 'complete') {
            complete();
          }
        };
      } else {
        this.iframe.onload = complete;
      }
    };

    var _nodeResolve_empty = {};

    var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _nodeResolve_empty
    });

    var require$$1 = getCjsExportFromNamespace(_nodeResolve_empty$1);

    /**
     * Module dependencies.
     */






    var debug$4 = browser$3('engine.io-client:websocket');

    var BrowserWebSocket, NodeWebSocket;

    if (typeof WebSocket !== 'undefined') {
      BrowserWebSocket = WebSocket;
    } else if (typeof self !== 'undefined') {
      BrowserWebSocket = self.WebSocket || self.MozWebSocket;
    }

    if (typeof window === 'undefined') {
      try {
        NodeWebSocket = require$$1;
      } catch (e) { }
    }

    /**
     * Get either the `WebSocket` or `MozWebSocket` globals
     * in the browser or try to resolve WebSocket-compatible
     * interface exposed by `ws` for Node-like environment.
     */

    var WebSocketImpl = BrowserWebSocket || NodeWebSocket;

    /**
     * Module exports.
     */

    var websocket = WS;

    /**
     * WebSocket transport constructor.
     *
     * @api {Object} connection options
     * @api public
     */

    function WS (opts) {
      var forceBase64 = (opts && opts.forceBase64);
      if (forceBase64) {
        this.supportsBinary = false;
      }
      this.perMessageDeflate = opts.perMessageDeflate;
      this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
      this.protocols = opts.protocols;
      if (!this.usingBrowserWebSocket) {
        WebSocketImpl = NodeWebSocket;
      }
      transport.call(this, opts);
    }

    /**
     * Inherits from Transport.
     */

    componentInherit(WS, transport);

    /**
     * Transport name.
     *
     * @api public
     */

    WS.prototype.name = 'websocket';

    /*
     * WebSockets support binary
     */

    WS.prototype.supportsBinary = true;

    /**
     * Opens socket.
     *
     * @api private
     */

    WS.prototype.doOpen = function () {
      if (!this.check()) {
        // let probe timeout
        return;
      }

      var uri = this.uri();
      var protocols = this.protocols;
      var opts = {
        agent: this.agent,
        perMessageDeflate: this.perMessageDeflate
      };

      // SSL options for Node.js client
      opts.pfx = this.pfx;
      opts.key = this.key;
      opts.passphrase = this.passphrase;
      opts.cert = this.cert;
      opts.ca = this.ca;
      opts.ciphers = this.ciphers;
      opts.rejectUnauthorized = this.rejectUnauthorized;
      if (this.extraHeaders) {
        opts.headers = this.extraHeaders;
      }
      if (this.localAddress) {
        opts.localAddress = this.localAddress;
      }

      try {
        this.ws =
          this.usingBrowserWebSocket && !this.isReactNative
            ? protocols
              ? new WebSocketImpl(uri, protocols)
              : new WebSocketImpl(uri)
            : new WebSocketImpl(uri, protocols, opts);
      } catch (err) {
        return this.emit('error', err);
      }

      if (this.ws.binaryType === undefined) {
        this.supportsBinary = false;
      }

      if (this.ws.supports && this.ws.supports.binary) {
        this.supportsBinary = true;
        this.ws.binaryType = 'nodebuffer';
      } else {
        this.ws.binaryType = 'arraybuffer';
      }

      this.addEventListeners();
    };

    /**
     * Adds event listeners to the socket
     *
     * @api private
     */

    WS.prototype.addEventListeners = function () {
      var self = this;

      this.ws.onopen = function () {
        self.onOpen();
      };
      this.ws.onclose = function () {
        self.onClose();
      };
      this.ws.onmessage = function (ev) {
        self.onData(ev.data);
      };
      this.ws.onerror = function (e) {
        self.onError('websocket error', e);
      };
    };

    /**
     * Writes data to socket.
     *
     * @param {Array} array of packets.
     * @api private
     */

    WS.prototype.write = function (packets) {
      var self = this;
      this.writable = false;

      // encodePacket efficient as it uses WS framing
      // no need for encodePayload
      var total = packets.length;
      for (var i = 0, l = total; i < l; i++) {
        (function (packet) {
          browser$2.encodePacket(packet, self.supportsBinary, function (data) {
            if (!self.usingBrowserWebSocket) {
              // always create a new object (GH-437)
              var opts = {};
              if (packet.options) {
                opts.compress = packet.options.compress;
              }

              if (self.perMessageDeflate) {
                var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
                if (len < self.perMessageDeflate.threshold) {
                  opts.compress = false;
                }
              }
            }

            // Sometimes the websocket has already been closed but the browser didn't
            // have a chance of informing us about it yet, in that case send will
            // throw an error
            try {
              if (self.usingBrowserWebSocket) {
                // TypeError is thrown when passing the second argument on Safari
                self.ws.send(data);
              } else {
                self.ws.send(data, opts);
              }
            } catch (e) {
              debug$4('websocket closed before onclose event');
            }

            --total || done();
          });
        })(packets[i]);
      }

      function done () {
        self.emit('flush');

        // fake drain
        // defer to next tick to allow Socket to clear writeBuffer
        setTimeout(function () {
          self.writable = true;
          self.emit('drain');
        }, 0);
      }
    };

    /**
     * Called upon close
     *
     * @api private
     */

    WS.prototype.onClose = function () {
      transport.prototype.onClose.call(this);
    };

    /**
     * Closes socket.
     *
     * @api private
     */

    WS.prototype.doClose = function () {
      if (typeof this.ws !== 'undefined') {
        this.ws.close();
      }
    };

    /**
     * Generates uri for connection.
     *
     * @api private
     */

    WS.prototype.uri = function () {
      var query = this.query || {};
      var schema = this.secure ? 'wss' : 'ws';
      var port = '';

      // avoid port if default for schema
      if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
        ('ws' === schema && Number(this.port) !== 80))) {
        port = ':' + this.port;
      }

      // append timestamp to URI
      if (this.timestampRequests) {
        query[this.timestampParam] = yeast_1();
      }

      // communicate binary support capabilities
      if (!this.supportsBinary) {
        query.b64 = 1;
      }

      query = parseqs.encode(query);

      // prepend ? to query
      if (query.length) {
        query = '?' + query;
      }

      var ipv6 = this.hostname.indexOf(':') !== -1;
      return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
    };

    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @api public
     */

    WS.prototype.check = function () {
      return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
    };

    /**
     * Module dependencies
     */






    /**
     * Export transports.
     */

    var polling_1 = polling$1;
    var websocket_1 = websocket;

    /**
     * Polling transport polymorphic constructor.
     * Decides on xhr vs jsonp based on feature detection.
     *
     * @api private
     */

    function polling$1 (opts) {
      var xhr;
      var xd = false;
      var xs = false;
      var jsonp = false !== opts.jsonp;

      if (typeof location !== 'undefined') {
        var isSSL = 'https:' === location.protocol;
        var port = location.port;

        // some user agents have empty `location.port`
        if (!port) {
          port = isSSL ? 443 : 80;
        }

        xd = opts.hostname !== location.hostname || port !== opts.port;
        xs = opts.secure !== isSSL;
      }

      opts.xdomain = xd;
      opts.xscheme = xs;
      xhr = new xmlhttprequest(opts);

      if ('open' in xhr && !opts.forceJSONP) {
        return new pollingXhr(opts);
      } else {
        if (!jsonp) throw new Error('JSONP disabled');
        return new pollingJsonp(opts);
      }
    }

    var transports = {
    	polling: polling_1,
    	websocket: websocket_1
    };

    var indexOf = [].indexOf;

    var indexof = function(arr, obj){
      if (indexOf) return arr.indexOf(obj);
      for (var i = 0; i < arr.length; ++i) {
        if (arr[i] === obj) return i;
      }
      return -1;
    };

    /**
     * Module dependencies.
     */



    var debug$5 = browser$3('engine.io-client:socket');





    /**
     * Module exports.
     */

    var socket = Socket;

    /**
     * Socket constructor.
     *
     * @param {String|Object} uri or options
     * @param {Object} options
     * @api public
     */

    function Socket (uri, opts) {
      if (!(this instanceof Socket)) return new Socket(uri, opts);

      opts = opts || {};

      if (uri && 'object' === typeof uri) {
        opts = uri;
        uri = null;
      }

      if (uri) {
        uri = parseuri(uri);
        opts.hostname = uri.host;
        opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
        opts.port = uri.port;
        if (uri.query) opts.query = uri.query;
      } else if (opts.host) {
        opts.hostname = parseuri(opts.host).host;
      }

      this.secure = null != opts.secure ? opts.secure
        : (typeof location !== 'undefined' && 'https:' === location.protocol);

      if (opts.hostname && !opts.port) {
        // if no port is specified manually, use the protocol default
        opts.port = this.secure ? '443' : '80';
      }

      this.agent = opts.agent || false;
      this.hostname = opts.hostname ||
        (typeof location !== 'undefined' ? location.hostname : 'localhost');
      this.port = opts.port || (typeof location !== 'undefined' && location.port
          ? location.port
          : (this.secure ? 443 : 80));
      this.query = opts.query || {};
      if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
      this.upgrade = false !== opts.upgrade;
      this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
      this.forceJSONP = !!opts.forceJSONP;
      this.jsonp = false !== opts.jsonp;
      this.forceBase64 = !!opts.forceBase64;
      this.enablesXDR = !!opts.enablesXDR;
      this.withCredentials = false !== opts.withCredentials;
      this.timestampParam = opts.timestampParam || 't';
      this.timestampRequests = opts.timestampRequests;
      this.transports = opts.transports || ['polling', 'websocket'];
      this.transportOptions = opts.transportOptions || {};
      this.readyState = '';
      this.writeBuffer = [];
      this.prevBufferLen = 0;
      this.policyPort = opts.policyPort || 843;
      this.rememberUpgrade = opts.rememberUpgrade || false;
      this.binaryType = null;
      this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
      this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

      if (true === this.perMessageDeflate) this.perMessageDeflate = {};
      if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
        this.perMessageDeflate.threshold = 1024;
      }

      // SSL options for Node.js client
      this.pfx = opts.pfx || null;
      this.key = opts.key || null;
      this.passphrase = opts.passphrase || null;
      this.cert = opts.cert || null;
      this.ca = opts.ca || null;
      this.ciphers = opts.ciphers || null;
      this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
      this.forceNode = !!opts.forceNode;

      // detect ReactNative environment
      this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');

      // other options for Node.js or ReactNative client
      if (typeof self === 'undefined' || this.isReactNative) {
        if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
          this.extraHeaders = opts.extraHeaders;
        }

        if (opts.localAddress) {
          this.localAddress = opts.localAddress;
        }
      }

      // set on handshake
      this.id = null;
      this.upgrades = null;
      this.pingInterval = null;
      this.pingTimeout = null;

      // set on heartbeat
      this.pingIntervalTimer = null;
      this.pingTimeoutTimer = null;

      this.open();
    }

    Socket.priorWebsocketSuccess = false;

    /**
     * Mix in `Emitter`.
     */

    componentEmitter$1(Socket.prototype);

    /**
     * Protocol version.
     *
     * @api public
     */

    Socket.protocol = browser$2.protocol; // this is an int

    /**
     * Expose deps for legacy compatibility
     * and standalone browser access.
     */

    Socket.Socket = Socket;
    Socket.Transport = transport;
    Socket.transports = transports;
    Socket.parser = browser$2;

    /**
     * Creates transport of the given type.
     *
     * @param {String} transport name
     * @return {Transport}
     * @api private
     */

    Socket.prototype.createTransport = function (name) {
      debug$5('creating transport "%s"', name);
      var query = clone(this.query);

      // append engine.io protocol identifier
      query.EIO = browser$2.protocol;

      // transport name
      query.transport = name;

      // per-transport options
      var options = this.transportOptions[name] || {};

      // session id if we already have one
      if (this.id) query.sid = this.id;

      var transport = new transports[name]({
        query: query,
        socket: this,
        agent: options.agent || this.agent,
        hostname: options.hostname || this.hostname,
        port: options.port || this.port,
        secure: options.secure || this.secure,
        path: options.path || this.path,
        forceJSONP: options.forceJSONP || this.forceJSONP,
        jsonp: options.jsonp || this.jsonp,
        forceBase64: options.forceBase64 || this.forceBase64,
        enablesXDR: options.enablesXDR || this.enablesXDR,
        withCredentials: options.withCredentials || this.withCredentials,
        timestampRequests: options.timestampRequests || this.timestampRequests,
        timestampParam: options.timestampParam || this.timestampParam,
        policyPort: options.policyPort || this.policyPort,
        pfx: options.pfx || this.pfx,
        key: options.key || this.key,
        passphrase: options.passphrase || this.passphrase,
        cert: options.cert || this.cert,
        ca: options.ca || this.ca,
        ciphers: options.ciphers || this.ciphers,
        rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
        perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
        extraHeaders: options.extraHeaders || this.extraHeaders,
        forceNode: options.forceNode || this.forceNode,
        localAddress: options.localAddress || this.localAddress,
        requestTimeout: options.requestTimeout || this.requestTimeout,
        protocols: options.protocols || void (0),
        isReactNative: this.isReactNative
      });

      return transport;
    };

    function clone (obj) {
      var o = {};
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          o[i] = obj[i];
        }
      }
      return o;
    }

    /**
     * Initializes transport to use and starts probe.
     *
     * @api private
     */
    Socket.prototype.open = function () {
      var transport;
      if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
        transport = 'websocket';
      } else if (0 === this.transports.length) {
        // Emit error on next tick so it can be listened to
        var self = this;
        setTimeout(function () {
          self.emit('error', 'No transports available');
        }, 0);
        return;
      } else {
        transport = this.transports[0];
      }
      this.readyState = 'opening';

      // Retry with the next transport if the transport is disabled (jsonp: false)
      try {
        transport = this.createTransport(transport);
      } catch (e) {
        this.transports.shift();
        this.open();
        return;
      }

      transport.open();
      this.setTransport(transport);
    };

    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @api private
     */

    Socket.prototype.setTransport = function (transport) {
      debug$5('setting transport %s', transport.name);
      var self = this;

      if (this.transport) {
        debug$5('clearing existing transport %s', this.transport.name);
        this.transport.removeAllListeners();
      }

      // set up transport
      this.transport = transport;

      // set up transport listeners
      transport
      .on('drain', function () {
        self.onDrain();
      })
      .on('packet', function (packet) {
        self.onPacket(packet);
      })
      .on('error', function (e) {
        self.onError(e);
      })
      .on('close', function () {
        self.onClose('transport close');
      });
    };

    /**
     * Probes a transport.
     *
     * @param {String} transport name
     * @api private
     */

    Socket.prototype.probe = function (name) {
      debug$5('probing transport "%s"', name);
      var transport = this.createTransport(name, { probe: 1 });
      var failed = false;
      var self = this;

      Socket.priorWebsocketSuccess = false;

      function onTransportOpen () {
        if (self.onlyBinaryUpgrades) {
          var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
          failed = failed || upgradeLosesBinary;
        }
        if (failed) return;

        debug$5('probe transport "%s" opened', name);
        transport.send([{ type: 'ping', data: 'probe' }]);
        transport.once('packet', function (msg) {
          if (failed) return;
          if ('pong' === msg.type && 'probe' === msg.data) {
            debug$5('probe transport "%s" pong', name);
            self.upgrading = true;
            self.emit('upgrading', transport);
            if (!transport) return;
            Socket.priorWebsocketSuccess = 'websocket' === transport.name;

            debug$5('pausing current transport "%s"', self.transport.name);
            self.transport.pause(function () {
              if (failed) return;
              if ('closed' === self.readyState) return;
              debug$5('changing transport and sending upgrade packet');

              cleanup();

              self.setTransport(transport);
              transport.send([{ type: 'upgrade' }]);
              self.emit('upgrade', transport);
              transport = null;
              self.upgrading = false;
              self.flush();
            });
          } else {
            debug$5('probe transport "%s" failed', name);
            var err = new Error('probe error');
            err.transport = transport.name;
            self.emit('upgradeError', err);
          }
        });
      }

      function freezeTransport () {
        if (failed) return;

        // Any callback called by transport should be ignored since now
        failed = true;

        cleanup();

        transport.close();
        transport = null;
      }

      // Handle any error that happens while probing
      function onerror (err) {
        var error = new Error('probe error: ' + err);
        error.transport = transport.name;

        freezeTransport();

        debug$5('probe transport "%s" failed because of error: %s', name, err);

        self.emit('upgradeError', error);
      }

      function onTransportClose () {
        onerror('transport closed');
      }

      // When the socket is closed while we're probing
      function onclose () {
        onerror('socket closed');
      }

      // When the socket is upgraded while we're probing
      function onupgrade (to) {
        if (transport && to.name !== transport.name) {
          debug$5('"%s" works - aborting "%s"', to.name, transport.name);
          freezeTransport();
        }
      }

      // Remove all listeners on the transport and on self
      function cleanup () {
        transport.removeListener('open', onTransportOpen);
        transport.removeListener('error', onerror);
        transport.removeListener('close', onTransportClose);
        self.removeListener('close', onclose);
        self.removeListener('upgrading', onupgrade);
      }

      transport.once('open', onTransportOpen);
      transport.once('error', onerror);
      transport.once('close', onTransportClose);

      this.once('close', onclose);
      this.once('upgrading', onupgrade);

      transport.open();
    };

    /**
     * Called when connection is deemed open.
     *
     * @api public
     */

    Socket.prototype.onOpen = function () {
      debug$5('socket open');
      this.readyState = 'open';
      Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
      this.emit('open');
      this.flush();

      // we check for `readyState` in case an `open`
      // listener already closed the socket
      if ('open' === this.readyState && this.upgrade && this.transport.pause) {
        debug$5('starting upgrade probes');
        for (var i = 0, l = this.upgrades.length; i < l; i++) {
          this.probe(this.upgrades[i]);
        }
      }
    };

    /**
     * Handles a packet.
     *
     * @api private
     */

    Socket.prototype.onPacket = function (packet) {
      if ('opening' === this.readyState || 'open' === this.readyState ||
          'closing' === this.readyState) {
        debug$5('socket receive: type "%s", data "%s"', packet.type, packet.data);

        this.emit('packet', packet);

        // Socket is live - any packet counts
        this.emit('heartbeat');

        switch (packet.type) {
          case 'open':
            this.onHandshake(JSON.parse(packet.data));
            break;

          case 'pong':
            this.setPing();
            this.emit('pong');
            break;

          case 'error':
            var err = new Error('server error');
            err.code = packet.data;
            this.onError(err);
            break;

          case 'message':
            this.emit('data', packet.data);
            this.emit('message', packet.data);
            break;
        }
      } else {
        debug$5('packet received with socket readyState "%s"', this.readyState);
      }
    };

    /**
     * Called upon handshake completion.
     *
     * @param {Object} handshake obj
     * @api private
     */

    Socket.prototype.onHandshake = function (data) {
      this.emit('handshake', data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this.upgrades = this.filterUpgrades(data.upgrades);
      this.pingInterval = data.pingInterval;
      this.pingTimeout = data.pingTimeout;
      this.onOpen();
      // In case open handler closes socket
      if ('closed' === this.readyState) return;
      this.setPing();

      // Prolong liveness of socket on heartbeat
      this.removeListener('heartbeat', this.onHeartbeat);
      this.on('heartbeat', this.onHeartbeat);
    };

    /**
     * Resets ping timeout.
     *
     * @api private
     */

    Socket.prototype.onHeartbeat = function (timeout) {
      clearTimeout(this.pingTimeoutTimer);
      var self = this;
      self.pingTimeoutTimer = setTimeout(function () {
        if ('closed' === self.readyState) return;
        self.onClose('ping timeout');
      }, timeout || (self.pingInterval + self.pingTimeout));
    };

    /**
     * Pings server every `this.pingInterval` and expects response
     * within `this.pingTimeout` or closes connection.
     *
     * @api private
     */

    Socket.prototype.setPing = function () {
      var self = this;
      clearTimeout(self.pingIntervalTimer);
      self.pingIntervalTimer = setTimeout(function () {
        debug$5('writing ping packet - expecting pong within %sms', self.pingTimeout);
        self.ping();
        self.onHeartbeat(self.pingTimeout);
      }, self.pingInterval);
    };

    /**
    * Sends a ping packet.
    *
    * @api private
    */

    Socket.prototype.ping = function () {
      var self = this;
      this.sendPacket('ping', function () {
        self.emit('ping');
      });
    };

    /**
     * Called on `drain` event
     *
     * @api private
     */

    Socket.prototype.onDrain = function () {
      this.writeBuffer.splice(0, this.prevBufferLen);

      // setting prevBufferLen = 0 is very important
      // for example, when upgrading, upgrade packet is sent over,
      // and a nonzero prevBufferLen could cause problems on `drain`
      this.prevBufferLen = 0;

      if (0 === this.writeBuffer.length) {
        this.emit('drain');
      } else {
        this.flush();
      }
    };

    /**
     * Flush write buffers.
     *
     * @api private
     */

    Socket.prototype.flush = function () {
      if ('closed' !== this.readyState && this.transport.writable &&
        !this.upgrading && this.writeBuffer.length) {
        debug$5('flushing %d packets in socket', this.writeBuffer.length);
        this.transport.send(this.writeBuffer);
        // keep track of current length of writeBuffer
        // splice writeBuffer and callbackBuffer on `drain`
        this.prevBufferLen = this.writeBuffer.length;
        this.emit('flush');
      }
    };

    /**
     * Sends a message.
     *
     * @param {String} message.
     * @param {Function} callback function.
     * @param {Object} options.
     * @return {Socket} for chaining.
     * @api public
     */

    Socket.prototype.write =
    Socket.prototype.send = function (msg, options, fn) {
      this.sendPacket('message', msg, options, fn);
      return this;
    };

    /**
     * Sends a packet.
     *
     * @param {String} packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} callback function.
     * @api private
     */

    Socket.prototype.sendPacket = function (type, data, options, fn) {
      if ('function' === typeof data) {
        fn = data;
        data = undefined;
      }

      if ('function' === typeof options) {
        fn = options;
        options = null;
      }

      if ('closing' === this.readyState || 'closed' === this.readyState) {
        return;
      }

      options = options || {};
      options.compress = false !== options.compress;

      var packet = {
        type: type,
        data: data,
        options: options
      };
      this.emit('packetCreate', packet);
      this.writeBuffer.push(packet);
      if (fn) this.once('flush', fn);
      this.flush();
    };

    /**
     * Closes the connection.
     *
     * @api private
     */

    Socket.prototype.close = function () {
      if ('opening' === this.readyState || 'open' === this.readyState) {
        this.readyState = 'closing';

        var self = this;

        if (this.writeBuffer.length) {
          this.once('drain', function () {
            if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }

      function close () {
        self.onClose('forced close');
        debug$5('socket closing - telling transport to close');
        self.transport.close();
      }

      function cleanupAndClose () {
        self.removeListener('upgrade', cleanupAndClose);
        self.removeListener('upgradeError', cleanupAndClose);
        close();
      }

      function waitForUpgrade () {
        // wait for upgrade to finish since we can't send packets while pausing a transport
        self.once('upgrade', cleanupAndClose);
        self.once('upgradeError', cleanupAndClose);
      }

      return this;
    };

    /**
     * Called upon transport error
     *
     * @api private
     */

    Socket.prototype.onError = function (err) {
      debug$5('socket error %j', err);
      Socket.priorWebsocketSuccess = false;
      this.emit('error', err);
      this.onClose('transport error', err);
    };

    /**
     * Called upon transport close.
     *
     * @api private
     */

    Socket.prototype.onClose = function (reason, desc) {
      if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
        debug$5('socket close with reason: "%s"', reason);
        var self = this;

        // clear timers
        clearTimeout(this.pingIntervalTimer);
        clearTimeout(this.pingTimeoutTimer);

        // stop event from firing again for transport
        this.transport.removeAllListeners('close');

        // ensure transport won't stay open
        this.transport.close();

        // ignore further transport communication
        this.transport.removeAllListeners();

        // set ready state
        this.readyState = 'closed';

        // clear session id
        this.id = null;

        // emit close event
        this.emit('close', reason, desc);

        // clean buffers after, so users can still
        // grab the buffers on `close` event
        self.writeBuffer = [];
        self.prevBufferLen = 0;
      }
    };

    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} server upgrades
     * @api private
     *
     */

    Socket.prototype.filterUpgrades = function (upgrades) {
      var filteredUpgrades = [];
      for (var i = 0, j = upgrades.length; i < j; i++) {
        if (~indexof(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
      }
      return filteredUpgrades;
    };

    var lib = socket;

    /**
     * Exports parser
     *
     * @api public
     *
     */
    var parser = browser$2;
    lib.parser = parser;

    var componentEmitter$2 = createCommonjsModule(function (module) {
    /**
     * Expose `Emitter`.
     */

    {
      module.exports = Emitter;
    }

    /**
     * Initialize a new `Emitter`.
     *
     * @api public
     */

    function Emitter(obj) {
      if (obj) return mixin(obj);
    }
    /**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }

    /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.on =
    Emitter.prototype.addEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};
      (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
        .push(fn);
      return this;
    };

    /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.once = function(event, fn){
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }

      on.fn = fn;
      this.on(event, on);
      return this;
    };

    /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.off =
    Emitter.prototype.removeListener =
    Emitter.prototype.removeAllListeners =
    Emitter.prototype.removeEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};

      // all
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }

      // specific event
      var callbacks = this._callbacks['$' + event];
      if (!callbacks) return this;

      // remove all handlers
      if (1 == arguments.length) {
        delete this._callbacks['$' + event];
        return this;
      }

      // remove specific handler
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      return this;
    };

    /**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */

    Emitter.prototype.emit = function(event){
      this._callbacks = this._callbacks || {};
      var args = [].slice.call(arguments, 1)
        , callbacks = this._callbacks['$' + event];

      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }

      return this;
    };

    /**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */

    Emitter.prototype.listeners = function(event){
      this._callbacks = this._callbacks || {};
      return this._callbacks['$' + event] || [];
    };

    /**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */

    Emitter.prototype.hasListeners = function(event){
      return !! this.listeners(event).length;
    };
    });

    var toArray_1 = toArray;

    function toArray(list, index) {
        var array = [];

        index = index || 0;

        for (var i = index || 0; i < list.length; i++) {
            array[i - index] = list[i];
        }

        return array
    }

    /**
     * Module exports.
     */

    var on_1 = on;

    /**
     * Helper for subscriptions.
     *
     * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
     * @param {String} event name
     * @param {Function} callback
     * @api public
     */

    function on (obj, ev, fn) {
      obj.on(ev, fn);
      return {
        destroy: function () {
          obj.removeListener(ev, fn);
        }
      };
    }

    /**
     * Slice reference.
     */

    var slice = [].slice;

    /**
     * Bind `obj` to `fn`.
     *
     * @param {Object} obj
     * @param {Function|String} fn or string
     * @return {Function}
     * @api public
     */

    var componentBind = function(obj, fn){
      if ('string' == typeof fn) fn = obj[fn];
      if ('function' != typeof fn) throw new Error('bind() requires a function');
      var args = slice.call(arguments, 2);
      return function(){
        return fn.apply(obj, args.concat(slice.call(arguments)));
      }
    };

    var socket$1 = createCommonjsModule(function (module, exports) {
    /**
     * Module dependencies.
     */






    var debug = browser('socket.io-client:socket');



    /**
     * Module exports.
     */

    module.exports = exports = Socket;

    /**
     * Internal events (blacklisted).
     * These events can't be emitted by the user.
     *
     * @api private
     */

    var events = {
      connect: 1,
      connect_error: 1,
      connect_timeout: 1,
      connecting: 1,
      disconnect: 1,
      error: 1,
      reconnect: 1,
      reconnect_attempt: 1,
      reconnect_failed: 1,
      reconnect_error: 1,
      reconnecting: 1,
      ping: 1,
      pong: 1
    };

    /**
     * Shortcut to `Emitter#emit`.
     */

    var emit = componentEmitter$2.prototype.emit;

    /**
     * `Socket` constructor.
     *
     * @api public
     */

    function Socket (io, nsp, opts) {
      this.io = io;
      this.nsp = nsp;
      this.json = this; // compat
      this.ids = 0;
      this.acks = {};
      this.receiveBuffer = [];
      this.sendBuffer = [];
      this.connected = false;
      this.disconnected = true;
      this.flags = {};
      if (opts && opts.query) {
        this.query = opts.query;
      }
      if (this.io.autoConnect) this.open();
    }

    /**
     * Mix in `Emitter`.
     */

    componentEmitter$2(Socket.prototype);

    /**
     * Subscribe to open, close and packet events
     *
     * @api private
     */

    Socket.prototype.subEvents = function () {
      if (this.subs) return;

      var io = this.io;
      this.subs = [
        on_1(io, 'open', componentBind(this, 'onopen')),
        on_1(io, 'packet', componentBind(this, 'onpacket')),
        on_1(io, 'close', componentBind(this, 'onclose'))
      ];
    };

    /**
     * "Opens" the socket.
     *
     * @api public
     */

    Socket.prototype.open =
    Socket.prototype.connect = function () {
      if (this.connected) return this;

      this.subEvents();
      this.io.open(); // ensure open
      if ('open' === this.io.readyState) this.onopen();
      this.emit('connecting');
      return this;
    };

    /**
     * Sends a `message` event.
     *
     * @return {Socket} self
     * @api public
     */

    Socket.prototype.send = function () {
      var args = toArray_1(arguments);
      args.unshift('message');
      this.emit.apply(this, args);
      return this;
    };

    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @param {String} event name
     * @return {Socket} self
     * @api public
     */

    Socket.prototype.emit = function (ev) {
      if (events.hasOwnProperty(ev)) {
        emit.apply(this, arguments);
        return this;
      }

      var args = toArray_1(arguments);
      var packet = {
        type: (this.flags.binary !== undefined ? this.flags.binary : hasBinary2(args)) ? socket_ioParser.BINARY_EVENT : socket_ioParser.EVENT,
        data: args
      };

      packet.options = {};
      packet.options.compress = !this.flags || false !== this.flags.compress;

      // event ack callback
      if ('function' === typeof args[args.length - 1]) {
        debug('emitting packet with ack id %d', this.ids);
        this.acks[this.ids] = args.pop();
        packet.id = this.ids++;
      }

      if (this.connected) {
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }

      this.flags = {};

      return this;
    };

    /**
     * Sends a packet.
     *
     * @param {Object} packet
     * @api private
     */

    Socket.prototype.packet = function (packet) {
      packet.nsp = this.nsp;
      this.io.packet(packet);
    };

    /**
     * Called upon engine `open`.
     *
     * @api private
     */

    Socket.prototype.onopen = function () {
      debug('transport is open - connecting');

      // write connect packet if necessary
      if ('/' !== this.nsp) {
        if (this.query) {
          var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
          debug('sending connect packet with query %s', query);
          this.packet({type: socket_ioParser.CONNECT, query: query});
        } else {
          this.packet({type: socket_ioParser.CONNECT});
        }
      }
    };

    /**
     * Called upon engine `close`.
     *
     * @param {String} reason
     * @api private
     */

    Socket.prototype.onclose = function (reason) {
      debug('close (%s)', reason);
      this.connected = false;
      this.disconnected = true;
      delete this.id;
      this.emit('disconnect', reason);
    };

    /**
     * Called with socket packet.
     *
     * @param {Object} packet
     * @api private
     */

    Socket.prototype.onpacket = function (packet) {
      var sameNamespace = packet.nsp === this.nsp;
      var rootNamespaceError = packet.type === socket_ioParser.ERROR && packet.nsp === '/';

      if (!sameNamespace && !rootNamespaceError) return;

      switch (packet.type) {
        case socket_ioParser.CONNECT:
          this.onconnect();
          break;

        case socket_ioParser.EVENT:
          this.onevent(packet);
          break;

        case socket_ioParser.BINARY_EVENT:
          this.onevent(packet);
          break;

        case socket_ioParser.ACK:
          this.onack(packet);
          break;

        case socket_ioParser.BINARY_ACK:
          this.onack(packet);
          break;

        case socket_ioParser.DISCONNECT:
          this.ondisconnect();
          break;

        case socket_ioParser.ERROR:
          this.emit('error', packet.data);
          break;
      }
    };

    /**
     * Called upon a server event.
     *
     * @param {Object} packet
     * @api private
     */

    Socket.prototype.onevent = function (packet) {
      var args = packet.data || [];
      debug('emitting event %j', args);

      if (null != packet.id) {
        debug('attaching ack callback to event');
        args.push(this.ack(packet.id));
      }

      if (this.connected) {
        emit.apply(this, args);
      } else {
        this.receiveBuffer.push(args);
      }
    };

    /**
     * Produces an ack callback to emit with an event.
     *
     * @api private
     */

    Socket.prototype.ack = function (id) {
      var self = this;
      var sent = false;
      return function () {
        // prevent double callbacks
        if (sent) return;
        sent = true;
        var args = toArray_1(arguments);
        debug('sending ack %j', args);

        self.packet({
          type: hasBinary2(args) ? socket_ioParser.BINARY_ACK : socket_ioParser.ACK,
          id: id,
          data: args
        });
      };
    };

    /**
     * Called upon a server acknowlegement.
     *
     * @param {Object} packet
     * @api private
     */

    Socket.prototype.onack = function (packet) {
      var ack = this.acks[packet.id];
      if ('function' === typeof ack) {
        debug('calling ack %s with %j', packet.id, packet.data);
        ack.apply(this, packet.data);
        delete this.acks[packet.id];
      } else {
        debug('bad ack %s', packet.id);
      }
    };

    /**
     * Called upon server connect.
     *
     * @api private
     */

    Socket.prototype.onconnect = function () {
      this.connected = true;
      this.disconnected = false;
      this.emit('connect');
      this.emitBuffered();
    };

    /**
     * Emit buffered events (received and emitted).
     *
     * @api private
     */

    Socket.prototype.emitBuffered = function () {
      var i;
      for (i = 0; i < this.receiveBuffer.length; i++) {
        emit.apply(this, this.receiveBuffer[i]);
      }
      this.receiveBuffer = [];

      for (i = 0; i < this.sendBuffer.length; i++) {
        this.packet(this.sendBuffer[i]);
      }
      this.sendBuffer = [];
    };

    /**
     * Called upon server disconnect.
     *
     * @api private
     */

    Socket.prototype.ondisconnect = function () {
      debug('server disconnect (%s)', this.nsp);
      this.destroy();
      this.onclose('io server disconnect');
    };

    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @api private.
     */

    Socket.prototype.destroy = function () {
      if (this.subs) {
        // clean subscriptions to avoid reconnections
        for (var i = 0; i < this.subs.length; i++) {
          this.subs[i].destroy();
        }
        this.subs = null;
      }

      this.io.destroy(this);
    };

    /**
     * Disconnects the socket manually.
     *
     * @return {Socket} self
     * @api public
     */

    Socket.prototype.close =
    Socket.prototype.disconnect = function () {
      if (this.connected) {
        debug('performing disconnect (%s)', this.nsp);
        this.packet({ type: socket_ioParser.DISCONNECT });
      }

      // remove socket from pool
      this.destroy();

      if (this.connected) {
        // fire events
        this.onclose('io client disconnect');
      }
      return this;
    };

    /**
     * Sets the compress flag.
     *
     * @param {Boolean} if `true`, compresses the sending data
     * @return {Socket} self
     * @api public
     */

    Socket.prototype.compress = function (compress) {
      this.flags.compress = compress;
      return this;
    };

    /**
     * Sets the binary flag
     *
     * @param {Boolean} whether the emitted data contains binary
     * @return {Socket} self
     * @api public
     */

    Socket.prototype.binary = function (binary) {
      this.flags.binary = binary;
      return this;
    };
    });

    /**
     * Expose `Backoff`.
     */

    var backo2 = Backoff;

    /**
     * Initialize backoff timer with `opts`.
     *
     * - `min` initial timeout in milliseconds [100]
     * - `max` max timeout [10000]
     * - `jitter` [0]
     * - `factor` [2]
     *
     * @param {Object} opts
     * @api public
     */

    function Backoff(opts) {
      opts = opts || {};
      this.ms = opts.min || 100;
      this.max = opts.max || 10000;
      this.factor = opts.factor || 2;
      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
      this.attempts = 0;
    }

    /**
     * Return the backoff duration.
     *
     * @return {Number}
     * @api public
     */

    Backoff.prototype.duration = function(){
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand =  Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
      }
      return Math.min(ms, this.max) | 0;
    };

    /**
     * Reset the number of attempts.
     *
     * @api public
     */

    Backoff.prototype.reset = function(){
      this.attempts = 0;
    };

    /**
     * Set the minimum duration
     *
     * @api public
     */

    Backoff.prototype.setMin = function(min){
      this.ms = min;
    };

    /**
     * Set the maximum duration
     *
     * @api public
     */

    Backoff.prototype.setMax = function(max){
      this.max = max;
    };

    /**
     * Set the jitter
     *
     * @api public
     */

    Backoff.prototype.setJitter = function(jitter){
      this.jitter = jitter;
    };

    /**
     * Module dependencies.
     */







    var debug$6 = browser('socket.io-client:manager');



    /**
     * IE6+ hasOwnProperty
     */

    var has = Object.prototype.hasOwnProperty;

    /**
     * Module exports
     */

    var manager = Manager;

    /**
     * `Manager` constructor.
     *
     * @param {String} engine instance or engine uri/opts
     * @param {Object} options
     * @api public
     */

    function Manager (uri, opts) {
      if (!(this instanceof Manager)) return new Manager(uri, opts);
      if (uri && ('object' === typeof uri)) {
        opts = uri;
        uri = undefined;
      }
      opts = opts || {};

      opts.path = opts.path || '/socket.io';
      this.nsps = {};
      this.subs = [];
      this.opts = opts;
      this.reconnection(opts.reconnection !== false);
      this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
      this.reconnectionDelay(opts.reconnectionDelay || 1000);
      this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
      this.randomizationFactor(opts.randomizationFactor || 0.5);
      this.backoff = new backo2({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      });
      this.timeout(null == opts.timeout ? 20000 : opts.timeout);
      this.readyState = 'closed';
      this.uri = uri;
      this.connecting = [];
      this.lastPing = null;
      this.encoding = false;
      this.packetBuffer = [];
      var _parser = opts.parser || socket_ioParser;
      this.encoder = new _parser.Encoder();
      this.decoder = new _parser.Decoder();
      this.autoConnect = opts.autoConnect !== false;
      if (this.autoConnect) this.open();
    }

    /**
     * Propagate given event to sockets and emit on `this`
     *
     * @api private
     */

    Manager.prototype.emitAll = function () {
      this.emit.apply(this, arguments);
      for (var nsp in this.nsps) {
        if (has.call(this.nsps, nsp)) {
          this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
        }
      }
    };

    /**
     * Update `socket.id` of all sockets
     *
     * @api private
     */

    Manager.prototype.updateSocketIds = function () {
      for (var nsp in this.nsps) {
        if (has.call(this.nsps, nsp)) {
          this.nsps[nsp].id = this.generateId(nsp);
        }
      }
    };

    /**
     * generate `socket.id` for the given `nsp`
     *
     * @param {String} nsp
     * @return {String}
     * @api private
     */

    Manager.prototype.generateId = function (nsp) {
      return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
    };

    /**
     * Mix in `Emitter`.
     */

    componentEmitter$2(Manager.prototype);

    /**
     * Sets the `reconnection` config.
     *
     * @param {Boolean} true/false if it should automatically reconnect
     * @return {Manager} self or value
     * @api public
     */

    Manager.prototype.reconnection = function (v) {
      if (!arguments.length) return this._reconnection;
      this._reconnection = !!v;
      return this;
    };

    /**
     * Sets the reconnection attempts config.
     *
     * @param {Number} max reconnection attempts before giving up
     * @return {Manager} self or value
     * @api public
     */

    Manager.prototype.reconnectionAttempts = function (v) {
      if (!arguments.length) return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    };

    /**
     * Sets the delay between reconnections.
     *
     * @param {Number} delay
     * @return {Manager} self or value
     * @api public
     */

    Manager.prototype.reconnectionDelay = function (v) {
      if (!arguments.length) return this._reconnectionDelay;
      this._reconnectionDelay = v;
      this.backoff && this.backoff.setMin(v);
      return this;
    };

    Manager.prototype.randomizationFactor = function (v) {
      if (!arguments.length) return this._randomizationFactor;
      this._randomizationFactor = v;
      this.backoff && this.backoff.setJitter(v);
      return this;
    };

    /**
     * Sets the maximum delay between reconnections.
     *
     * @param {Number} delay
     * @return {Manager} self or value
     * @api public
     */

    Manager.prototype.reconnectionDelayMax = function (v) {
      if (!arguments.length) return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      this.backoff && this.backoff.setMax(v);
      return this;
    };

    /**
     * Sets the connection timeout. `false` to disable
     *
     * @return {Manager} self or value
     * @api public
     */

    Manager.prototype.timeout = function (v) {
      if (!arguments.length) return this._timeout;
      this._timeout = v;
      return this;
    };

    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @api private
     */

    Manager.prototype.maybeReconnectOnOpen = function () {
      // Only try to reconnect if it's the first time we're connecting
      if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
        // keeps reconnection from firing twice for the same reconnection loop
        this.reconnect();
      }
    };

    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} optional, callback
     * @return {Manager} self
     * @api public
     */

    Manager.prototype.open =
    Manager.prototype.connect = function (fn, opts) {
      debug$6('readyState %s', this.readyState);
      if (~this.readyState.indexOf('open')) return this;

      debug$6('opening %s', this.uri);
      this.engine = lib(this.uri, this.opts);
      var socket = this.engine;
      var self = this;
      this.readyState = 'opening';
      this.skipReconnect = false;

      // emit `open`
      var openSub = on_1(socket, 'open', function () {
        self.onopen();
        fn && fn();
      });

      // emit `connect_error`
      var errorSub = on_1(socket, 'error', function (data) {
        debug$6('connect_error');
        self.cleanup();
        self.readyState = 'closed';
        self.emitAll('connect_error', data);
        if (fn) {
          var err = new Error('Connection error');
          err.data = data;
          fn(err);
        } else {
          // Only do this if there is no fn to handle the error
          self.maybeReconnectOnOpen();
        }
      });

      // emit `connect_timeout`
      if (false !== this._timeout) {
        var timeout = this._timeout;
        debug$6('connect attempt will timeout after %d', timeout);

        // set timer
        var timer = setTimeout(function () {
          debug$6('connect attempt timed out after %d', timeout);
          openSub.destroy();
          socket.close();
          socket.emit('error', 'timeout');
          self.emitAll('connect_timeout', timeout);
        }, timeout);

        this.subs.push({
          destroy: function () {
            clearTimeout(timer);
          }
        });
      }

      this.subs.push(openSub);
      this.subs.push(errorSub);

      return this;
    };

    /**
     * Called upon transport open.
     *
     * @api private
     */

    Manager.prototype.onopen = function () {
      debug$6('open');

      // clear old subs
      this.cleanup();

      // mark as open
      this.readyState = 'open';
      this.emit('open');

      // add new subs
      var socket = this.engine;
      this.subs.push(on_1(socket, 'data', componentBind(this, 'ondata')));
      this.subs.push(on_1(socket, 'ping', componentBind(this, 'onping')));
      this.subs.push(on_1(socket, 'pong', componentBind(this, 'onpong')));
      this.subs.push(on_1(socket, 'error', componentBind(this, 'onerror')));
      this.subs.push(on_1(socket, 'close', componentBind(this, 'onclose')));
      this.subs.push(on_1(this.decoder, 'decoded', componentBind(this, 'ondecoded')));
    };

    /**
     * Called upon a ping.
     *
     * @api private
     */

    Manager.prototype.onping = function () {
      this.lastPing = new Date();
      this.emitAll('ping');
    };

    /**
     * Called upon a packet.
     *
     * @api private
     */

    Manager.prototype.onpong = function () {
      this.emitAll('pong', new Date() - this.lastPing);
    };

    /**
     * Called with data.
     *
     * @api private
     */

    Manager.prototype.ondata = function (data) {
      this.decoder.add(data);
    };

    /**
     * Called when parser fully decodes a packet.
     *
     * @api private
     */

    Manager.prototype.ondecoded = function (packet) {
      this.emit('packet', packet);
    };

    /**
     * Called upon socket error.
     *
     * @api private
     */

    Manager.prototype.onerror = function (err) {
      debug$6('error', err);
      this.emitAll('error', err);
    };

    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @api public
     */

    Manager.prototype.socket = function (nsp, opts) {
      var socket = this.nsps[nsp];
      if (!socket) {
        socket = new socket$1(this, nsp, opts);
        this.nsps[nsp] = socket;
        var self = this;
        socket.on('connecting', onConnecting);
        socket.on('connect', function () {
          socket.id = self.generateId(nsp);
        });

        if (this.autoConnect) {
          // manually call here since connecting event is fired before listening
          onConnecting();
        }
      }

      function onConnecting () {
        if (!~indexof(self.connecting, socket)) {
          self.connecting.push(socket);
        }
      }

      return socket;
    };

    /**
     * Called upon a socket close.
     *
     * @param {Socket} socket
     */

    Manager.prototype.destroy = function (socket) {
      var index = indexof(this.connecting, socket);
      if (~index) this.connecting.splice(index, 1);
      if (this.connecting.length) return;

      this.close();
    };

    /**
     * Writes a packet.
     *
     * @param {Object} packet
     * @api private
     */

    Manager.prototype.packet = function (packet) {
      debug$6('writing packet %j', packet);
      var self = this;
      if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

      if (!self.encoding) {
        // encode, then write to engine with result
        self.encoding = true;
        this.encoder.encode(packet, function (encodedPackets) {
          for (var i = 0; i < encodedPackets.length; i++) {
            self.engine.write(encodedPackets[i], packet.options);
          }
          self.encoding = false;
          self.processPacketQueue();
        });
      } else { // add packet to the queue
        self.packetBuffer.push(packet);
      }
    };

    /**
     * If packet buffer is non-empty, begins encoding the
     * next packet in line.
     *
     * @api private
     */

    Manager.prototype.processPacketQueue = function () {
      if (this.packetBuffer.length > 0 && !this.encoding) {
        var pack = this.packetBuffer.shift();
        this.packet(pack);
      }
    };

    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @api private
     */

    Manager.prototype.cleanup = function () {
      debug$6('cleanup');

      var subsLength = this.subs.length;
      for (var i = 0; i < subsLength; i++) {
        var sub = this.subs.shift();
        sub.destroy();
      }

      this.packetBuffer = [];
      this.encoding = false;
      this.lastPing = null;

      this.decoder.destroy();
    };

    /**
     * Close the current socket.
     *
     * @api private
     */

    Manager.prototype.close =
    Manager.prototype.disconnect = function () {
      debug$6('disconnect');
      this.skipReconnect = true;
      this.reconnecting = false;
      if ('opening' === this.readyState) {
        // `onclose` will not fire because
        // an open event never happened
        this.cleanup();
      }
      this.backoff.reset();
      this.readyState = 'closed';
      if (this.engine) this.engine.close();
    };

    /**
     * Called upon engine close.
     *
     * @api private
     */

    Manager.prototype.onclose = function (reason) {
      debug$6('onclose');

      this.cleanup();
      this.backoff.reset();
      this.readyState = 'closed';
      this.emit('close', reason);

      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    };

    /**
     * Attempt a reconnection.
     *
     * @api private
     */

    Manager.prototype.reconnect = function () {
      if (this.reconnecting || this.skipReconnect) return this;

      var self = this;

      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug$6('reconnect failed');
        this.backoff.reset();
        this.emitAll('reconnect_failed');
        this.reconnecting = false;
      } else {
        var delay = this.backoff.duration();
        debug$6('will wait %dms before reconnect attempt', delay);

        this.reconnecting = true;
        var timer = setTimeout(function () {
          if (self.skipReconnect) return;

          debug$6('attempting reconnect');
          self.emitAll('reconnect_attempt', self.backoff.attempts);
          self.emitAll('reconnecting', self.backoff.attempts);

          // check again for the case socket closed in above events
          if (self.skipReconnect) return;

          self.open(function (err) {
            if (err) {
              debug$6('reconnect attempt error');
              self.reconnecting = false;
              self.reconnect();
              self.emitAll('reconnect_error', err.data);
            } else {
              debug$6('reconnect success');
              self.onreconnect();
            }
          });
        }, delay);

        this.subs.push({
          destroy: function () {
            clearTimeout(timer);
          }
        });
      }
    };

    /**
     * Called upon successful reconnect.
     *
     * @api private
     */

    Manager.prototype.onreconnect = function () {
      var attempt = this.backoff.attempts;
      this.reconnecting = false;
      this.backoff.reset();
      this.updateSocketIds();
      this.emitAll('reconnect', attempt);
    };

    var lib$1 = createCommonjsModule(function (module, exports) {
    /**
     * Module dependencies.
     */




    var debug = browser('socket.io-client');

    /**
     * Module exports.
     */

    module.exports = exports = lookup;

    /**
     * Managers cache.
     */

    var cache = exports.managers = {};

    /**
     * Looks up an existing `Manager` for multiplexing.
     * If the user summons:
     *
     *   `io('http://localhost/a');`
     *   `io('http://localhost/b');`
     *
     * We reuse the existing instance based on same scheme/port/host,
     * and we initialize sockets for each namespace.
     *
     * @api public
     */

    function lookup (uri, opts) {
      if (typeof uri === 'object') {
        opts = uri;
        uri = undefined;
      }

      opts = opts || {};

      var parsed = url_1(uri);
      var source = parsed.source;
      var id = parsed.id;
      var path = parsed.path;
      var sameNamespace = cache[id] && path in cache[id].nsps;
      var newConnection = opts.forceNew || opts['force new connection'] ||
                          false === opts.multiplex || sameNamespace;

      var io;

      if (newConnection) {
        debug('ignoring socket cache for %s', source);
        io = manager(source, opts);
      } else {
        if (!cache[id]) {
          debug('new io instance for %s', source);
          cache[id] = manager(source, opts);
        }
        io = cache[id];
      }
      if (parsed.query && !opts.query) {
        opts.query = parsed.query;
      }
      return io.socket(parsed.path, opts);
    }

    /**
     * Protocol version.
     *
     * @api public
     */

    exports.protocol = socket_ioParser.protocol;

    /**
     * `connect`.
     *
     * @param {String} uri
     * @api public
     */

    exports.connect = lookup;

    /**
     * Expose constructors for standalone build.
     *
     * @api public
     */

    exports.Manager = manager;
    exports.Socket = socket$1;
    });
    var lib_1 = lib$1.managers;
    var lib_2 = lib$1.protocol;
    var lib_3 = lib$1.connect;
    var lib_4 = lib$1.Manager;
    var lib_5 = lib$1.Socket;

    /* src\App.svelte generated by Svelte v3.18.1 */

    const { document: document_1 } = globals;

    const file$n = "src\\App.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	child_ctx[19] = i;
    	return child_ctx;
    }

    // (433:6) {:else}
    function create_else_block_2(ctx) {
    	let center;
    	let p;
    	let t1;

    	const block = {
    		c: function create() {
    			center = element("center");
    			p = element("p");
    			p.textContent = "Comments are loading...";
    			t1 = space();
    			attr_dev(p, "class", "svelte-tur9y2");
    			add_location(p, file$n, 435, 10, 9384);
    			attr_dev(center, "class", "svelte-tur9y2");
    			add_location(center, file$n, 434, 8, 9365);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, center, anchor);
    			append_dev(center, p);
    			append_dev(center, t1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(center);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(433:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (406:8) {:else}
    function create_else_block$2(ctx) {
    	let t0;
    	let article;
    	let current_block_type_index;
    	let if_block1;
    	let t1;
    	let input;
    	let t2;
    	let div_1;
    	let t3_value = /*comment*/ ctx[17].time + "";
    	let t3;
    	let t4;
    	let article_class_value;
    	let current;
    	let if_block0 = /*i*/ ctx[19] != 0 && /*comment*/ ctx[17].author != /*comments*/ ctx[4][/*i*/ ctx[19] - 1].author && create_if_block_2$1(ctx);
    	const if_block_creators = [create_if_block_1$2, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*comment*/ ctx[17].type === "link") return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			article = element("article");
    			if_block1.c();
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			div_1 = element("div");
    			t3 = text(t3_value);
    			t4 = space();
    			attr_dev(input, "class", "nothing svelte-tur9y2");
    			attr_dev(input, "type", "button");
    			add_location(input, file$n, 428, 12, 9152);
    			attr_dev(div_1, "id", "commentdate");
    			attr_dev(div_1, "class", "svelte-tur9y2");
    			add_location(div_1, file$n, 429, 12, 9204);

    			attr_dev(article, "class", article_class_value = "" + (null_to_empty(/*comment*/ ctx[17].author === /*name*/ ctx[1]
    			? "user"
    			: "other") + " svelte-tur9y2"));

    			add_location(article, file$n, 413, 10, 8674);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, article, anchor);
    			if_blocks[current_block_type_index].m(article, null);
    			append_dev(article, t1);
    			append_dev(article, input);
    			append_dev(article, t2);
    			append_dev(article, div_1);
    			append_dev(div_1, t3);
    			append_dev(article, t4);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*i*/ ctx[19] != 0 && /*comment*/ ctx[17].author != /*comments*/ ctx[4][/*i*/ ctx[19] - 1].author) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$1(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(article, t1);
    			}

    			if ((!current || dirty & /*comments*/ 16) && t3_value !== (t3_value = /*comment*/ ctx[17].time + "")) set_data_dev(t3, t3_value);

    			if (!current || dirty & /*comments, name*/ 18 && article_class_value !== (article_class_value = "" + (null_to_empty(/*comment*/ ctx[17].author === /*name*/ ctx[1]
    			? "user"
    			: "other") + " svelte-tur9y2"))) {
    				attr_dev(article, "class", article_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(article);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(406:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (404:8) {#if comment.author === 'system'}
    function create_if_block$3(ctx) {
    	let span;
    	let t_value = /*comment*/ ctx[17].text + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "systemsg svelte-tur9y2");
    			add_location(span, file$n, 404, 10, 8298);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*comments*/ 16 && t_value !== (t_value = /*comment*/ ctx[17].text + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(404:8) {#if comment.author === 'system'}",
    		ctx
    	});

    	return block;
    }

    // (407:10) {#if i != 0 && comment.author != comments[i - 1].author}
    function create_if_block_2$1(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*comment*/ ctx[17].type === "bot") return create_if_block_3;
    		if (/*comment*/ ctx[17].author != /*name*/ ctx[1]) return create_if_block_4;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) {
    				if_block.d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(407:10) {#if i != 0 && comment.author != comments[i - 1].author}",
    		ctx
    	});

    	return block;
    }

    // (410:45) 
    function create_if_block_4(ctx) {
    	let p;
    	let t0_value = /*comment*/ ctx[17].author + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = text(":");
    			attr_dev(p, "class", "otherusert svelte-tur9y2");
    			add_location(p, file$n, 410, 14, 8586);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*comments*/ 16 && t0_value !== (t0_value = /*comment*/ ctx[17].author + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(410:45) ",
    		ctx
    	});

    	return block;
    }

    // (408:12) {#if comment.type === 'bot'}
    function create_if_block_3(ctx) {
    	let p;
    	let t0_value = /*comment*/ ctx[17].author + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = text(":");
    			attr_dev(p, "class", "bot_respond svelte-tur9y2");
    			add_location(p, file$n, 408, 14, 8481);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*comments*/ 16 && t0_value !== (t0_value = /*comment*/ ctx[17].author + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(408:12) {#if comment.type === 'bot'}",
    		ctx
    	});

    	return block;
    }

    // (424:12) {:else}
    function create_else_block_1(ctx) {
    	let span;
    	let raw_value = /*comment*/ ctx[17].text + "";

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "svelte-tur9y2");
    			add_location(span, file$n, 424, 14, 9056);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			span.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*comments*/ 16 && raw_value !== (raw_value = /*comment*/ ctx[17].text + "")) span.innerHTML = raw_value;		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(424:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (415:12) {#if comment.type === 'link'}
    function create_if_block_1$2(ctx) {
    	let span;
    	let current;

    	const linkpreview = new Linkpreview({
    			props: {
    				title: /*comment*/ ctx[17].title,
    				image: /*comment*/ ctx[17].image,
    				description: /*comment*/ ctx[17].description,
    				url: /*comment*/ ctx[17].text
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(linkpreview.$$.fragment);
    			attr_dev(span, "class", "svelte-tur9y2");
    			add_location(span, file$n, 415, 14, 8791);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(linkpreview, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const linkpreview_changes = {};
    			if (dirty & /*comments*/ 16) linkpreview_changes.title = /*comment*/ ctx[17].title;
    			if (dirty & /*comments*/ 16) linkpreview_changes.image = /*comment*/ ctx[17].image;
    			if (dirty & /*comments*/ 16) linkpreview_changes.description = /*comment*/ ctx[17].description;
    			if (dirty & /*comments*/ 16) linkpreview_changes.url = /*comment*/ ctx[17].text;
    			linkpreview.$set(linkpreview_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linkpreview.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linkpreview.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(linkpreview);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(415:12) {#if comment.type === 'link'}",
    		ctx
    	});

    	return block;
    }

    // (403:6) {#each comments as comment, i}
    function create_each_block$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$3, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*comment*/ ctx[17].author === "system") return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(403:6) {#each comments as comment, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let script0;
    	let script0_src_value;
    	let script1;
    	let link;
    	let t1;
    	let main;
    	let updating_name;
    	let t2;
    	let div3;
    	let div0;
    	let t3;
    	let div2;
    	let div1;
    	let t4;
    	let t5;
    	let button;
    	let Anchor_action;
    	let current;
    	let dispose;

    	function headdiv_name_binding(value) {
    		/*headdiv_name_binding*/ ctx[13].call(null, value);
    	}

    	let headdiv_props = {};

    	if (/*name*/ ctx[1] !== void 0) {
    		headdiv_props.name = /*name*/ ctx[1];
    	}

    	const headdiv = new Headdiv({ props: headdiv_props, $$inline: true });
    	binding_callbacks.push(() => bind(headdiv, "name", headdiv_name_binding));
    	let each_value = /*comments*/ ctx[4];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let each_1_else = null;

    	if (!each_value.length) {
    		each_1_else = create_else_block_2(ctx);
    	}

    	const emoji = new Emoji({ $$inline: true });
    	emoji.$on("emojiClicked", /*alertmsg*/ ctx[6]);

    	const block = {
    		c: function create() {
    			script0 = element("script");
    			script1 = element("script");
    			script1.textContent = "window.dataLayer = window.dataLayer || [];\n    function gtag() {\n      dataLayer.push(arguments);\n    }\n    gtag(\"js\", new Date());\n\n    gtag(\"config\", \"UA-158899098-1\");\n  ";
    			link = element("link");
    			t1 = space();
    			main = element("main");
    			create_component(headdiv.$$.fragment);
    			t2 = space();
    			div3 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			if (each_1_else) {
    				each_1_else.c();
    			}

    			t3 = space();
    			div2 = element("div");
    			div1 = element("div");
    			t4 = space();
    			create_component(emoji.$$.fragment);
    			t5 = space();
    			button = element("button");
    			button.textContent = "Send";
    			script0.async = true;
    			if (script0.src !== (script0_src_value = "https://www.googletagmanager.com/gtag/js?id=UA-158899098-1")) attr_dev(script0, "src", script0_src_value);
    			add_location(script0, file$n, 376, 2, 7681);
    			add_location(script1, file$n, 381, 2, 7784);
    			attr_dev(link, "href", "https://fonts.googleapis.com/css?family=Roboto&display=swap");
    			attr_dev(link, "rel", "stylesheet");
    			add_location(link, file$n, 390, 2, 7982);
    			attr_dev(div0, "class", "scrollable svelte-tur9y2");
    			add_location(div0, file$n, 401, 4, 8168);
    			attr_dev(div1, "contenteditable", "true");
    			attr_dev(div1, "class", "svelte-tur9y2");
    			if (/*input1*/ ctx[3] === void 0) add_render_callback(() => /*div1_input_handler*/ ctx[15].call(div1));
    			add_location(div1, file$n, 441, 6, 9539);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "svelte-tur9y2");
    			add_location(button, file$n, 448, 6, 9767);
    			attr_dev(div2, "class", "msg-input svelte-tur9y2");
    			attr_dev(div2, "id", "msg-input");
    			add_location(div2, file$n, 440, 4, 9463);
    			attr_dev(div3, "class", "chat svelte-tur9y2");
    			attr_dev(div3, "id", "chat");
    			add_location(div3, file$n, 400, 2, 8135);
    			attr_dev(main, "class", "svelte-tur9y2");
    			add_location(main, file$n, 396, 0, 8100);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document_1.head, script0);
    			append_dev(document_1.head, script1);
    			append_dev(document_1.head, link);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(headdiv, main, null);
    			append_dev(main, t2);
    			append_dev(main, div3);
    			append_dev(div3, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			if (each_1_else) {
    				each_1_else.m(div0, null);
    			}

    			/*div0_binding*/ ctx[14](div0);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);

    			if (/*input1*/ ctx[3] !== void 0) {
    				div1.innerHTML = /*input1*/ ctx[3];
    			}

    			append_dev(div2, t4);
    			mount_component(emoji, div2, null);
    			append_dev(div2, t5);
    			append_dev(div2, button);
    			/*div2_binding*/ ctx[16](div2);
    			current = true;

    			dispose = [
    				listen_dev(div1, "input", /*div1_input_handler*/ ctx[15]),
    				listen_dev(div1, "keydown", /*handleKeydown*/ ctx[5], false, false, false),
    				listen_dev(button, "click", /*handleKeydown*/ ctx[5], false, false, false),
    				action_destroyer(Anchor_action = Anchor.call(null, div2))
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			const headdiv_changes = {};

    			if (!updating_name && dirty & /*name*/ 2) {
    				updating_name = true;
    				headdiv_changes.name = /*name*/ ctx[1];
    				add_flush_callback(() => updating_name = false);
    			}

    			headdiv.$set(headdiv_changes);

    			if (dirty & /*comments, name*/ 18) {
    				each_value = /*comments*/ ctx[4];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (each_value.length) {
    				if (each_1_else) {
    					each_1_else.d(1);
    					each_1_else = null;
    				}
    			} else if (!each_1_else) {
    				each_1_else = create_else_block_2(ctx);
    				each_1_else.c();
    				each_1_else.m(div0, null);
    			}

    			if (dirty & /*input1*/ 8 && /*input1*/ ctx[3] !== div1.innerHTML) {
    				div1.innerHTML = /*input1*/ ctx[3];
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(headdiv.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(emoji.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(headdiv.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(emoji.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(script0);
    			detach_dev(script1);
    			detach_dev(link);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(main);
    			destroy_component(headdiv);
    			destroy_each(each_blocks, detaching);
    			if (each_1_else) each_1_else.d();
    			/*div0_binding*/ ctx[14](null);
    			destroy_component(emoji);
    			/*div2_binding*/ ctx[16](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const serveradd = "https://webchay.herokuapp.com";

    function asda() {
    	if (document.cookie) {
    		var cookieValue = document.cookie.replace(/(?:(?:^|.*;\s*)username\s*\=\s*([^;]*).*$)|^.*$/, "$1");
    		console.log(cookieValue);
    		return cookieValue;
    	} else {
    		return "Guest";
    	}
    }

    function addCookie(item) {
    	document.cookie = "username=" + item;
    }

    function dateformat(date) {
    	let now = new Date(date);
    	const offsetMs = now.getTimezoneOffset() * 60 * 1000;
    	var dateLocal = new Date(now.getTime() - offsetMs);
    	let str = dateLocal.toString().slice(0, 25);
    	return str;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let anchor2;
    	let name;
    	var currentuser;
    	let div;
    	let autoscroll;
    	let input1;
    	const socket = lib$1(serveradd);

    	beforeUpdate(() => {
    		autoscroll = div && div.offsetHeight + div.scrollTop > div.scrollHeight - 20;
    	});

    	afterUpdate(() => {
    		if (autoscroll) div.scrollTo(0, div.scrollHeight);
    	});

    	function handleKeydown() {
    		if (event.which === 13 || event.type === "click") {
    			event.preventDefault();

    			if (!name) {
    				alert("Please insert your name");
    				return;
    			}

    			
    			const text = input1;
    			if (text) return;
    			console.log(text);

    			socket.emit("chat message", {
    				author: name,
    				commend: text,
    				clienttime: new Date().toLocaleString()
    			});

    			console.log(comments);
    			$$invalidate(3, input1 = "");
    		}
    	}

    	
    	var formdata = new FormData();
    	var requestOptions = { method: "GET", redirect: "follow" };
    	let comments = [];
    	let uuser = [];

    	onMount(async () => {
    		const res = await fetch(serveradd + "/api/chat", requestOptions);
    		let results = await res.json();

    		await results.reverse().forEach(result => {
    			$$invalidate(4, comments = comments.concat({
    				author: result.author,
    				text: result.commend,
    				time: dateformat(result.time),
    				type: result.type,
    				title: result.title,
    				description: result.description,
    				image: result.image
    			}));

    			if (!uuser.includes(result.author)) {
    				uuser.push(result.author);
    			}

    			
    		});

    		console.log(uuser);
    	});

    	socket.on("chat message", function (json) {
    		json = JSON.parse(json);
    		console.log(json);

    		$$invalidate(4, comments = comments.concat({
    			author: json.author,
    			text: json.commend,
    			time: dateformat(json.time),
    			type: json.type,
    			title: json.title,
    			description: json.description,
    			image: json.image
    		}));
    	});

    	function alertmsg(event) {
    		$$invalidate(3, input1 += event.detail.detail);
    		console.log(input1.length);
    	}

    	function headdiv_name_binding(value) {
    		name = value;
    		$$invalidate(1, name);
    	}

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(2, div = $$value);
    		});
    	}

    	function div1_input_handler() {
    		input1 = this.innerHTML;
    		$$invalidate(3, input1);
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(0, anchor2 = $$value);
    		});
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("anchor2" in $$props) $$invalidate(0, anchor2 = $$props.anchor2);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    		if ("currentuser" in $$props) currentuser = $$props.currentuser;
    		if ("div" in $$props) $$invalidate(2, div = $$props.div);
    		if ("autoscroll" in $$props) autoscroll = $$props.autoscroll;
    		if ("input1" in $$props) $$invalidate(3, input1 = $$props.input1);
    		if ("formdata" in $$props) formdata = $$props.formdata;
    		if ("requestOptions" in $$props) requestOptions = $$props.requestOptions;
    		if ("comments" in $$props) $$invalidate(4, comments = $$props.comments);
    		if ("uuser" in $$props) uuser = $$props.uuser;
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*name*/ 2) {
    			 addCookie(name);
    		}
    	};

    	 $$invalidate(1, name = asda());

    	return [
    		anchor2,
    		name,
    		div,
    		input1,
    		comments,
    		handleKeydown,
    		alertmsg,
    		autoscroll,
    		currentuser,
    		socket,
    		formdata,
    		requestOptions,
    		uuser,
    		headdiv_name_binding,
    		div0_binding,
    		div1_input_handler,
    		div2_binding
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    const app = new App({
    	target: document.body,
    	props: {
    		name: 'world'
    	}
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
